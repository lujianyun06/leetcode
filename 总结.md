该看：:看完了👀


tO(x) : 时间复杂度
sO(x): 空间复杂度

#遍历问题--如在数组中遍历找多个数字组合成为目标
```
》在数组中遍历找到两个共同符合条件的数字，使用map存储已经遍历过的数字，并在遍历到新数字时看它的搭档是否已经遍历过了： 1


》对于数组中连续多个元素满足条件（重点在连续）
    》双指针法，一般都可以显著降低复杂度，双指针法又可以称为窗口法，一般可以把遍历的n^2复杂度降低为n
    一般做法是：窗口从一端开始（假设从最左端），窗口中值不满足条件时，窗口往后延伸，满足条件时，窗口往前缩小，如果还满足就再缩小，直到不满足时，再往后延伸直到窗口到达另一端，这样可以遍历到所有满足条件的连续元素情况，复杂度是O(n)

    》双指针法还可以用于窗口固定的情况，即如果要求固定数量元素符合条件的情况，如一串数组中，求连续2个，或连续3个和最大的情形，就要把窗口固定为2或3，前后指针同时移动，保证窗口内元素个数一定，在每次更新窗口时，遍历窗口内的值。

    》双指针法求当前窗口能包含的最大面积，面积=宽度*高度 ，宽度一般就是窗口两边横坐标之差，高度可以是窗口内最小的元素，可以让两指针一开始分别在数组两侧，每次将指针高度更小的一个向另一侧移动，当长度减小时，要使得面积大，只能是高度增加，所以应该保留高的，让矮的前进，在长度减小的情况下，尽量保持可用的高度最高，这样面积就能尽可能地大，记录每一步窗口面积，最终得出最大值  ：11


》 数组中找到共同满足条件的N个元素：代表 2sum、3sum、4sum
  》N指针法（如双指针，三指针，由于这里不要求连续元素组成，所以不能叫做窗口法）
  	》双向双指针求3sum：首先要将数组排序，遍历每个数字，对于每个数字，指针l从它左边开始往左走，指针r从它右边开始往右走，当该三个数字满足条件时，加入结果集，两个指针都挪动；当和小于条件时，右指针右移；当和大于条件时，左指针左移。 该题暴力遍历复杂度为O(n^3)，双指针法复杂度为O（n^2）： 15
    》对于4个数字求和，则是：先对每个数遍历，当遍历到某个数时，则目标减去该数为新目标，则变成了求3数和，可用双向双指针法。 18
      》其他方法：遍历到某个数时，目标减去该数为新目标，变成3数求和，范围为该数后面的部分。继续遍历，目标减去该数为新目标，变成2数求和，两数求和就可以是简单的二重循环枚举了。


》 数组中找到3个元素之和，使其最接近目标 : 16
    》也使用双向双指针法，对于每个元素，都用2个指针分别从其左右向两边移动


》给出一个数组和一个值t，找到数组中能组成t的所有组合（数组中的数可以重复）
    如[2,3,5], target = 8  答案是 [ [2,2,2,2], [2,3,3],[3,5] ]
    典型的trackback，用递归调用函数。
        2->2,2->2,2,2->2,2,2,2(满足，回退)
         ->去掉上一个2：2,2,2->2,2,2,3(大了，回退)
         ->去掉上一个3：2,2,2->2,2,2,5(大了，回退)
        --->2,2,3->2,2,3,3(这里3后面不再接2了（子函数的遍历不是从头开始，而是从父函数传入的位置开始），大了，回退)
        ->2,2,3,5(大了，回退)->2,2,5(大了，回退).......


》给定n个非负整数，表示一个高度图，其中每个条的宽度为1，计算它在雨后能够截留多少水。：42
    利用栈中放入索引的方式。（该方式很重要）
    该题关键理解点在于，遍历高度，

    check: 对于某高度来说，每次都看它是否能和栈顶的下一个元素索引的高度构成矩形（即该高度是否大于栈顶索引对应的高度）
        若能，则矩形高度= min（该元素-栈顶，栈顶下一个元素），宽度=当前元素索引-栈顶下一个元素索引，总面积+= 高度*宽度 弹出栈顶索引，由于栈顶索引变了，继续check，直到上述的不能，或者栈顶的下一个元素为空
        这么看下来栈中的连续三个元素不会保留”高矮高“的情况，当出现这种情况时，一定会被处理了，即矮的一定会被弹出（这句话是核心）
        过了check的循环后，入栈当前元素索引
        若不能，则只会入栈当前元素索引，不会对它计算，因为不能以它为右边构造矩形

        例如对于 4 2 3 5的高度来说
        遍历到3时，取出2的索引，宽度是4到3之间的宽度，高度是 min(3-2,4-2), 再放入3的索引
        遍历到5时，取出3的索引，宽度是4到5之间的宽度，高度是 min(5-3,4-3), 再放入5的索引

    》步骤
    循环遍历高度
        循环（若栈不为空，且当前高度大于栈顶高度）
            top=弹栈（栈顶矩形索引）
            若栈为空，break
            宽度 = 当前索引-当前栈顶索引-1
            高度 = min(当前栈顶对应高度，当前高度)-top对应的高度
            面积 += 宽度 * 高度
        压栈当前索引
          |
    | 1 1 |
    | 0 | |
    | | | |
    | | | |
    0 1 2 3 如上图：第一次加面积的时候加入了0的部分，第二次加面积加入了1的部分


》连续子数组的最大和：给定整数数组，找到具有最大和的相邻子数组(至少包含一个数字)并返回其和。： 53，j42-p218，b32
    核心思想是，与其让前面的和把该数抵消得更小，还不如从该数开始算。
    复杂度要求O(n)
    这个题不适合双指针，双指针也很麻烦，降低不了复杂度，
    遍历数组，初始化一个maxSoFar=nums[0];
        当遍历到nums[i]时, 如果nums[i] 大于 maxSoFar+nums[i]，说明前面累加的和还会抵消掉nums[i]，那么从nums[i]重新开始累计，令maxSoFar = nums[i]
        如果nums[i] 小等于 maxSoFar+nums[i]，说明可以起到累加的效果，令maxSoFar = nums[i]+maxSoFar
        综合上面两种情况，即为 maxSoFar = Math.max(nums[i]+maxSoFar, nums[i]);
        每次更新完后，更新maxTotal = Math.max(maxSoFar, maxTotal);
        这种方法的关键在于及时止损，如果x前面的累加和加上x还能比x小，那么直接不要前面的了，从x重新开始
    maxTotal记录已经出现过的最大值

    》动态规划，其实和上面的方法思想相同
        dp[i]是截止加到nums[i]时连续子数组的最大值
        当dp[i-1]>0时
            dp[i]=dp[i-1]+nums[i]
        当dp[i-1]<=0时
            dp[i]=nums[i]


    

》找出k个数字的所有可能组合，它们加起来等于一个数字n，假设只能使用1到9之间的数字，并且每个组合应该是一组唯一的数字。
    例如  Input: k = 3, n = 9   Output: [[1,2,6], [1,3,5], [2,3,4]]
    使用trackback
    trackBack(int start, int k, int rest, List<Integer> list) //rest是前面加和后剩下的数字
        if(list.size==k 且 rest==0) 找到一个答案
        if(list.size>=k 且rest>0) return;
        if(start>rest) return;
        for i从start到9 ，闭区间
            if(i>rest) break;



》给定一个只包含正整数的非空数组，找出该数组是否可以划分为两个子集，使两个子集中的元素之和相等。：416
    数组是否能被分成两个集合，和相等，则每个集合中的和都是总数的一半
    先算所有数字之和，如果是奇数，则肯定不行；如果是偶数
    先把数组排序，如[1,5,5,11]
    判断最后一个数，如果小等于和的一半，则成立，如果大于和的一半，则不成立，而且这个不能用回退递归，太慢了

    这个问题基本上是让我们找出集合中是否有多个能够求和到特定值的数字（在这个问题中，值是sum / 2）。

    实际上，这是一个0/1背包问题，对于每个数字，我们可以选择与否。 让我们假设dp[i][j]表示是否可以从前i个数中得到特定的和j。 如果我们可以从0-i中选择这样一系列数字，其总和为j，则dp [i] [j]为真，否则为假。

    基本情况：dp [0][0]为真; （零数由0和0组成）

    第i个数字是nums[i-1]
    转换函数：对于每个数字，如果我们选择不使用它，dp [i] [j] = dp [i-1] [j]，这意味着如果第一个i-1元素已经使它成为j，dp [i][j]也会把它变成j（我们可以忽略不要nums[i-1]）。 如果我们选择使用nums[i-1]。 dp [i][j] = dp [i-1][j-nums [i-1]]，表示j由当前值nums [i-1]组成，剩余部分由其他先前数字组成。 因此，转移函数是dp [i][j] = dp [i-1][j] || dp [i-1] [j-nums[i-1]] (第i个数是nums[i-1])
    最后遍历所有的dp[i][sum/2] (i从0到len-1)，若有一个为true则为true，否则为false



》给你一个非负整数的列表，a1 a2…， an, 可以给其中得数附上符号+或-，使其加和成为s，求一共有多少种组合方式：494
    直接用回退递归,可以过，但是速度太慢了，运行时间是指数级别的
    原始问题陈述相当于：
    找到需要为正的nums子集，其余为负数，使得总和等于target

    设P为正子集，N为负子集
    例如：
    给定nums = [1,2,3,4,5]和target = 3，那么一个可能的解决方案是+ 1-2 + 3-4 + 5 = 3
    这里正子集是P = [1,3,5]，负子集是N = [2,4]

    然后让我们看看如何将其转换为子集求和问题：
                  sum(P) - sum(N) = target
    sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)

    因此，原始问题已转换为子集求和问题，如下所示：
    找到n的子集P，使得sum（P）=（target + sum（nums））/ 2

    显然如果 target + sum（nums）是奇数就没有适合的解    
    如果是偶数，

    可以转换成0-1背包问题，从数组中找到若干个数，使得和为sum（P）
    dp[i][j]是前i个数（可以1个都不包括），和为j的可能性数
    if(j>=nums[i-1])
        dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
    else
        dp[i][j] = dp[i-1][j];

    dp[0][0]=1;
    dp[0][j]=0;   sum>=j>=1


》根据上面两道题的意思，可以得出：给定一个数组，选出若干个和为target的组合的可能性或者可能性数
    可以转换成0-1背包问题，从数组中找到若干个数，使得和为sum（P）
    dp[i][j]是前i个数（可以1个都不包括），和为j的可能性数(可能性)： 下面是两种不同问法的答案，一种是整型数组(可能性数)，一种是布尔型数组（可能性）
    if(j>=nums[i-1])
        dp[i][j] = dp[i-1][j] +(||) dp[i-1][j-nums[i-1]];
    else
        dp[i][j] = dp[i-1][j];

    dp[0][0]=1(true); 
    dp[0][j]=0(false);   sum>=j>=1



》找出数组中和为k的连续子数组，返回有多少个这样的子数组：560
    》方法一
    可以对与每一个数作为开头，算它与后面的连续数组之和，这样会很慢，但能过

    》方法二：
    上面主要耗时间的步骤是计算sum[i，j]并判断是否等于k,但如果我们知道sum[0,i-1]和sum[0,j]，其实也就知道了sum[i,j]，
    所以当sum[i,j]==k时，sum[0,i-1] = sum[0,j] - k，不需要知道i是多少，只需要只有没有，有几个即可，
    由于可能会出现负数，所以sum[0,i-1]这个数可能出现不止一次，其实用图像来想象这个过程会很容易
    用HashMap来保存出现过的sum[0,j]的次数
    //方法二：
    /*
    */
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> preSum = new HashMap<>();
        int result = 0;
        int sum=0;
        preSum.put(0,1);
        for(int i=0;i<nums.length;i++){
            sum += nums[i];
            if(preSum.containsKey(sum-k)){
                result += preSum.get(sum-k);
            }
            preSum.put(sum, preSum.getOrDefault(sum, 0)+1);
        }
        return result;
    }


》和为s的连续正数序列：j-p282
    输入一个正数s,打印出所有和为s的连续正数序列（至少含两个数），例如，输入15，由于1+2+3+4+5 = 4+5+6+7 = 7+8=15,
    所以打印出3个连续序列： 1~ 5， 4~ 7， 7~ 8
    用双指针窗口法，p1,p2分别为前后指针  sum为窗口内所有元素之和，p1< p2,且 array[p1] < 1+(s/2)
    若sum< s，p2++ sum+=array[p2]； 若sum>s，p1++  sum-= array[p1]；若sum==s，将p1到p2全部加入一个列表，并把该列表加入结果集，且p2++，sum+=p2

    该题和560的区别是，该题的”数组“是无界的，即所有自然数，所以不可能求出所有的sum，用窗口法是更合理的



》查看数组内有没有从左往右递增的三个数，这三个数可以不挨着：334
    只遍历一遍，而且空间复杂度O（1）

    以下是一个巧妙的算法

    small永远是遍历过的数中的最小值
    mid永远是比small大，且排在small后面，到当前数中的最小值
    再遇到比small和mid大的数时，则说明满足条件

    if语句能保证small，mid的次序是对的

    这个题还可以拓展，如果问四个连续增加数，则再加一个，五个就再加1个。。。

    class Solution {
        public boolean increasingTriplet(int[] nums) {
            int small = Integer.MAX_VALUE;
            int mid = Integer.MAX_VALUE;
            for(int num: nums){
                if(num <= small){
                    small = num;
                }
                else if(num <= mid){
                    mid = num;
                }else{
                    return true;
                }
            }
            return false;
        }
    }


》计算4个数组A, B, C, D中各取一个数得到和为0的取法总数：454
    直接用O(n^4)做会超时
    好做法是先算A和B的各个和值，保存起来，再去算C和D的和值，也就是“中途相遇法”

    需要注意的是，重复的组合也算，比如A中有两个1，那么计算次数的时候1算两次的
    （那个加不同符号和为指定数的题：top100liked-494）

    HashMap<Integer, Integer> map1 = new HashMap<>(); 
    HashMap<Integer, Integer> map2 = new HashMap<>(); 
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        for(int i=0;i<C.length;i++){
            for(int j=0;j<D.length;j++){
                int sum = C[i]+ D[j];
                map1.put(sum, map1.getOrDefault(sum, 0)+1);
            }
        }
        int res = 0;
        for(int i=0;i<A.length;i++){
            for(int j=0;j<B.length;j++){
                int sum = A[i]+ B[j];
                res += map1.getOrDefault(-1 * sum, 0);
            }
        }
        return res;        
    }


》给定一组候选数字编号和一个目标数字，找出候选数字之和等于目标数字的所有唯一组合。
    候选项中的每个数字只能在每个组合中使用一次。
    注意:

    所有的数字(包括目标)都是正整数。
    解集不能包含重复的组合。

    先把数字排序，然后使用标准的trackback，用list记录当前已经加过的数字，当和值等于目标值时，结果集添加当前list
    用递归，一个一个加着试，每次只加比当前数字大的数字，当剩余的目标值小于当前准备加的数字，则后面的数字都不用加了


》最小的k个数   j40-p209
    输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

    》方法一：会改动原数组
    可以基于快排中的Partition函数来解决这个问题。如果基于数组中的第k个数字调整，使得比第k个数字小的所有数字都位于数组的左边，比第k个数字大的所有数字都位于数字右边，这样调整后，位于数组中左边的k个数字就是最小的k个数字（这k个数字不一定是排过序的） 但该方法的弊端是必须要修改原数组（对其进行快排）。
    Partition后，枢轴索引若小于k，则继续Partition枢轴右边的数组；若枢轴索引大于k，则Partition左边的数组

    》方法二：适合海量数据，k小n大的情景
    先创建一个大小为k的容器来存储最小的k个数字，然后从输入的n个整数中读入一个数,如果容器中的数字少于k个，则直接把这次读入的数据放入容器，若容器已满，则不能再插入新值，找到容器中的最大值，若待插入的数字比当前最大值小，则将该数字替换该最大值，否则不变。
    可以使用PriorityQueue来做，让queue中的数字始终以降序排列，即队头是最大的数字，当遇到一个数且队列容量为k时，比较队头的数字和该数字，若该数更小，出队，然后把该数入队即可


》给定一个已经按升序排序的整数数组，找到两个数字，使它们加起来等于一个特定的目标数字。：167, j57-p280
    函数twoSum应该返回这两个数字的索引，使它们之和等于目标，其中index1必须小于index2。

    》方法一：tO(n*logn)
        遍历数组，每遍历到一个数字cur时，用二分搜索去查找与其和为目标值的另一个数
        如果当前遍历到的数cur的索引和查找后的索引相同，则看cur后面一个数是不是与cur相等，等的话按序将cur的索引，及cur的索引+1放入答案集，这一步很重要，主要是解决某个数重复出现的情况

    》方法二：tO(n)
        双指针法，p1从头向尾走，p2从尾向头走，设 sum = array[p1]+array[p2]
        若sum>s,p2--; 若sum< s, p1++, 若sum==s, 记录一下，然后p1++，最后要找二者乘积最小的。




》给定一个由n个正整数的数组和一个正整数s，找出其和≥s的相邻子数组的最小长度。如果没有，则返回0。：209
    》方法一：
    n^2的方法很好找，就是两个遍历，每次选一个数字作为当次循环的开头，加入其后面的数字
    》方法二：
    使用双指针法，即窗口法，窗口中值小于s时，窗口往后延伸，大于等于s时，窗口往前缩小，每当遇到一个和满足的子数组，就和最小长度对比，若更小就更新最小长度


》找出k个数字的所有可能组合，它们加起来等于一个数字n，假设只能使用1到9之间的数字，并且每个组合应该是一组唯一的数字。：216
    k<9,所以用很简单的带start的trackback，然后找到符合条件的组合即可


》一个数组，要求把数组“切”成三组，并且必须保证第一个数组之和等于最后一个数组之和（允许任意一组是空），：b16
    最终第一组数组之和就是能得到的奖金，求最多能拿到的奖金

    如 1 3 1 1 4， sum1表示第一组中的和，sum3表示第三组中的和

    注意的是，第三组不能每次都从后往前重新开始，会超时

    i为第一组的后索引，j为第三组的前索引
        若sum3大于sum1，j不用动，i++ sum1+=d[i]；
        若sum3==sum1，加入结果集，i++ sum1+=d[i]；
        若sum3< sum1，i不动，j++，sum3+=d[j]

    注意的是，为了不把两端的情况漏掉，i从-1开始，j从n开始（因为每次添加d[i]或d[j]之前，i和j都要+1，所以不存在越界）

    从空开始，sum1=0，sum3=0，满足，加入答案集
    第一组加入1，sum1=1，sum3=0， sum3+=4
    sum1< sum3, sum1+=3
    sum1==sum3==4  4加入答案集。sum1+=1
    sum1(5)>sum3(4) sum3+=1
    sum1(5)==sum3(5) 5加入答案集，sum1+=1
    i=3,j=3跳出循环



》善变的同伴：b20
    给出一个数组，其中有正有负，给出一个数m（选取操作次数），表示最多可以在其中选取的连续子数组的个数，当然也可以一个都不取，上限为m，下限为0，求取出的数能达到的最大和是多少

    先对数组进行处理，遇到连着正的或者负的就累加在一起

        /*
        举几组例子方便理解：
        输入：7 7 【1 2 3 -2 3 -10 3】
        输出ss:[6 -2 3 -10 3]
        输入：10 1 【-1 2 4 -3 5 -7 11 24 -6 -9】
        输出ss:[-1 6 -3 5 -7 35]
        输入：6 1 【1 -2 -3 -4 -5 -6】
        输出ss：[1]
        输入：7 1 【1 -1 -2 -3 -4 2 3】
        输出ss：[1 -10 5]
        这样做的目的可以有效减少接下来二维dp的运算量
        否则本题直接用dp会因为运算量过大只通过80%的测试案例
        */


    ************求最大m子段和*********** 
    给定由n个整数（可能为负）组成的序列a1、a2、a3...,an,
    以及一个正整数m，要求确定序列的m个不相交子段，使这m个子段的总和最大

    定义二维数组dp， dp[i][j]，表示前 j 项所构成 i 子段的最大和，且必须包含着第j项，即以第j项结尾

    求dp[ i ][ j ]，有两种情况

    1、dp[ i ][ j ] = dp[ i ] [ j-1 ] + a[ j ] ，即把第j项融合到第 j-1 项的子段中，子段数没变；而且是融合进去总段数没变，且每个段中的元素必须是连续的，所以第j项只能融合进dp[i][j-1]

    2、dp[ i ][ j ] = dp[ i-1 ] [ t ] + a[ j ]，（i-1<= t < j ） a[j]是单独的一个子段，与前面的i-1个字段（a[j]前的最后一个子段不一定是dp[i-1][j-1],因为段内部是连续的，但是段之间不一定是连续的）

    for(int i=1;i<=m;i++){
        for(int j=i;j<=n;j){
            for(int t=i-1;t<=j-1;t++){
                dp[i][j] = max(dp[i][j-1], dp[i-1][t]) + a[j-1]
            }
        }
    }

    优化：
    dp[i][j] = max(dp[i][j-1], dp[i-1][t]) + a[j-1]  （a[j-1]是第j个数）,此时的dp[i-1][t]遍历 dp[i-1][i-1]...dp[i-1][j-1]

    对于dp[i][j+1] = max(dp[i][j], dp[i-1][t]) + a[j]  （a[j]是第j+1个数），此时的dp[i-1][t] 遍历 dp[i-1][i-1]...dp[i-1][j]，
    只比上一步的dp[i-1][t]多了一个dp[i-1][j]。

    因此，设一个max保存dp[i-1][t]的最大值, 每当我们计算到dp[i][j]时， max=(max, dp[i-1][j-1])
     计算到dp[i][j+1]时，只需要比较一下当前max和dp[i-1][j]，取其更大值即可，并把该更大值再存入max供下一个计算使用，这样就不用每次都遍历一遍t了，省去了一个复杂度

    改进为：
    for(int i=1;i<=m;i++){
        int max = 0;  //对同一个i，max要跟着j的更新而更新，max保存dp[i-1][t]持续的最大值（因为t的上限跟着j不断变化，所以是持续的最大值）
        for(int j=i;j<=n;j){
            max = Math.max(max, dp[i-1][j-1]);
            dp[i][j] = Math.max(dp[i][j-1], max)+a[j-1];
        }
    }
    遍历所有的dp[m][?],最大值即为答案，要求是让必须分成m段，所以要取第一个维度为m
    ***********证明结束***********


    因为该题是比上面更复杂一步，可以取小于m个段，所以要遍历所有的dp[i][j]，找出其中的最大值
    由于对数组已经预处理过了（连续的正和负合并）预处理后为ss，就直接使用ss代替上面算法中的a即可



》给一个数组，询问多少个区间和在某个[lower,upper]之内。：327

    求出前缀和sums[i] 。
    归根结底是要计算sums[j]-sums[i] （j>i）满足条件的个数,对sums使用归并排序，在每次归并完左右两个子区间后，当前区间两部分分别都已经排序完毕，然后将这两部分归并
    此时只需计算前半部分sums当做sums[i]，后半部分sums当做sums[j]时，满足条件的个数
    lower<=sums[j]-sums[i]<=upper  --->   sums[j]-upper<=sums[i]<=sums[j]-lower
    对于sums[i]，找到第一个满足条件的j，令为l，以及l后第一个不满足条件的i，令为r
    因为sums[j]和sums[i]是单调递增的，因此，对于i+1对应的l和r只会比i对应的l和r更大
    l和r是单调不减的。，因此该循环的总复杂度是O(n)，
    归并的复杂度是logn，因此总复杂度是nlogn

    这里有两个技巧，
        1.为了让sum[i]满足条件时自身也能算入，且nums都能被sum的表达式表示，令sums长度为n+1，
          且让sums[0]=0，sums[i+1]=sums[i]+nums[i]。这样任何sums[i]-sums[0]=sums[i]如果满足条件就会被算入了；任何nums[i]
        2.归并的时候要满足待归并块大于2个，当待归并块只有一个时（即low==high），不进行操作




》给定一个已排序的正整数数组编号和一个整数n，向数组中添加元素，使范围[1,n]内的任何数字都可以由数组中某些元素的和组成（每个数字只能用1次）。返回所需的最小补丁数量。：330

    假设输入为nums = [1、2、4、13、43]和n =100。我们需要确保范围为[1,100]的所有和都是可能的。
    使用给定的数字1、2和4，我们已经可以建立从0到7的所有和，即范围[0,8）。 但是我们无法建立和8，下一个给定的数字（13）太大。 因此，我们将8插入数组。 然后，我们可以在[0,16）中建立所有和。
    我们需要在数组中插入16吗？ 不需要！ 我们已经可以建立和3，将给定的13加到我们得出的总和为16。我们还可以将13加到其他总和上，将范围扩展到[0,29）。
    等等。 给定的43太大，无法求和29，因此我们必须在数组中插入29。 这将我们的范围扩展到[0,58）。 但随后43变得有用，并将我们的范围扩展到[0,101）。 至此，我们完成了。

    如果当前第一个达不到的和大等于下一个待加入的数字，则直接把下一个数字加入集，更新下一个达不到的和；
    如果当前第一个达不到的和小于下一个待加入的数字，则把这个和插入集中，更新下一个达不到的和为2倍的该和

    当和为[1...i）时都能满足，第一个达不到的数是i，若数组中下一个数字是x>i，显然不能加入x，此时加入i，则第一个达不到的和成了2i，2i前面的数都能达到，
    因为1到i-1都能达到，i也能达到，所以下一个达不到的是2i；若2i>=x, 把x加入集中，则此时第一个达不到的和成了2i+x，
    为什么2i到2i+x之间的数能到达？此时显然能到达的数有：1，2，... 2i, x。那么显然1+x,2+x,....2i+x-1都能达到，且1，2,...2i都能到达，二者取并集，所以
    1，2，.... 2i+x-1都能到达

    但这个结果为啥是要加的最小个数，不知道怎么证明


》最大值减去最小值小于或等于num的子数组数量：c-p31
给定数组arr和整数num，共返回有多少子数组满足如下情况：
max(arr[i..j])-min(arr[i..j]) <= num
max(arr[i..j])表示子数组arr[i..j]中的最大值，
min(arr[i..j])表示子数组arr[i..j]中的最小值。
实现O(N)的算法

    普通解法是求出每个子数组，再在每个子数组中得出最大值和最小值看是否满足条件，复杂度是O(N^3)

    借助于”生成窗口最大值数组“中的双端队列的思想，生成两个双端队列qmax和qmin，一个存储大值的下标，一个存储小值的下标
    其队列原则与原来的基本一致：
    遍历到num[i]时：
    若num[i]>=qmax头端的索引对应的值，则qmax全出队，num[i]入队
    否则从qmax尾端比较，从尾端出队直到尾端的值大于等于num[i]，再压入num[i]

    若num[i]<=qmin头端的索引对应的值，则qmin全出队，num[i]入队
    否则从qmin尾端比较，从尾端出队直到尾端的值小于等于num[i]，再压入num[i]

    qmax维护了窗口子数组arr[i..j]的最大值的更新结构，qmin维护了窗口子数组arr[i..j]的最小值的更新结构。当子数组arr[i..j]向右扩一个位置变成arr[i,j+1]时，qmax和qmin结构可以在O(1)的时间内更新，当子数组arr[i..j]向左缩一个位置变成arr[i+1,j]时。qmax和qmin结构仍可以在O(1)的时间内更新，并在O(1)的时间内获得最大最小值。

    结论：
    1.如果子数组arr[i..j]满足条件，那么arr[i..j]中的每一个子数组都满足条件
    2.如果子数组arr[i..j]不满足条件，那么所有包含arr[i..j]的子数组都不满足条件。

    步骤：
    1.用两个变量i和j表示子数组的范围。res为结果
    2.令j不断向右移，即j++，表示arr[i,j]向右扩大，并不断更新qmax和qmin
    一旦出现arr[i..j]不满足条件，j停止向右扩。此时arr[i..i], ... arr[i,j-2], arr[i, j-1]都满足条件，即所有以arr[i]作为第一个元素的子数组，满足条件的数量为j-i个，res+= j-i
    3.进行完步骤2，令i向右移动一个位置，并对qmax和qmin更新，然后重复步骤2，也就是求所有以arr[i+1]作为第一个元素的子数组中，满足条件的数量有多少个。
    4.根据步骤2和步骤3，依次求出以arr[0], arr[1] ... arr[n-1]作为第一个元素的子数组中满足条件的数量分别有多少个，加起来就是结果

    有两个点要注意：第一层循环中条件不能加j< len，因为最后一个子数组的时候arr[len-1, len-1]需要j为len
    在更新最大最小值的过程中，如果当前j在队列中，则要先将其出队，然后再入队，否则直接入队会造成队列中存在重复值（虽然对结果没有影响）。因为此时若j不满足条件，则j对应的值会被更新进qmax，然后跳出循环；i更新后，又会进入j的循环，j对应的值又会被更新进qmax，所以如果已经在的话，先出队，然后再入队，保证个数正确





```


```数组问题
》在数组中删除某值，剩下的元素按需前移：如 [0,1,2,2,3,0,4,2],删除2后为[0,1,3,0,4,?,?,?], ?代表可以是任何数：27
    》也使用双指针，指针m指向当前最后一个要替换的位置，指针n指向当前不是2的元素，先动m, 当m到2时，m不动了，动n，直到n不为2且n下标>m下标，将n的数换到
    m处，m和n同时加1，然后重复上面的动作，直到m到头, 复杂度= tO(n)+sO(1)


》数组中删除重复值，且元素都归到前面来（只保留一个）： [0,0,1,1,1,2,2,3,3,4] -》 [0,1,2,3,4,?,?,?,?,?]： 26
        难点在于保证 sO(1) 
        用3个值：pre代表上一次出现的值，mod代表当前准备替换的坐标，i是当前遍历到的位置，还有关键点在于pre和mod的初始值。
        i用于循环，当num[i]与pre不等时，说明出现了新值，更新将num[mod]=num[i],更新mod=mod+1，更新pre为num[i]
                  当num[i]与pre等时，说明还是旧值，mod，pre不变，i继续遍历

》替换数组中的值，可能把一个值替换成多个值，如 [1,2,3,4,2,5] 把2替换为7，8  结果为 [1,7,8,3,4,7,8,5]
    还是要新开一个数组，先遍历一遍得到要替换的个数，可知新开的数组大小，然后遍历即可，当遍历到原数组的2时，新数组放入7，8；遍历到其他数时，拷贝该值到新数组，复杂度是tO(n)+sO(n)

》合并两个有序数组：有两个排序的数组a1和a2，a1的末尾有足够多的空间容纳a2，实现一个函数，把a2所有数字插入a1中，并且所有数字是排序的  ： j5-p55，88
    时间和空间复杂度都低的办法：从尾到头比较a1与a2的数字，并把较大的数字复制进a1的合适位置（尾部往前,索引从len1+len2-1开始，逐渐减小）
    这是个非常好用的办法，tO(n)+sO(1)


》就地翻转数组（空间复杂度=O(1)），假设数组长度为len，则就是交换下标和为len-1的两个数  for(int i=0;i<len/2;i++)
    [0,1,2,3,4,5] --> [5,4,3,2,1,0]


》排好序的数组，循环移位后，(一般描述可能是：按升序排序的数组在某个未知的主轴上旋转）（关键词：循环移位，两段序）
    有序序列相当于经过了若干次循环移位，把序列分成两个部分，一部分一定是有序的，而另一部分是两段序

    》查找某个数target的下标 ： 33
        仍可使用二分查找：
            while(high>=low)
            mid= (low+high)/2;
            若num[mid]==target 返回mid;
            1. num[mid]<num[high] 说明mid-high是正序
                if(target落在 mid~high之间)：low=mid+1
                else： high=mid-1
            2. num[mid]>=num[high] 说明low-mid是正序
                if(target落在low~mid之间)：high=mid-1;
                else：low=mid+1;
            return -1;


    》找出最小元素：数字不重复（153）、数字可能重复(154), j11-p82
        仍可使用二分查找：
            while(high>low)
            mid= (low+high)/2;
            只要判断high和mid指的数的大小关系就能确定前后的序了，这里因为mid有可能就是最小元素，所以high只能变成mid不能变成mid-1
            因为：
            1. nums[mid]>nums[high]时，说明mid到high之间有两段序，最小值一定在之间
                low = mid+1
            2. nums[mid]< nums[high]时，说明mid到high之间是顺序，最小值一定在这个区间之外（或者就是mid）
                high = mid;
            3. nums[mid]==nums[high] (如果数字有重复的情况) 
                if(nums[high-1]>nums[high]){
                    low = high;
                    break;
                }
                high = high -1;
            则直接让high=high-1既可以缩小范围，又不会丢数（因为mid数和high数一样大，所以不会丢失）。上面的if中的部分，是为了保证如果返回索引而不是值时，能返回正确的首索引（返回low）
            return num[low];

    》给定要搜索的目标值。如果在数组中找到，返回true，否则返回false。（其中可能有重复元素）：81
       [0,0,1,2,2,5,6]可能变成[2,5,6,0,0,1,2])。

        对整个数组处理，看mid和low， high的大小关系，如果 mid>low，则前面是顺序，直接可以用二分，后面是一部分顺序一部分逆序,继续处理

        相比于之前的二分，这个题不能简单那么做，因为有重复元素，边界条件很难判定

        1)每次检查targe == nums[mid]，如果是，我们就找到它。
        2）//区别于上述的最关键一步：若left，mid，right的值相同，则同时缩小左右范围
            if( (nums[left] == nums[mid]) && (nums[right] == nums[mid]) ) {++left; --right;}
        3)否则，检查前半部分是否是顺序(即nums[left]<=nums[mid])
        如果是，请转到步骤3)，否则，请转到步骤4)
        4)检查target是否在[left, mid-1]范围内(即nums[left]<=target < nums[mid])，如果是，则在前半部分进行搜索，即right = mid-1;否则，下半部分搜索 left = mid+1;
        5)检查target是否在[mid+1, right]范围内(即nums[mid]< target <= nums[right])，如果是，则在后半部分进行搜索，即left = mid+1;否则前半部分进行搜索 right=mid-1;



》一个排好序的数组，找出给定目标值的起始和结束位置 （要求复杂度为logn）：34
    一般，logn的复杂度就一定要用二分
        mid= (low+high)/2;
        if(nums[mid]>target) //所有target全部落在 low-mid之间
            high = mid-1;
        else if(nums[mid]<target) //所有target全部落在 mid-high之间
            low = mid+1;
        else //target == nums[mid]
            if(mid-1 < 0 || (mid - 1 >= 0 && nums[mid-1]<target)) //mid是左边界 把mid设置给全局变量l
            if(mid+1 >= nums.length || (mid + 1 < nums.length && nums[mid+1]>target)) //mid是右边界，把mid设置给全局变量r
            如果左边界没找到，则继续二分查找 low到mid-1
            如果右边界没找到，则继续二分查找 mid+1到high 


》给定一个整数数组和一个整数k，找出数组中是否有两个不同的索引i和j，使得nums[i] = nums[j]，并且i和j之间的绝对差不超过k。：219
    使用HashMap<Integer, List>的形式，key是数组中出现过的数字，list存该数字的所有索引，当遍历到一个数时，取出该数对应的上一个索引，
    看差值是否满足，如果上一个都不满足，那么前面的就没必要再比了


》给定一个包含n个0、1或2的数组，对它们进行排序，使相同的数字相邻，顺序为0、1和2。：75
    双指针定位，单指针扫描(一共3个指针，因为如果用双指针的话，当p1和p2都遇到1的时候就卡住了，必须有其他人来打破僵局)，p1和p2分别从前后往中间靠，p1到达第一个不为0的地方，p2到达第1个不为2的地方
    p每次从p1开始往后走（因为p1前面的一定是0，没必要再看了），遇到0则和p1的值交换，p1继续往后走到不为0的地方，p再遇到2与p2交换，p2走到不为2的地方（这里p与p2,p1交换，而p1和p2互相不交换）遇到1继续走不管，停止的条件是p1超过p2 或 p超过p2



》给出一个数组所有可能的子集：78
    简单的回退递归


》给一个数组代表一排矩形，矩形的宽都是1，让求能构成的最大矩形面积：84
    对于任何条形i，最大矩形的宽度为r-l-1，其中r是条形i的右边的一个坐标，r低于i，i+1到r-1的条形都不低于i，l是条形i坐标左边的一个坐标 l+1到i-1的条形都不低于i，l低于i对于i，l是i左边离i第一个的比它低的矩形坐标，r是i右边第一个比它低的矩形坐标

        int maxArea = 0;
        for（int i = 0; i <height.length; i ++）{
           maxArea = Math.max（maxArea，height [i] *（lessFromRight [i]  -  lessFromLeft [i]  -  1））;
        }
    lessFromLeft[i] 表示i左边最近的比height[i]的矮的坐标
    主要技巧是如何有效地计算lessFromRight和lessFromLeft数组。平凡的解决方案是使用O（n ^ 2）解决方案，并且对于每个i元素，首先在第二个内部循环中找到他的左/右heighbour，只是向后或向前迭代：

    普通的办法：
    for（int i = 1; i <height.length; i ++）{
        int p = i  -  1;
        while（p> = 0 && height [p]> = height [i]）{
          P--;
        }
        lessFromLeft [i] = p;
    }
    唯一的行更改将此算法从O（n ^ 2）转移到O（n）复杂度：我们不需要重新扫描左边的每个项 - 我们可以重用先前计算的结果并快速“跳转”索引：

    # 如何在一行数组中高效查找每个元素左边比它小的最近的元素

    for（int i = 1; i <height.length; i ++）{
        int p = i  -  1;
        while（p> = 0 && height [p]> = height [i]）{
          p = lessFromLeft [p];
        }
        lessFromLeft [i] = p;
    }

    这个思想有点像滑动窗口，但它的窗口主体是每个条形边的左右滑动，而不是从头到尾的遍历数组
    还有一个技巧在于p的搜索，比如寻找左边界，当p到达x时（x在i前面）还不满足，说明h[x]肯定比h[i]大，
    那就p直接跳转到lessFromLeft[x]的地方（第一个比h[x]低的位置）再去比较h[p]和h[i]的高度，
    而对于lessFromRight，要从后往前来找

    最后遍历一遍i，计算 height [i] *（lessFromRight [i]  -  lessFromLeft [i]  -  1）的最大值



》给定一个整数数组，找出数组中是否有两个不同的索引i和j，使得nums[i]和nums[j]之间的绝对值差最大为t, i和j之间的绝对值差最大为k。：220
    使用TreeSet数据结构，可以借助TreeSet中有用的函数

    TreeSet.floor(x) 表示TreeSet中小于或等于x的最大元素
    TreeSet.ceiling(x) 表示TreeSet中大于或等于x的最小元素

    遍历数组元素
    对于数组中任意一个数nums[i], 与其绝对值差小于等于为t的区间为 [nums[i]-t，nums[i]+t],  数轴表示如下

             I__________I__________I
        nums[i]-t   nums[i]      nums[i]+t

    使用TreeSet的floor和ceiling函数，可以得到是否有数字在上述区间内
    即：f = floor(nums[i] + t) 且 f>=nums[i]，说明f在[ nums[i], nums[i]+t]内
       c = ceiling(nums[i] - t) 且 c<=nums[i]，说明c在[ nums[i]-t, nums[i]]内

    如果存在f或者c，然后要保证的是 它们的索引和i差距小于k，则只需维持TreeSet中始终只保留窗口大小为k的元素即可（在访问nums[i]时，TreeSet中始终只保留nums[i-k]到nums[i-1] ），int±t可能会溢出，所以TreeSet用Long保存

    这样，只要存在f或者c，就存在满足条件的值，因为TreeSet中元素的坐标都满足和i的约束关系
    若不存在，则把nums[i]加入TreeSet，删去nums[i-k]（因为下一个要访问的是nums[i+1]，nums[i-k]与nums[i+1]的坐标约束不满足）

    核心在于，本来要考虑i和j两个随机索引，现在只用考虑一个索引i和其前面的索引了，而其前面的索引由于TreeSet的关系，不用复杂的遍历
    不用担心有两个相同的数字会删去，当相同的数字会奏效时，已经满足条件了，就不会走后面的删除的逻辑了



》买卖股票，一个数组代表当天股票价格
    》只能买卖1次，求能得到的最大利润：121，j63-p304
        遍历数组，记录截止num[i]为止的最小值min，当num[i]< min 时，min更新为num[i]，否则计算profit=max(profit, num[i]-min)，为截止到num[i]，能达到的最大利润。遍历后，返回profit即可

    》可以买卖多次，但无法同时进行多项交易（即必须先出售股票才能再次购买）：122
        》方法一
            还是想象成折线图，则最大利润是在谷底买入，在谷后的第一个峰卖出，然后再在峰后的第一个谷买入，在这个谷后的第一个峰卖出
            两边都下降或左边下降右边相等的，为峰，两边都上升的或左边相等右边上升的，为谷，
            //第一个数不当峰，最后一个数不当谷
            //此时只需第一个峰-第一个谷，第二个峰-第二个谷。。。。直到有一方不存在，把所有的差加起来就是结果


        》方法二：
            直接遍历数组，若prices[i]>prices[i-1] 则res += prices[i]-prices[i-1]
            由于不限制次数，则可以一有价格差就买卖，而对于 3 8 10 这样的来说，3买，8卖，8又买了，10卖（8做了一个桥梁，事实上应该是3买，10卖，但这样中间加个桥梁，不影响整体，能得出答案也简单）


    》只能最多购买2次：123
        使用动态规划
        dp[k][i] 表示操作k步（买卖次数，买+卖算操作一次），截止到prices[i]能获得的最大利润

        对于dp[k][i],如果不考虑prices[i],那就是对前面i-1操作k次获得的利润，即dp[k][i-1]
        如果考虑prices[i], 有个难点是对于prices[j]，因为dp[k][i]是考虑进prices[i]的，所以有可能dp[k-1][j]中把prices[j]卖了
        而dp[k][i]算的时候又有prices[i]-prices[j]，相当于把prices[j]又买了，但其实就相当于prices[j]做了个桥梁，结果没有变，而操作步骤只会少而不会多
        因此就可以这么做（如[1,2,4],可以变成：1买入，2卖出，2买入，4卖出，看上去是2操作了两次，但这种连续的，最终结果也只是4-1）

        ## 下面是最关键的递推公式：
        dp[k][i] = max(dp[k][i-1], prices[i]-prices[j] + dp[k-1][j])  (j从0到i-1)
        dp[0][i] 操作0步能获得的最大利润，一定是0
        dp[k][0] 只对prices[0]操作 能获得的最大利润，一定也是0
        for (int k = 1; k <= op; k++) {
            for (int i = 1; i < len; i++) {
                for (int j = 0; j < i; j++) {
                    int tmp = Math.max(dp[k][i - 1], prices[i] - prices[j] + dp[k - 1][j]);
                    dp[k][i] = Math.max(tmp, dp[k][i]);
                    
                }
            }
        }
        这个DP的好处是不受限于k的值，不论k是几都可以做

    》最多买卖k次：188
        按照123题的做法，dp会提示Memory Limit Exceeded，当k=1000000000时，所需要的数组空间过大
        用下面方法，在k足够大的时候，（k大于等于prices个数的一半，能保证所有的prices都可以交易时），顺序遍历，只要有价格差就做交易，这样看起来就像是在同 一天进行买卖，其实不是
        如[1,2,4],可以变成：1买入，2卖出，2买入，4卖出，看上去是2操作了两次，但这种连续的，最终结果也只是4-1，只需要累加即可，这种情况只有在k足够大的情况才可以。如果k不是足够大，再用上面123的经典做法。

        具体做法是：
            当k大等于prices个数的一半时，遍历数组，只要prices[i]大于prices[i-1]，答案就+（prices[i]-prices[i-1]）
            当k小于prices个数的一半时，用上面123的做法





》LCS(最长连续序列)：128，c-p236
    给定一个未排序的整数数组，找出最长的连续元素序列的长度且用O(n)复杂度。如[100, 4, 200, 1, 3, 2]  连续的：[1,2,3,4]。

        不用排序，用HashSet可以达到O(n)的效果，把数组中的所有元素装入HashSet中，然后再遍历数组，当便历到一个x时，检查x+1，如果在，则以它开头的连续数字长度就+1；然后再检查x+2，如果在，则以它开头的连续数字长度就再+1... 直到检查的数字不在set中。
        如果遍历的时候一个数字x前面的数x-1在set里，说明它要么在后面会被检查到，要么已经检查完了，取决于x-1在x的前还是后。总之x就不用管了，直接continue


》给定一个非空整数数组，除一个元素外，每个元素都出现两次。找到那一个。：136
    把所有数字都异或一遍，最后的结果就是只出现过一次的那个数,时间复杂度O(n),空间复杂度O(1)


》给定整数数组nums，找到具有最大乘积的数组（包含至少一个数字）内的连续子数组。：152
    用max[i]表示 第i个数与它前面的数能构成的最大乘积
    用min[i]表示 第i个数与它前面的数能构成的最小乘积
    max[i] = Math.max(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])
    min[i] = Math.min(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])
    保存最小乘积是为了避免由于负负得正而漏情况，这样只需要O(n)的复杂度即可，最后再遍历一遍max数组找出最大值即可。



》众数1：给定一个大小为n的数组，找到一个元素。该元素出现次数不少于⌊n / 2⌋（该元素个数多于数组元素的一半）多次出现。：169， j39-p205
    可以假设数组是非空的，并且大多数元素始终存在于数组中。
    使用摩尔投票法：
    维护一个计数和一个数x，若遍历到的数为x，计数+1，否则减一，计数为0时，更换数x为遍历到的数，这样，最后x的数就是主数
    思想是，主数出现过超过一半的次数，则它可以和每个不是主数的数字抵消，最后还剩下至少1个
    （一开始要随便指定一个数）
    for (int num : nums) {
        if (count == 0) {
            majority = num;
            count++;
        } else {
            if (majority == num) {
                count++;
            } else {
                count--;
            }
        }
    }


》众数2：给定一个整数数组的大小为n,找到所有出现n / 3次以上的元素。要使用O(n)的时间和O(1)的空间复杂度：229
    可以证明，出现次数超过n/3的元素至多只有2个，(反证：假设有3个，则他们3个的总数就超过n了。)
    当要找超过三分之一的元素时，我们使用投票法的核心是找出两个候选众数进行投票，需要两遍遍历，第一遍历找出两个候选众数，第二遍遍历重新投票验证这两个候选众数是否为众数即可，选候选众数方法和前面那篇Majority Element求众数一样，由于之前那题题目中限定了一定会有众数存在，故而省略了验证候选众数的步骤，这道题却没有这种限定，即满足要求的众数可能不存在，所以要有验证。
    #下面是步骤代码，可看出，摩尔投票法可以用很小的代价计算出现次数超过 n/m的元素，超过n/m的元素不会超过m-1个，因此都可以用下面的方法
       #
        List<Integer> result = new ArrayList<Integer>();
        int number1 = nums[0], number2 = nums[0], count1 = 0, count2 = 0, len = nums.length;

        //用if-else确保不会对同一个数计算重复
        //注意的是，若某数出现了n/3次以上，经过遍历后一定在number1或number2中；但反过来number1和number2不一定是出现次数超过三分之一（若此时根本就没有出现超过三分之一的数字）
        for(int i=0;i<len;i++){
            if(nums[i]==number1){
                count1++;
            }else if(nums[i]==number2){
                count2++;
            }else if(count1==0){
                number1 = nums[i];
                count1=1;
            }else if(count2==0){
                number2 = nums[i];
                count2=1;                
            }else{
                count1--;
                count2--;
            }
        }
        //验证number1和number2是否真的出现了n/3次以上,用if-else，就算两者相同，最后也只会计算一个
        count1=0;count2=0;
        for(int i =0;i<len;i++){
            if(nums[i]==number1) count1++;
            else if(nums[i]==number2) count2++;
        }
        if(count1>len/3) result.add(number1);
        if(count2>len/3) result.add(number2);
        return result;
        #





》找数组中第k小的值：215
    一般遇到这种第k大的，就可以考虑堆排序了，或者快排也行
    但如果不允许修改数组，或者说空间复杂度是O(1),就不能排序了。

    》对于不能改变数组本身：
    如果不能改变数组中，那么就不能使用排序了。使用不断二分的方法
    首先记录数组中的最大值max和最小值min，在max和min中不断进行二分查找，对于每一个mid，找到数组中有几个数比它大，当数组中有k-1个数比它大时，说明它如果在数组中，是第k大的元素。
    假设该元素是x。接着遍历数组，找到不大于x的最大值(如果x在数组中，则肯定是x，如果不在数组中，则第k大的元素是比x小的最大元素)




》给定一个没有重复的排序整数数组，返回其范围的摘要。：228
    Input:  [0,1,2,4,5,7]
    Output: ["0->2","4->5","7"]
    定义一个表示当前范围的int[2] range， range[0]表示下界， range[1]表示上界
    遍历数组，
    如果该数=当前上界+1，则更新上界为该数，继续
    如果不是，则将当前上下界加入答案集中（上下界相同时，不用->；不同时，用->），然后把上下界都更新为该数，继续


》给定一个包含n个整数的数组，其中n>1，返回一个数组output，使output[i]等于除nums[i]外的所有nums元素的乘积。：238
    》方法一：把原数组中所有非0的数字都乘起来，如果原数组中0多于1个，则output都为0；如果只有一个num[i]为0，则output[i]不为0，其他output都为0，
            如果没有0，则 output[i]= num中所有元素乘积 / num[i]

    》方法二：第一遍循环，output[i]等于num[i]前面数(即)的乘积，但时间复杂度是O(n)
            做法是，维持一个数tmp，每次都让tmp *= num[i],而output[i] = 上一轮的tmp，这样能保证O(n)的情况下符合条件
            for (int i = 0, tmp = 1; i < nums.length; i++) {
                output[i] = tmp;
                tmp *= nums[i];
            }
            第二遍循环，output[i]再乘以nums[i]后面数的乘积，做法和上面相同，只不过是从后往前


》给一个n+1个数的数组，每个数大小都在1到n之间，其中只有一个重复的数，找到这个重复的数：287
    注意的是，只有一个数会重复，但它重复多少遍却不一定
    条件是不能动这个数组，常数空间复杂度，时间复杂度小于O(n^2)（也就无法排序了，而且也不能双重遍历了）

    把nums看成一个链表节点，索引i表示该节点位置，其值表示它的next节点的位置（画个图很直观）

    这个链表一定是有环的，因为每个节点的next一定是一个存在的节点(因为值是1到n，而节点位置编号范围是0-n)。
    而且也不可能完全是一个环，因为位置为0的节点一定没有前驱（没有节点的next是0）。因此整个图的抽象一定是若干个链表（可能是1个，可能是多个）汇聚成一个环，而且只可能有一个环，因为只有一个元素重复，代表如果有不同节点的next相同，那么这个next只有一种取值。

    重复的元素一定是环的起点位置，因为环内有一个节点的next是它，环外也有一个节点的next是它。因此找到这个环的起点即可，则用龟兔赛跑算法（Floyd判圈法）来找圈的起点.

    由于位置为0的节点一定没有前驱，所以0可以当做一个链表的头来作为算法的开始。🐢和🐰都在位置为0的节点处开始

    
》给定一个数组，编写一个函数将所有0移到数组末尾，同时保持非零元素的相对顺序。：283
    noZeroPos从0开始，遍历数组，当遇到不是0的数，放入noZeroPos的位置，noZeroPos++，遇到0则记录0出现的个数，最后再把有多少个0放到数组最后即可


》给定一个整数数组，其中1≤a[i]≤n (n =数组大小)，有些元素出现两次，有些元素出现一次。找到[1,n]中不出现在该数组中的所有元素。：448
    用tO(n)和sO(1)
    方法一：
        基本思想是我们遍历整个数组，当见过一个数时，就把它作为索引(由于是1开始，所以要-1)的数标记为负数:[4,3,2,7,8,2,3,1]
        如对于4，代表第四个数，索引为4-1=3：nums[4-1] = -nums[4-1]：-7，一圈标记下来，为：[-4,-3,-2,-7,8,2,-3,-1]
        通过这种方式，我们看到的出现过的索引所代表的数都将标记为负数。 
        在第二次迭代中，如果某个值未标记为负数，则表示我们之前从未见过该索引，因此只需将其添加到返回列表中即可。
        数组长度为n，数组中的数字小于等于n，大于等于1，当遍历到了nums[i]=x时，令nums[x]为负数，表示x这个数出现过
        当设负一遍后，所有出现过的值作为索引的对应数字都是负数，意为只要有i，那么nums[i]就是负数
        那么没有i的话，nums[i]就是正数

    方法二：
        遍历数组，如果某个数字没有放在其应该在的位置（如4应该放在第四个位置，即nums[3]应该=4），交换其与本来在这个位置上的数字
        i=0时，nums[nums[i]-1] = nums[i]：nums[2]=3
        则下标递增去，考虑下一个数字。一直到遍历完数组，变成了[1,2,3,4,3,2,7,8]，即每个位置一定是其对应数字，如果不是，则说明这个数字没有，记录


》给定一个char数组表示CPU需要执行的任务。 它包含大写字母A到Z，其中不同的字母代表不同的任务。 任务可以不按照原始的顺序完成。 ：621
每项任务都可以在一个时间槽内完成。 对于每个时间槽，CPU可以完成一个任务或只是空闲。但是，有一个非负的冷却间隔n意味着在两个相同的任务之间，必须至少有n个时间槽，CPU正在执行不同的任务或只是空闲。您需要返回CPU将完成所有给定任务所需的最少时间槽数。

    也就是说，上面A和A之间必须有两个以上时间槽

    加入对[A,A,A,A,B,C,C,C]
    将任务排序，
    A,A,A,A
    C,C,C
    B

    每次取出当前任务数最多的1个任务t

    然后每次取n个除了最大的所有的不重复的任务，插入到t的后面，
    然后每次都是取出，插入，当不够取时，插入idle, 直到最后一个最大插入
    要注意的是，最多元素每次插完就会改变，如下：

    每次都取出当前任务数最多的1个，不够就用interval补齐（除了最后）
    取完一组就对任务数组重新排序，（这一步极其重要！）
    取出一个任务，就减1

    对[A,A,A,A,B,C,C,C] n=2：
    A C B --->   A C B A C idle  ---> A C B A C IDLE A C IDLE  --->  A C B A C IDLE A C IDLE A



》给定一个未排序的整数数组，找出丢失的最小正整数。要求是用O(n)的时间复杂度和O(1)的空间复杂度：41
    这个做法是只管数组长度这么长范围内的从1开始的整数，即：
    对于长度为5的数组，只要发现1到5范围内的数x，就让它挪到x-1的位置（交换，不是替换，比如发现1就让它换到index为0的位置），其他的数字都不管，因为如果缺失这个范围的某个数，
    那答案就是这个数，如果不缺失，那么答案就是最大数+1
    [3,4,-1,1]->[-1,4,3,1]->[-1,1,3,4]->[1,-1,3,4]，从头开始遍历，第一个不等于索引+1的数是2，所以答案是2
    如果出现重复的数，那么不做改变，因为前一个该数已经放在正确的位置上了。


》一个人一开始面向正北，一个长度为N的字符串，由L和R组成，L表示向左转，R表示向右转。：b4
    输出最后面向的方向，N表示北，S表示南，E表示东，W表示西。
    显然方向中 一对L和R就可以抵消，所以LRR就相当于一个R，就是东了(E)
    给每个方向代号,顺时针增加：N:0, E：1，S：2，W：3
    左转相当于减1，右转相当于加1。 得到最终转向累加数lastDir
    为了方便，全部转换成正数。左转一次相当于右转3次，如果lastDir非负，则不用变，如果为负，则取绝对值后* 3
    例如，lastDir=-2，即从正北左转2次，相当于从正北右转6次，lastDir=abs(lastDir)* 3
    再取 lastDir%4 即为最终方向



》把一个数组循环右移k位：189，j-p286
    》方法一：
    如果使用O(1)的空间复杂度  （下面这种方法可以算是循环移位通用做法）
    使用2层循环，并使用一个计数器记录已经被放到合适位置上的数字个数
    外循环：for(i: nums.length) 如果计数器==数组长度，表示所有数字都被放置完毕，跳出循环。curIndex=i;  oriIndex=curIndex
    内循环：设 nextIndex = (curIndex+k)%nums.len  交换 nums[curIndex]和nums[nextIndex] ，此时nums[curIndex]到达了合适的位置，接着往后
        放nums[nextIndex]，更新curIndex=nextIndex 继续循环,每成功交换一个数计数器+1（表示有一个数已经被放到了合适的位置上）
        循环条件是curIndex!=oriIndex （即已经绕了一圈回来了）

     也可以改成循环左移， nextIndex = (curIndex-k+len)%len）
     数组也可以改成字符串

     》方法二：
        不论对于循环左移还是右移，首先让k=k%len;
        对于循环左移：循环左移k位，先将字符串分成两部分：[0, k-1], [k, len-1]
                    分别翻转两部分：[k-1, 0], [len-1, k]
                    然后再翻转整个字符串 [k...len-1,0...k-1]

        对于循环右移，循环右移k位相当于循环左移len-k位，做法就能统一起来了 
        （但要注意对字符串判空）




》给一个数组nums，返回一个数组counts, counts[i]是nums[i]右边比它小的元素的个数：315
    如果回回都要遍历会超时

    把数组改造成一个二叉搜索树，其节点有4个域：
    val：本身的值
    leftSum：该节点的左子树中的节点值
    smaller：插入该节点时树中比它小的节点总数
    dup：该值在邻旁的重复数，

    比如对于 [3, 2, 2, 6, 1]，从后往前向树中插入节点
    对于重复的节点，一开始并不知道重复不重复，当遍历到与要插入的节点值相等的节点，则在dup域上+1


    对bst中的任意一个节点，比它小的节点有几种可能：
        1.它的左子树上的所有节点；
        2.它的祖先链上（包括它自己）的所有作为右子节点其父节点的左子树上所有节点

    节点有一个记录在插入自己时，树中比自己小的节点个数域smaller，一个记录自己左子树节点数的值leftSum
    因此，smaller只在插入节点的时候赋值，插入后续节点时就不动了，而leftSum要一直跟踪变化

    因此需要累积一个每节点左子树上的节点数
    在插入一个节点时，每当右拐，则在该节点smaller域上增加当前位置节点的leftSum域+当前位置节点的重复次数
    每当左拐，则在当前位置节点的leftSum域上+1

    统计当node插入后的smaller域即可，但要格外注意的是，当node的值存在时，说明前面已经出现过该值，别忘记加上该值的左子树的节点个数
    （如果之前x就插入了，在第一次出现后第二次出现前，该节点的左子树可能增加了若干值，所以要加上）


》给定两个数组，写一个函数来计算它们的交集。：350
    使用hashMap，先遍历一个数组，把出现的数字和次数放入
    再遍历另一个，一旦出现一次，若该数字在map中的v>0,则v-1，并把该数字保存到结果集中



》将一个数组洗牌，并返回一个新数组，任何结果返回的概率要一样大：384
    如：把[1,2,3]洗牌成[2,1,3]
    reset会把数组恢复成刚进入的样子
    用一个数组保存刚进入的样子
    另一个数组保存每次洗牌的结果

    如何洗牌？
    循环遍历该数组，在每次遍历中产生一个0 ~ length - 1的数，该数代表本次循环要随机交换的位置。将本次循环当前位置的数和随机位置的数进行交换。
    public int[] shuffle() {
        for(int i=0;i<origin.length;i++){
            int randomIndex = rand.nextInt(origin.length);
            int tmp = copy[i];
            copy[i] = copy[randomIndex];
            copy[randomIndex] = tmp;
        }
        return copy;
    }



》特殊的俄罗斯方块：荧幕上一共有 n 列，每次都会有一个 1 x 1 ：b9
    的方块随机落下，在同一列中，后落下的方块会叠在先前的方块之上，当一整行方块都被占满时，这一行会被消去，并得到1分
    已知共有m个方块落下，且知道这些方块分别落在哪一列，求最终所得分数

    令总得分为s
    记录一个数字c, 记录当前有方块的列的个数
    并用一个数组blocks保存当前i列上的方块数
    每当有方块落到新的一列时，c+1，而当方块落到已有方块的一列时，c不变
    当c=n时，s++，且将blocks中的所有数都-1，且当有列上方块数为0时，c--
    最终返回s


》给定一组可能包含重复项的数字，返回所有可能的惟一排列。：47
    标准trackback，还是用trackBack和Set,用一个标志数组表示当前数是否已经被算进去，当已经被算进去的数等于总数，则添加进结果集


》数在第几个列表中：有n个列表从左往右依次排开，每个列表i中元素数量为ai，再给一个数组q，给出从在左往右数第q[i]个数属于第几个列表：b11
    如：
    5
    ai：2 7 3 4 9 （列表中的数分别有2个、7个、、、。。）
    3
    qi：1 25 11 （找第1个数在第几个列表，第25个数在第几个列表。。。）
    输出 1 5  3

    把n个列表中的元素个数，从左往右依次加到一个数组中：
    如：2，9，12，16，25

    对于数q[i]，方法是使用二分查找，依次找num中第一个大等于q[i]的数，该数的索引+1就是q[i]所在的列表序号。在c++中有函数 lower_bound，在Java中要自己实现
    对q[i]排序然后依次顺着在num中找的方法不可行，貌似是因为排序复杂度过大，所以在排序和二分查找做选择的时候，要选择二分查找的办法


》分配糖果：135
    有N个孩子站在一排。每个孩子都有一个评分值。你给予这些儿童糖果，必须符合下列规定:
    每个孩子必须至少有一颗糖果。
    得分高的孩子比他们的邻居得到更多的糖果。
    你至少要给多少糖果?

    初始化给没人一颗
    循环，设置一个布尔位，当此次循环数组中没发生任何变化就不再循环
        循环遍历数组的每一个位置，
            当该位置的分数高于左边的分，l= max(左边的+1，该位置原本的糖果)
            当该位置的分数高于右边的分，r= max(右边的+1，该位置原本的糖果)
            该位置上的糖果 = max(l,r),当该位置原本的糖果与之前不一样多时，布尔位标注为变化发生



》给定一个未排序的数组，找出其排序形式中连续元素之间的最大差值。：164
    如果数组包含少于2个元素，则返回0。
    
    您可以假设数组中的所有元素都是非负整数，并且符合32位带符号整数范围。
    试着在线性时间/空间中求解。

    用线性时间意味着不能排序，线性空间意味着能存储全部元素

    假设数组中有n个元素，最小和最大的数分别是min和max，那么相邻两个数之间的最大的跨度不会小于 tGap = ceil{(max-min)/(n-1)} （ceil是向上取整）
    这个很好理解，因为如果n个数是等差的话，那两个相邻数的差就是tGap，不是等差的话，则一定会有gap比tGap等或大（当然也会有gap比tGap小）
    我们可以把这n个数安排到n-1个桶中，每个桶的范围为tGap，第k个桶包含数的范围是[min+（k-1） * tGap,  min+ k * tGap )  (k从1开始)

    对于一个数x，它所属的桶的编号是 (x-min)/tGap   (单让min和max不属于任何一个桶)

    因为除去min和max，有n-2个数字，而有n-1个桶，所以至少有一个桶是空的，对于每一个桶，
    我们只需要存储其中最大的数和最小的数即可，存储完成后，
    只需计算 相邻桶的 后桶最小数-前桶最大数，并找出其中最大的值即可

    因为同一个桶中距离最大也就是tGap(桶中最大数-桶中最小数)，而由上面的论证可知数列中的最大差值最小也的是tGap，所以同一个桶中的不用算



》h索引：274
    给定一个研究员的文献的被引用数组(每个数都是非负整数)，编写一个函数来计算研究员的h指数。
    根据Wikipedia上h-index的定义：“如果科学家的N篇论文中的h篇每篇至少被h引用，而其他n － h篇每篇不超过h篇引用，则科学家对h索引进行索引。”

    [3,0,6,1,5]表示研究人员总共有5篇论文，每篇都有
              分别收到了3、0、6、1、5个引用。
              由于研究人员有3篇论文，每篇论文至少被引3篇，其余
              两次引用均不超过3次，她的h指数为3。

    总共只有n片论文，因此h最大也不能超过n，即在数组中，有h个数不小于h，其余n-h个数不大于h，找到这个最大的h
    假设n是论文总数，如果我们有n + 1个存储桶，即从0到n，即count[n+1]
    遍历数组，遇到一个数x时，若x小于n，count[x]++, 否则count[n]++，即大于n的数字，最多只能对h贡献n
    然后从后往前遍历数组count,并且累加count[i]到total上， 当total大等于i时，说明比i大或等的数超过（或等于）了i个，这就是h索引。从后往前遍历的原因是我们要找最大的h索引
    

》数组中的逆序对：j51-p249
    在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
    输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

    显然不能用顺序扫描的思想，一定会超时。

    用分解然后归并的思想：
    把数组分成2部分（一半一半），part1和part2，先得到part1和part2各自的逆序数i1和i2，设置i表示part1和part2之间的逆序数，然后对part1和part2各自排序，设置两个指针p1,p2分别从后往前遍历part1和part2
    当part1[p1]>part2[p2]时，则肯定比part2[0]到part2[p2]都大，一共有p2+1个数，i += （p2+1），p1往前挪；否则part1[p1]< part2[p2] p2往前挪
    直到有一个到头了。然后把数组排序，供上层使用，并返回i+i1+i2, 即本层的逆序数等于两个子部分各自的逆序数及两部分之间的逆序数


》给定一个整数数组nums，找到索引i和j之间的元素之和（i≤j）（含）。：303
    您可以假设数组没有更改。
    有许多对sumRange函数的调用。
    由于调用有很多，所以不能每次都算
    设sum[i] 为 从第0个开始，截止到第i个（包含）的和
    sumRange(i,j) = i==0?sum[j]:(sum[j]-sum[i-1])


》给定一个整数数组编号，求索引i和j (i≤j)之间元素的和,(两边都是闭区间)：307
    update(i, val)函数通过将索引i处的元素更新为val来修改nums。
    是303的改进版，这次可以修改其中的值了，update和sumRange的调用是均匀分布的。
    
    主体思想还是sumRange(i,j) = i==0?sum[j]:(sum[j]-sum[i-1])
    但当有update(x,i)的时候，计算offset =  x-num[i], 然后更新所有的 sum[j]  (j从i到len-1)




》数字在排序数组中出现的次数  j53-p263
    统计一个数字在排序数组中出现的次数。
    先二分查找，找到后左右扩展边界


》构建乘积数组：j66-p312
    给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。
    
    定义C[i] = A[0]xA[1]...xA[i-1]
    D[i] = A[i+1]xA[i+2]...xA[n-1]

    C[i] = C[i-1]xA[i-1]
    D[i] = D[i+1]xA[i+1]

    C[0]=1;
    D[n-1] = 1;

    B[i] = C[i]xD[i]

    //由于D[i]只与D[i+1]和A[i+1]有关，因此在算出C数组的前提下，只需要一个数就能完成滚动数组
        for(int i=1;i<n;i++){
            C[i] = C[i-1]*A[i-1];
        }

        //由于D[i]只与D[i+1]和A[i+1]有关，因此在算出C数组的前提下，只需要一个数就能完成滚动数组
        int temp = 1;
        int[] B = new int[n];
        B[n-1] = C[n-1];
        for(int i=n-2;i>=0;i--){
            temp = temp * A[i+1];
            B[i] = temp * C[i];
        }
        return B;


》合并两个或一个升序数组为一个升序数组：b26
    很简单的双指针法合并数组。p1，p2分别在两个数组的头部，把当前p1，p2中指向的小的数字加入结果数组，然后指针后移,直到一个指针到头了，然后把另一数组全部加入结果数组即可。因为同一个数组的数字都在同一行，所以用nextLine，然后用split分割每个数字
    难点在于如何判别输入的是两个还是一个数组？关键在于用hasNextLine判断是否还有下一行。如下：如果只有一行，则直接输出s1
        Scanner in = new Scanner(System.in);
        String s1 = in.nextLine();

        if(!in.hasNextLine()){
            System.out.println(s1);
            return;
        }
        String s2 = in.nextLine();

    直接用上述代码在控制台中手动模拟不行，因为hasNextLine还是会有读下一行的操作（读到了再判断是不是空），可以用文件来测试，在牛客上可以通过



》给定两个长度为m和n的数组，只包含数字0到9，每个数组都代表一个数。 从两个数组中创建最大长度k <= m + n的新数组（代表一个数，从第0位到第k位代表数位从高到低）。 该数组中的数字必须保留同一数组中数字的相对顺序。 返回这个k个数字的数组。：321

    该题其实是很麻烦的一道题，最终也只能达到O((m+n)^3)的时间复杂度。
    首先是对两个数组各取若干个数字，若nums1取i个，则nums2取k-i个，且取的数字必须是顺序能组成的最大数，
    采用回溯法，当遍历到一个比前一个取的数字更大的数字时，回溯已经取的数字，目的是想要把大的数字尽可能往前移，且还要满足剩下的数字够取
    把nums1和nums2中的尽可能大的数字取出后，使用归并排序让他们组成的数字尽可能大，
    先是普通的归并，当两个指针指向的数字不一样时，优先将大数字放入结果，两数字一样大时，要额外处理，则先取后面有更大值的那一个
    比较所有这样取得的序列（由i值不同取得不同的序列），其中最大的就是答案。

    下面得到是如何得到一个数组中尽可能大的子数组，且保持数字相对顺序不变的方法：
    public int[] maxArray(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[k];

        //j是当前ans中的元素数
        for(int i=0,j=0;i<n;i++){

            //如果当前数nums[i]大于ans[j-1]，则继续往前找，直到剩下的数字(n-i)+ans中的数字个数(j)少于等于k，或者ans[j-1]大于当前数，则停止寻找
            while (n-i+j>k && j>0 && nums[i]>ans[j-1]){
                j--;
            }

            if(j<k)
                ans[j++] = nums[i];
        }
        return ans;
    }




```


## 循环移位（循环左移、循环右移，又叫左旋转、右旋转）若当前元素位置为i，下一个位置的算法：
   左移：nextPos = (i-n+len)%len
   右移：nextPos = (i+n+len)%len


```背包问题
》共有n种零食，每种体积为v[i], 要放入体积为w的袋子，要求放入的总体积不超过袋子体积，有多少种不同的放法（不放算一种）：b8
    01背包问题：对于每一种物品都有放和不放有两种选择，


    这一类背包问题有两种方法，一种是当物品个数n较少，但是背包大小m比较大时采用指数级的枚举搜索（递归搜索），复杂度为O(2^n)
    另一种是当背包比较小的时候采用动态规划O(nm)  让能达到的值都存一下

    这道题明显是属于第一种（因为数字太大不可能全存的下）。如果用简单的trackback递归，AC率 80%，时间复杂度太大 ，2^30的复杂度是不可以接受的，因此我们可以采用中途相遇法。把我们能接受的前15个物品先进行第一次枚举搜索，然后再对剩下的物品进行第二次枚举搜索。把第二次枚举搜索出来的结果(至多2^15=32768个答案)存入数组并排序，枚举第一次搜出来的结果，计算出还剩下多少背包体积还能装，在第二次的结果中进行二分查找，并把两次搜索的结果进行相乘(乘法原理)。再把所有的结果进行相加(加法原理)，就是答案了。
    当然也可以把物品分成n/2和n-n/2两部分。
    总复杂度是O(2^(n/2)*n)

    ## 掌握这种“中途相遇法”：把一个大问题拆成两个小问题，然后组合两个小问题所有合适的解，即为大问题的解



```




```查找排序
》对一个数组进行排序，数字范围为0-100，同一数字可能出现多次
    用长度为110的数组tmp记录每个数字出现的次数，当x出现时，tmp[x]++,某个数字出现了多少次，就在原数组中设置几个该数，就相当于排序了
    典型的用空间换时间的做法


》给定一个非空整数数组，返回k个出现频率最高的元素。：347
    先把数组中的数，以数为key，次数为value存入Hashmap，然后把map中的entrySet(k,v对)放入一个Arraylist中，并重写Collection.sort对该list进行排序，排序的规则自定义，v越大越靠前。之后该list中的元素就是排过序的了，只需遍历出前k个即可
    核心算法：
        Set<Map.Entry<Integer, Integer>> set = map.entrySet();
        List<Map.Entry<Integer, Integer>> list = new ArrayList<Map.Entry<Integer, Integer>>(set);
        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer>>() {
            @Override
            public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
                return o2.getValue()-o1.getValue();
            }
        });


》假设你有一列随机的人在排队。每个人由一对整数(h, k)描述，其中h是这个人的高度，k是这个人前面的高度大于或等于h的人数。编写一个算法来重构队列。：406
    Input:
    [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

    Output:
    [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

    找到其中最高的值，排列出来  [7,0]  [7,1]
    次高的值，先按照k从小到大排：[6,1],然后从上面队列的第一个开始数，数k个，插入：[7,0] [6,1] [7,1]
    继续：[5,0], [5,2]，插入：[5,0] [7,0] [5,2] [6,1] [7,1]
    继续：[4,4],插入：[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]

    把原数组排序，按照h优先，h从大到小，k从小到大的顺序：要重写一下sort方法h不同时，按降序，h相同时，按照k升序
    简化方法：先按照h排序之后（[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]），再从前到后直接逐个按k为位置往List里面插即可



》给定一个整数数组，你需要找到一个连续子数组，如果你只按升序排列这个子数组，：581
然后整个数组也将按升序排序。您需要找到最短的子数组并输出它的长度。
    Input: [2, 6, 4, 8, 10, 9, 15]
    Output: 5
    Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
    直接将序列弄一个排好的，然后用两个指针一个从前往后一个从后往前，当遇到不一样的数字时指针停止走动（因为要求的子数组必须是连续的），最后算两个指针的差即可


》给定一些数对(di,pi)，以及一些数字ai，对于每一个ai，找到满足ai>=di的最大pi并输出pi：b1
    先用map保存di-pi，然后保存ai，若map中已有ai(即有di==ai)则不动，否则保存ai-0，并且用一个数组mm保存di和ai，用一个数组nn保存ai
    对ai从小到大排序，然后遍历mm，保存目前为止最大的pi为max，取map.get(mmi)和max的大值作为map中mmi的value
    这样遍历到一个ai时，即使map中值为0，由于max的存在，也能取到比ai小的中di对应的最大的pi
    之后再遍历nn，以其为key从map中取出value输出，由于nn保存了ai输入的顺序，所以可以保证输出顺序和输入顺序对应


》给一个数组，就是对于每一个值，找到它后面的第几个数是比它大的，并返回这个数字的数组：739
    还是用栈来做，当遍历到一个值时，如果它比栈顶元素所索引的元素大，那栈顶元素所索引的答案就是该值-栈顶元素所索引
    然后出栈，持续比较该值和栈顶元素大小，直到栈顶元素不比该值小，然后该值入栈，继续遍历
    最终还在栈中的元素，说明它后面没有比它大的数了，所以对应的值是0。
    ## 又一个这里入栈索引的典型


》给定一个包含n个红色、白色或蓝色对象的数组，对它们进行排序，使相同颜色的对象相邻，颜色顺序为红色、白色和蓝色。：75
    这里，我们将使用整数0、1和2分别表示红色、白色和蓝色。注意:对于这个问题，您不应该使用库的sort函数。    
    循环：
        p1和p2分别从前后往中间靠，p1到达第一个不为0的地方，p2到达第1个不为2的地方
        p从前往后走，遇到0则和p1的值交换，遇到2与p2交换，p遇到1继续走不管，
        循环继续：p1继续往后走到不为0的地方，，p2走到不为2的地方。。。
        循环停止的条件是p1超过p2 或 p超过p2


》输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 ：j21-p129
    先遍历，得出奇数多少个，把偶数存起来。
    再遍历数组，遍历到奇数时，放入一个自增的下标中，遍历完后，再把保存的偶数放到后面
    sO(n)+tO(n)


》查找峰值，peak元素是比它的邻居更大的元素。：162
给定一个输入数组nums，其中nums[i]≠nums[i+1]，找到一个peak元素并返回其索引。数组可能包含多个峰值，在这种情况下，将索引返回到任何一个峰值都可以。
    
    找到峰值元素，峰值元素是指比它两边的元素都大，如果用线性复杂度很简单，但这里要用对数复杂度
    对数就得用二分查找的思想，查看mid是否是峰值，
    如果不是，则分别递归查看它的两边的数组，这里和普通二分有区别，因为两边都要找，但如果先找的一边有峰值，就可以直接返回，后面的那一边就不用找了
    如果mid不是峰值，且左右两边都没有峰值找到，则返回-1.



》摆动排序：324
要保证的是，奇数位的数字一定大于它两边的偶数位的（从0开始算） 
先排序，排完序然后从左往右奇数索引位置放大于中位数(注意是中位数，不是平均数)的数, 然后从右往左在偶数索引位置放小于中位数的数, 剩下的位置都放中位数. 其时间复杂度为O(nlog(n)), 空间复杂度为O(n).

        [1, 5, 2, 1, 6, 4]-》[2, 6, 1, 5, 1, 4] （可能有多种结果，只求出其中一个结果）
        //小数字从右往左放，从右往左依次增大，能保证如果需要中间数，那它一定在最左端（对于小数字而言，整体的中间数就是其中最大的）
        //大数字也从左往右放，从右往左依次增大，能保证如果需要中间数，那它一定在最右端（对于大数字而言，整体的中间数就是其中最小的）
        //这里的话，就算两头是中间数，也不会出现相邻的相同了
        //小数字放偶数位
        //如果末尾索引是偶数，就从末尾开始填，如果是奇数，就从末尾的前一个开始填


》翻转字符数组顺序，用O(1)的空间复杂度：344
    所有的翻转都可以：
    #翻转数组通用公式：s[i] swap s[len-i-1]


》给一个排好序的数组，返回给定值的位置，如果没有该值，给出如果插入它时的位置：35
    如果有，返回位置；如果么有，返回第一个比它大的位置
    》方法一：遍历即可，if先判断是否等，等则返回，else if判断是否大，大则返回，循环结束没返回说明都比给定值小，返回数组长度即可
    》方法二：二分查找，找lower_bound，即数组中第一个大于或等于该值的数的位置


》给定一个数字数字数组，其中恰好有两个元素只出现一次，而所有其他元素正好出现两次。找到只出现一次的两个元素。：260，j56-p275
    》方法一：
        如果用sO(n)很简单，用hashmap保存每个值出现的次数，再遍历一遍找到出现次数为1的两个数即可

    》方法二： sO(1)
        假设数组中两个不同的数字为 A 和 B；
        通过遍历整个数组并求整个数组所有数字之间的 XOR，根据 XOR 的特性可以得到最终的结果为 AXORB = A XOR B；
        通过某种特定的方式，我们可以通过 AXORB 得到在数字 A 和数字 B 的二进制下某一位不相同的位；因为A 和 B 是不相同的，所以他们的二进制数字有且至少有一位是不相同的。我们将这一位设置为 1，并将所有的其他位设置为 0，我们假设我们得到的这个数字为 bitFlag；
        （与上：与运算， XOR：异或运算）
        例如，结果是 11000100，取从右往左数第三位，将其他所有位都置为0，得 00000100，说明上述两数该位上不一样，将该数设为bitFlag
        设置的方法可以将该数转成二进制（Integer.toBinaryString），将遇到的第一个1保留，剩下的1全设为0
        那么现在，我们很容易知道，数字 A 和 数字 B 中必然有一个数字与上 bitFlag 为 0；因为bitFlag 标志了数字 A 和数字 B 中的某一位不同，那么在数字 A 和 B 中的这一位必然是一个为 0，另一个为 1；而我们在 bitFlag 中将其他位都设置为 0，那么该位为 0 的数字与上 bitFlag 就等于 0，而该位为 1 的数字与上 bitFlag 就等于 bitFlag
        现在问题就简单了，我们只需要再循环一次数组，将与上 bitFlag 为 0 的数字全部一起进行 XOR 运算，与上 bitFlag 不为 0 的数全部一起进行 XOR 运算。那么最后我们得到的这两个数字就是 A 和 B。


》瞌睡：b10
    给2个长度为n的数组a,t，a里面是值，t里面只有0和1。再给一个值k。可以做一次处理，让t中某个位置开始连续k个位置都是1(原来是1则保持该位置仍为1)，
    然后求所有在t中值为1的索引在a中的值的和的最大值。

    遍历所有的可取值的位置，算连着3个的值，并且把其中本来就为1的那个值去掉，取其中最大值
    然后再算一遍本来就为1的值的和，即为答案, 这样做提示算法复杂度过大，AC率为90%

    关键在于怎么把n^2的复杂度降下来，可以考虑用窗口，保持窗口大小为k, 窗口在变，设置一个值表示当前窗口中t为0的数之和，每次只删一个值，只加一个值（加和删的都是t为0的）然后一直记录窗口中t为0的位置的和的最大值，然后再算一遍本来就为1的值的和，即为答案。这样用窗口可以在tO(n)得到最大值



》塔：数组中有一些数，不稳定值为其中最大数与最小数之差，每次可以把某个数-1，再让每个数+1，这视为一个操作，不超过k次操作后，不稳定值最小是多少：b14
    一定是每次把最大的-1，最小的+1，每次都遍历找最大最小的，并记录交换的次数。如要求每次的索引，则可把索引记录到一个数组中。
    最关键的一步在于，如果最大的和最小的之间差1，那就不用再移动了，因为再移动也是左右横跳。因此，当最大的和最小的差小等于1时，就可以不操作了。



》搭积木：b18
    有一袋子长方形的积木(二维数组，第一维有多少个，第二维是长和宽)，如果一个积木A的长和宽都不大于另外一个积木B的长和宽，则积木A可以搭在积木B的上面。
    求这一袋子积木最多可以搭多少层，你能帮他想想办法吗？

    把积木先按长排序，再按宽排序（宽的优先级高）

    (2, 2), (3, 3)，(2, 4), (2, 5), (4, 5)

    (2, 2), (2, 4), (2, 5)，(3, 3), (4, 5)

    在数组中求长的最长递增子序列，但这里不能按照普通的那种两层循环来求（即dp[i]是以第i个元素结尾（从第0个开始算）的最长子序列
    这种思想），会超时。

    用另一种思路：dp中存储堆叠积木的高度，dp是一个上升(不减)的数组

    int[] dp = new int[n]
    int count //能达到的最大层数

    for(int i=0;i< n;i++){
        if(count==0 || bricks[i].l>=dp[count-1]){  //第一个，或者遍历到的长度不小于当前最大长度，直接加入数组
            dp[count++] = bricks[i].l;
        }else{
            //设bricks[i]是当前积木
            //dp中的积木的宽一定都小于当前积木的宽（因为宽是排过序的），而当前积木的长又小于dp中最长的积木
            //将第一个比bricks[i]的长大的位置找出来将其替换为bricks[i]，目的不是为了替换当前的积木塔中的积木，而是为了是为了另开一个积木塔
            // 而”共用"前面比它小的部分，在后续如果比它宽更大的就连在它的后面即可
            index = upper_bound(0, count, dp[count])
        }
    }

    再举个例子(2, 2), (2, 4)，(2, 5), (20, 2), (30, 2), (40,2)
    按宽度排序即为上面的顺序，然后按照上述的算法：
    (2, 2)  count:1
    (2, 2), (2, 4) count:2
    (2, 2), (2, 4)，(2, 5) count:3
    (2, 2), (20, 2)，(2, 5), count:3  //(2,4已经用不到了，相当于重开了个塔：(2, 2), (20, 2) )，但count始终保存当前能达到的最大层数，当前积木不一定在最高的塔中
    (2, 2), (20, 2)，(30, 2) count:3
    (2, 2), (20, 2)，(30, 2) （40，2）count:4
    最高的塔层数为4
    //如果把brick单开一个类，会超时，所以当能用原生类型的时候，尽量不要新开类，创建对象所需的时间成本有时候也较大


》数组中重复的数字：j69
    在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

    所有的数字都是0到n-1的范围内，所以它们都可以放到自己对应的位置上，如果某个数字对应的位置已经是这个数了，则是一个重复的数(注意里面得是双重循环)




```



```链表问题：
》注意，两个数字做加法进位的时候只能进位1。因为最多也就是前一个进位的1，加上本位的两个9，这样往高位进位还是1（最低位往前进位最多是1，导致高位进位最多也就是1了）：2
》获得链表节点的值时，有时候可以判断如果节点为null后返回0，这样有利于统一化计算：2

》双指针（N指针）法：
    》删除（倒数）第N个元素：若是正数第N个，则需要遍历两遍定位，若是倒数第N个则需要遍历1遍，用相隔若干的两个指针，当一个指针到底时，另一个指针抵达目标位置  19
    》输入一个链表，输出该链表中倒数第k个结点。：j22-p134
        思想很简单，就是双指针法，p1出发k步后p2才出发，p1到达末尾时，p2到达倒数第k个
        重点在于代码的鲁棒性
        1.头结点判空，若为null直接返回null
        2.k值的合法性，输入小于等于0的值返回null
        3.记录步数的count在什么地方增加，结果才能合理


》求链表的中间节点，如果链表中节点总数位奇数，则返回中间节点；如果节点总数是偶数，则返回中间两个节点的任意一个。：j138
    定义两个指针，同时从头结点出发，一个指针一次走1步，另一个一次走两步，当走的快的到达末尾时，走得慢的正好在链表中间


》合并有序链表： 23，j25-p145
    》方法一使用优先级队列，给优先级队列设定排序规则，然后把两个链表的节点都输入队列，再取出时，就已是排好的顺序，只需要链起来即可
                （对于排好序的链表不用一开始就把所有节点输进去，一开始只需入队头节点，当输出时把输出节点的next入队即可）
    》方法二：
        用两个链表指针，每次都比较，将小的值接在新链表的后面，并且更新该指针指向下一个节点。
    所以一开始要有个假头
    也算是双指针法,一直到其中一个指针为null，则把剩下的那个链表直接全接在新链表的后面即可


》交换相邻的两个节点：1->2->3->4 ---》 2->1->4->3.，对于交换隔N个的节点也可以用类似方法： 24
    添加一个虚头，保留3个指针，一个pre，一个n1,一个n2，关系是 pre->n1->n2
    交换：
    n1->next=n2->next
    n2->next = n1
    pre->next = n2

    交换完之后，都要往后移一位：

            pre = n1;
            //如果后面没东西了捕获异常退出
            try{
                n2 = n1.next.next;
                n1 = n1.next;
            }catch(Exception e){
                break;
            }

    当n2为null时，循环结束


》反转部分单向链表：c-p42
    给定一个单向链表，及两个整数from和to，把from到to进行反转
    很简单，将第from-1个节点和to+1个节点记录下来，然后把from到to的链表翻转，然后把from-1和to+1接上去即可。
    为了方便操作，先引入dummy


》分段翻转链表 ：25 ，c-p68
    例如：1-2-3-4-5-6-7-8   K=3   调整为 3-2-1-6-5-4-7-8   7、8不调整，因为不够1组
    分段翻转，保存翻转前该段的头和尾作为翻转后的尾和头连接上下段
    每个段的翻转，就跟下面“翻转链表”一样的。
    额外注意的是，需要保存该组翻转后的尾节点，用于连接下一组的头结点




》翻转链表：j24-p142
    》空间复杂度O(1)
    ① 三节点法：
    链表长度=2时直接交换头尾
    链表长度>=3时，用以下方式：其实就是每次只修改n2的next指向n1，即后一个节点的next指向前一个节点，n3是辅助节点，防止断链
        {
            ListNode n1 = head;
            ListNode n2 = head.next;
            ListNode n3 = head.next.next;
            while(n3!=last){
                n2.next = n1;

                n1 = n2;
                n2 = n3;
                n3 = n3.next;
            }
            //此时n1,n2,n3分别是这个链表的最后3个节点,手动把它们设置好
            n3.next = n2;
            n2.next = n1;
            head.next=null //这一步很重要，一定记得!!!
        }

    ② 直接用头插法，也可以实现用O(1)翻转链表：
        要借助假头结点dummy
        public ListNode reverse(ListNode head){
            ListNode dummy = new ListNode(0);
            dummy.next = head;
            ListNode p = head;
            while (p!=null){
                ListNode tmp = p.next;
                if(p==head){
                    p.next = null;
                }else
                    p.next = dummy.next;
                dummy.next = p;
                p = tmp;
            }
            return dummy.next;
        }

    》空间复杂度O(n)
        可以使用栈，顺序入栈后，再出栈就是倒序，然后直接重新链next即可
        也可以使用数组，把链表节点都存入数组后，重新链它们


》给定一个链表，判断它是否有一个环。：141
    用O(1)的复杂度，只用两个指针，一个指针一次走两步，一个指针一次走一步，当两个指针能重合，说明有环（龟兔赛跑算法）


》给定一个链表，返回循环开始的节点。如果没有循环，返回null。：142, j23-p139
    #龟兔赛跑算法（Floyd判圈法）

    》首先，判定环的存在：
    fast一次走2步，slow一次走1步
    a. 有环的话，快指针和慢指针必然相遇，通过指针相等退出循环；
    b. 无环时，快指针将访问非法域，导致异常 

    》判定有环后，利用上一步的信息（相遇的点），判定入口：
    a. 设起点q到环的入口点r的距离为H步，入口r到第一次见面点m的为d步。一圈为C步，设第一次相遇时，Fast相对于r点转了m圈，Slow转了n圈
    b. 则第一次相遇时，Slow运动了(H+d+nC)步，Fast运动了(H + mC + d), 由于Fast指针是慢指针Slow的两倍速度, 从而有距离公式：

                      2(H+d+nC) = H + mC + d,
                    经过简单的运算，有：

                       H+d = (m-2n) * C
    即：  H = (m-2n) * C - d
    H+d = (m-2n) * C

    H+d是环长的整数倍

    （fast是slow速度的2倍）
    这表明，当我们让Slow重新从q点处、Fast继续从相遇见的m点处，都以速度1移动时，当slow到达r点时，走了H步，此时fast从一开始链表起点算，走过的路程是
    H + mC + d + H， 而H+d是整数倍的C，则fast走过的路程可以写成 kC +  H，相当于fast从起点走到r点（H步），然后在环里绕了k圈又回到了r点，故此时slow和
    fast重合，且重合的点是环的入口点m，而且这是slow重新从q出发以后第一次和fast相遇（slow在环外，fast在环内）


》如何计算上述链表中环的长度
    上述可以根据龟兔赛跑算法，知道一快一慢两个指针相遇时一定在环内，标记这个节点，让慢指针继续走，直到下一次到达这个节点时，就可直到环的长度


》将单链表排序，且达到tO(nlogn)：148
    排序算法能达到O(nlgn)的有归并排序，堆排序，快速排序，其空间复杂度分别为O(n),O(1),O(1),     
    考虑并归排序，构造两个指针，一个快一个慢，fast一次走两步，slow一次走1步，当fast走到链表尾时，slow正好就在链表中间
    head-slow， slow-fast  视为两个链表，对这两个链表进行归并排序，为了达到O(nlogn)的时间复杂度，使用递归(对每个小链表再进行归并)


》就是找两个链表的第一个公共节点，两个链表有公共节点，则一定是Y型的样子：160，j52-p253
    A从头到公共节点距离为ta，B从头到公共节点距离为tb，公共节点到尾距离为l

    》方法一：
        保持两个指针pA和pB分别在A和B的头部初始化。 然后让它们遍历列表，一次遍历一个节点。
        当pA到达列表的末尾时，然后将其重定向到B的头部（是的，B，这是正确的。）; 类似地，当pB到达列表的末尾时，将其重定向到A的头部。
        如果pA在任何时候遇到pB，则pA即pB是交叉点节点。此时pA走了：ta+l+tb,pB走了tb+l+ta

        》这里要注意！在循环中不能将p1设置为p1.next后再判断是否为空然后跳转。 应该是要么设置为next，要么跳转。二者都为一个完整操作，切记不要连着做

    》方法二：
        分别遍历，计算两个链表的长度，计算其长度差为offset，长链表指针从offset开始出发，短链表指针从头部出发，两者相遇的地方是第一个公共节点



》回文链表：给定一个单链表，判断是否是回文：234
    》普通法：sO(n)
        将其中一半存起来，然后再与另一半比较

    》反转链表法：sO(1) (推荐使用，简单且效果好)
        将链表后半段原地翻转，再将前半段、后半段依次比较，判断是否相等，时间复杂度O（n），空间复杂度为O（1）。
        不论链表节点数为偶数还是奇数，都翻转[mid, len-1]。先用双指针法找到mid位置的节点，然后翻转
        如果是奇数，则后半链表要比前半链表长1(即多中间节点)，所以互相比较直到其中一个链表节点为null就停止比较即可。



》在O(1)的时间内删除某个节点 ：j18-p119
    有点投机取巧的意味，比如要删除node，
    直接把node.next的值设置给node，然后node.next = node.next.next 
    其实是删除了node.next，但从值上看，删除了node

    如果node是头结点，则新链表的头结点就是node的next。
    如果node是尾节点，只能从头遍历，将node前面的节点的next置null了(只有这一种情况不是O(1)，但其余情况都是O(1))


》在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 ：j18-p122，82
    例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

    》方法一：先遍历链表，把有重复的值都放到一个HashSet中，再从头到尾遍历，如果出现set中有的值，删去该节点

    》方法二：如果要求空间复杂度O(1)的话，则保留一个pre，如果node.val==node.next.val,则循环将node=node.next直到其值变了为止    
    简单起见，引入一个头结点，同时保留一个节点的前驱，后继，相当于同时维持3个指针
    如果节点node的后继等于它，则前驱不变，往后遍历node，直到node的值与其后继的值不同，连接前驱的next为node，也即删除中间的节点


》删除无序单链表中值重复出现的节点：c-p71
    注意该题是链表无序
    例如 1-2-3-3-4-4-2-1-1  删除后为 1-2-3-4
    》方法一：
        如果空间复杂度为O(N),时间复杂度是O(N)的话很简单，每遍历一个节点，尝试把其值放入hashset中，如果出现过该值则删除该节点

    》方法二：
    如果空间复杂度为O(1),时间复杂度是O(N^2)，则设定一个节点p等于当前节点，n为p.next, n往后遍历，只要出现等于这个值的节点，都删掉（所以还要保留pre），然后p继续往下走一个，n继续为p.next，继续。最后，head一定还是head，因为是从第二个节点才开始删的




》一个特殊的链表，链表节点的next指向下一个节点，random指向这个链表中任一一个节点或者空，：138, j35-p187,c-p56
    要求深拷贝这个链表
    难点在于怎么让新的链表也维持random域的关系

    》方法一 sO(n)+tO(n)
    先完全不管random域，拷贝出一个只有next域的链表
    把源链表放入一个list，这样可以知道它的random域指向的节点序号
    把生成的链表也放入一个list，按照原链表的random序号去指新链表节点的random


    》方法二：sO(1)+tO(n)
    step1：根据原始链表的每个节点N创建对应的N‘，这一次把N’链接在N的后面
    step2：设置复制出来的节点的random，假设原始链表上的N的random指向节点S，那么其对应复制出来的N‘是N的next指向的节点，同样S’也是S的next指向的节点
    step3：把这个长链表拆分成两个链表：把奇数位置的节点用next连起来就是原始链表，把偶数位置用next连起来就是复制出来的链表



》编写一个函数来删除单链表中的一个节点(尾巴除外)，该函数只允许访问该节点。：237
    注意的是只能访问该节点！也就是说前面的都是透明的
    而这个题的解法，就是把node的值改成node.next的值，然后删除node.next
    显然这不是删除了节点，题目有点违反直觉，但在实际中是很有用的


》只给定一个节点，以O(1)方式删除该节点的方法存在的问题：c-p82： 237的问题
1.这样的方式无法删除最后一个节点（继无法让倒数第二个节点的next变成null）
2.本质上部署删除node节点，工厂上一个节点可能代表很复杂的结构，节点值的复制很复杂，或者根本就禁止改变节点的值


》奇偶链表，给一个单链表，把奇数序号的节点放在前面，偶数序号的放在奇数序号的后面，应该使用O(1)：328
    的空间复杂度和O(n)的时间复杂度。关键是常数空间复杂度
    》解：
    用odd，even分别代表奇偶节点，初始化odd为第一个节点，even为第二个节点。并且保留当前这两个节点的引用。
    循环迭代，每次令odd的next为它的next的next，even也一样。然后再让odd = odd.next, even=even.next;

    这里是不设置值，而是利用next节点，在链表内部形成两个链表，最后再把它们连起来


》给定一个已排序的链表，删除所有重复项，使每个元素只出现一次。：83
    保留前驱
    如果当前节点值和前驱的相同，则删除当前节点
        while(node!=null){
            if(node.val==pre.val){
                pre.next = node.next;
                node = node.next;
            }else{
                pre = node;
                node = node.next;
            }
        }



》给定一个链表和一个值x，对其进行分区，使所有小于x的节点都位于大于或等于x的节点之前。：86
    您应该保留两个分区中每个节点的原始相对顺序。
    这里只对小于x的节点的位置进行了约束，没说对于大等于x的节点如何做，那就是不动

    》方法一：sO(n)
    把小于x的节点按顺序放入一个数组，其他的放入另一个数组，然后把这个两个数组连接起来

    》方法二：sO(1)
    更好的办法是，设置两个链表头: sHead和 tHead，遍历链表，当遇到比target小的数时，接入sHead，更新指针s指向sHead链表的最后一个节点
    当遇到比target大或等的数时，接入tHead，更新指针t指向tHead链表的最后一个节点，最后把sHead-tHead把两个链表连起来即可


》给一个单链表 L0→L1→…→Ln-1→Ln,重排序成  L0→Ln→L1→Ln-1→L2→Ln-2→…：143
    您不能修改列表节点中的值，只能修改节点本身。
    利用数组很方便，先把链表节点顺序放进数组，一个指针p1从前往后走，一个指针p2从后往前走，让两个操作：（p1.next=p2, p1++）和（p2.next=p1,p2--）交替进行
    直到p1大于p2为止


》给定一个单链表头部节点head，链表长度N，如果N为奇数，那么前N/2算左半区，后N/2为右半区；如果N为奇数，那么前N/2算左半区，后N/2+1为右半区；左半区是L1->L2->... 右半区是R1->R2->...请将单链表调整为 L1->R1->L2->R2...的形式：c-p86

    轮流把两个半区的节点接到新链表上。p1到左半区头，p2为右半区头，设立一个flag表示该接左还是右的节点了，接上后，p1/p2往后移一位， flag取反， 新链表的尾节点=其next... 循环直到p1,p2都是null




》使用插入排序对链表排序。：147
    插入排序的图形示例。部分排序列表(黑色)最初只包含列表中的第一个元素。
    每次迭代都从输入数据中删除一个元素(红色)，并插入到排序列表中

    插入排序算法:

    插入排序迭代，每次重复使用一个输入元素，并生成一个排序后的输出列表。
    在每次迭代中，插入排序从输入数据中删除一个元素，找到它在已排序列表中的位置，并将其插入其中。
    它不断重复，直到没有输入元素保留。
    插入排序就必须每遍历到一个数时，就从头遍历到当前（在前面已排序列中找到其合适的位置），要注意排完序后要把最后一个节点的next置null


》圆圈中最后剩下的数字：j62-p300
    0，1.。。。n-1 这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈中删除第m个数字，求出这个圆圈剩下的最后一个数字
    
    》方法一
        有点类似哈夫曼环，可以构建一个循环链表，然后去删即可，由于要维持链表，所以要保留一个pre节点来保存前一个节点，当cur等于pre时，说明环中只有一个节点了
        边界情况：n为0或m为0时，没有这样的数字，返回-1

    》方法二：
        数学方法，具体见 j-p302
        f(n,m) = 0                  n=1
                 (f(n-1, m)+m)%n    n>1
        //代码如下：
        int last = 0;
        for(int i=2;i<=n;i++){
            last = (last+m)%i;
        }
        return last;


》把链表中的后面k个节点提到前面来：61
    相当于把倒数的k个节点插入到链表头，用双指针法定位到倒数第k个节点，然后把该节点前面的next置空，末尾节点的next置为原头结点
    若k大于链表长度，则 k=k%len （可以统一都先做处理：k=k%len）
    注意要对处理后k=0的情况做特殊处理，直接返回原头结点即可


》打印2个有序链表的公共部分：c-p34
    注意不是两个链表有公共节点，而是打印出它俩值相等的节点

    如果head1小于head2，head1往下移动
    如果head1大于head2，head2往下移动
    如果二者相等，打印值，然后head1和head2都往下移动
    head1和head2任意一个移动到null，则停止过程


》在单链表和双链表中删除倒数第k个节点，c-p35
    删除单链表的：
        双指针法：p1到达第k个节点后，p2设为第1个结点，然后二者一起往后走，当p1到末尾节点时，p2就是倒数第k个节点，并且过程中要一直维持p2的前驱节点（为了方便，最好弄个假头节点）

    删除双链表的：
        双指针法也可，不用设置前驱了，因为有pre域
        单指针法：一个指针一直到达末尾，然后往前走k-1次，就是倒数第k个节点


》删除链表的中间节点和a/b处的节点：c-p38
    》删除中间节点：
        三个指针p1，p2和pre，p1一次走2步，p2一次走1步，pre始终是p2的前驱。当p1走到末尾时，p2刚好在中间，执行删除即可。注意最好是有dummy节点，方便操作

    》删除a/b处的节点：
        例如，有链表1->2->3->4->5 假设a/b的值为r
        如果r为0，则不删除任何节点
        如果r在区间(0, 1/5]上，删除节点1
        如果r在区间(1/5, 2/5]上，删除节点2
        如果r在区间(2/5, 3/5]上，删除节点3
        ...
        如果r在区间(4/5, 1]上，删除节点5
        如果r大于1，不删除任何节点

        先遍历链表得出长度l，让a/b * l 向上取整得到要删除的节点编号，再顺着去删除即可


》翻转单向和双向链表：c-p40：
    要求空间复杂度是O(1)
    翻转单向链表，见j24-p142，
        链表长为2时直接调换头尾即可
        长大等于3时，要维持3个指针p1,p2,p3
        循环 p2.next=p1, p1=p2,p2=p3,p3=p3.next，结束条件是p3!=null
        最后再让p2.next=p1 ，很重要的一点是最后要让head的next为null。(head是起始链表的第一个节点)

    翻转双向链表：
        双向链表的难点在于要维持两个域(pre和next)的正确
        和单向链表相似，但要改部分：
        循环：p2.next=p1,p1.pre=p2, p1=p2,p2=p3,p3=p3.next，结束条件是p3!=null
        最后再让p2.pre=null, p2.next=p1, p1.pre=p2, head.next=null 
        (head是起始链表的第一个节点）



》环形单链表的约瑟夫问题：c-p43

    》普通解法：O(n*m)
        41个人绕成一个圈，从第一个人开始报数，报到m的就踢出环，从下一个人再开始报1，直到剩下一个人
        用环形单链表来描述这个过程。

        建一个环，然后过程很简单，不断更新计数，当计数为3时，删除当前节点，并把它的前后节点连起来
        最终直到只有一个节点，它的next是自己。

        可以引入dummy，但dummy不在环内，不参与循环过程
        利用循环，整个算法的复杂度是O(n * m) //n为节点个数，m为报数的值
        （每想删掉一个节点，都需要遍历m次，一共需要删除的节点数是n-1个，所以复杂度是O(n * m)）

    》进阶解法：O(n)
        如果链表节点数n，想在时间复杂度为O(N)内完成解答，要如何实现？
        原问题花费时间多，是因为我们一开始不知道哪个节点会最后活下来，所以需要不断删除。
        例如1->2->3->4->5->1,从头结点开始编号，
        如果环形链表节点数为n，作如下定义：从环形链表头结点开始编号，头结点编号1，下一个编号2.。。最后一个节点编号n
        最后只剩下一个节点，这个幸存节点在只由自己组成的环中编号为1，记为Num(1)=1;
        在由2个节点组成额环中，这个幸存节点的编号是多少呢？假设是Num(2)
        。。。
        在由i个节点组成额环中，这个幸存节点的编号是多少呢？假设是Num(i)
        。。。
        在由n个节点组成额环中，这个幸存节点的编号是多少呢？假设是Num(n)

        我们已经知道Num(1)=1,如果再确定Num(i-1)和Num(i)的关系，就可以递归求出了

        1.假设现在圈中共有i个节点，从头结点开始报数，报1的是编号1的节点，报2的是编号2的节点，假设报A的是编号B的节点，则A和B关系如下：
        A    B
        1    1
        2    2
        i    i
        i+1  1
        i+2  2
        ...
        2i   i
        2i+1 1
        ...
        举个例子，环形链表中有3个节点，报1的是编号1，报2的是编号2，报3的是编号3，报4的是编号1，
        报5的是编号2，报6的是编号3，报7的是编号1，。。

        A与B的关系可写成 B=(A—1)%i+1 。该表达式不唯一，总之只要找到报的数（A）和当前环中的编号节点（B）的关系即可。

        2.如果编号为2的节点被删除，环的节点数自然从i变成i-1.那么原来在大小为i的环中，每个节点的编号会发生什么呢？


        环大小为i的每个节点编号    删掉编号s的节点后，环大小为i-1的每个节点的编号
        ...                      ...
        s-2                      i-2
        s-1                      i-1
        s                        ----(无编号，因为被删掉了)
        s+1                       1
        s+2                       2

        假设环大小为i的每个节点编号即为old，环大小为i-1的每个节点编号记为new，则old与new的关系表达式为：old=(new+s-1)%i+1 (这个也不唯一，能满足即可) 

        3.因为每次都是报数到m的节点被杀，根据步骤1的表达式B=（A-1）%i+1, A=m。被杀的节点编号为(m-1)%i+1, 即s=(m-1)%i+1，代入到步骤2中的表达式中，即为old=(new+(m-1)%i+1)%i+1,经过化简为：
        old=(new+m-1)%i+1。至此，我们终于得到了Num(i-1)-new 和 Num(i)-old 的关系，且这个关系只和m与i的值有关。

        整个解法总结如下：
            1.遍历链表，求链表的节点个数记为n，时间复杂度为O(N),
            2.根据n和m的值，还有上面分析的Num(i-1)和Num(i)的关系，递归求生存节点的编号，递归为N层，所以时间复杂度为O(N)
            3.最后根据生存节点的编号，遍历链表找到该节点，时间复杂度为O(N)
            4.整个过程结束，总的时间复杂度是O(N)

        核心代码：getLive：递归，根据下一次环中幸存者的编号计算出它在此次环中的编号
        public int getLive(int len, int m){
            if(i==1) return 1;
            return (getLive(len-1, m)+m-1)%len+1;
        }


》将单向链表按某值划分成左边小，中间相等，右边大的形式：c-p52：
    设置3个指针假头，遍历原链表，第一个后面接比该值小的，第二个后面接和它等的，第三个后面接比它大的，最后再把3个链表从第二个节点开始（去除假头）连起来即可,这样能保证顺序也不变，sO(1), tO(n)

    需要注意的是，在往3个链上接节点的时候，要把当前节点的next置空，避免链一直那么长，所以要提前把next保存起来以便遍历


》两个链表相加生成链表，节点的值在0-9之间。如9->3->7 和 6->3相加 新链表是 1->0->0->0：c-p59
    》用sO(n)很简单，把两个链表分别压入栈中，弹栈相加，记录进位，和的个位新做一个链表，然后把结果链表翻转即可

    》用sO(1)
    先把两个链表翻转，然后逐节点加和，记录进位，和的个位新做一个链表，然后把结果链表翻转即可
    注意，一定要记得把dummy从原链表中断开，否则也就被翻转掉了



》将二叉搜索树转成有序的双向链表 c-p74
    二叉搜索树的中序遍历就是顺序，中序遍历即可，维持一个前一个遍历过的节点用来保持连接
    但要注意的是，如果引入假头节点，在最后返回的时候要断开假头结点和链表之间的联系（主要是head.pre）


》单链表的选择排序：c-p79
    要求sO(1),选择排序就是从未排序的部分找出最小值，然后放在排好序部分的尾部。每次都遍历未排序序列，挑出其中的最小值单独接在已排序序列的最后，并且把它从未排序链表中删除。而且删除的过程要保证链表在结构上不断开


```


#（注意区别插入排序和选择排序）：
插入排序是直接从未排序序列中取首元素，然后逐个与已排序的比，插入。
选择排序是从未排序的序列中选出最小的，直接插入到已排序序列的最后





```括号匹配
》查看括号序列是否合法： 22，c-p273.1
    》所以扫描一个括号序列是否匹配（括号匹配）可以如下做：
    初始化一个计数器count为0，扫描到左括号时，count++；扫描到右括号时，count--，扫描时如果出现count<0，则跳出，为无效匹配；扫描完后count不为0则无效匹配，为0则是有效匹配


》最长有效括号：给一串只包含(和)的串，找到最长有效括号子串：32，c-p273.2
    使用“入栈索引”的方法来匹配
    先入栈-1
    遇到'('时，入栈索引
    遇到')'时，先弹栈，如果弹栈后栈为空，入栈其索引，
            计算此时的 t=当前索引-栈顶元素， max = Math.max(t, max);
    最终答案是扫描完后的max。     
    这样做会使得每次遇到 ')'时，弹栈，然后此时的栈顶元素是当前能连起来的括号集合的最左端的前一个位置（放-1的原因）。


》删除无用的括号，字符串中除了括号还有别的字符，要保留，且有效匹配形式不止一种：301
    回退递归，对一个括号的策略只有要或者不要，这样可以使用回退递归（BackTracking）来将所有情况列出，
    对于不是括号的字符，直接加入并继续递归，当递归到最后时，对最后的字符串进行正确性判别，如果左括号不等于右括号则无效，
    如果相等，则再次进行一遍有效性判别（查看括号序列是否合法）
    public void trackBack(int 字符串遍历到的位置, int 目前已有的左括号数, int 目前已有的右括号数, String 原字符串, String 目前的字符串)


》两个单链表相交的一系列问题： c-p62
    两个单链表，可能有环也可能无环，给定两个头结点head1和head2，两个链表可能相交也可能不相交，实现一个函数，如果相交，返回相交的第一个节点，如果不相交，返回null
    要求：如果链表1长度为N，链表2长度为M，时间复杂度要求O(M+N), 额外空间复杂度请达到O(1)

    如何判断一个链表有环是关键，有的单链表的环不是全环，而是部分有环，如 1->2->3->2..
    如何判断这种环是难点

    用龟兔赛跑算法，p1每次跑1步，p2每次跑2步，如果p2为了null，则说明没环，一旦p2和p1相等了，说明有环，p1返回链表头，p1，p2都一步一步往前走，最先重合的点是环入口

    链表2也用上述办法，但过程中多加一步判断当前节点是否是链1的环入口，如果有节点是环入口，说明链1和链2的环是重合的。但二者的首个重合点不一定是环入口，而且二者的入环点可能不同，此时要算出环的长度，再算出链1链2分别环外的长度，让两个节点分别从距环相同距离的节点开始往前走，如果走到环上了还不相同，说明入环点不一样，返回任意一个入环点都可

    如果一个有环一个没环，一定不相交

    如果两个都没环，则p1先走l1再走l2，p2先走l2再走l2，第一次相遇的点就是第一个相交的节点。如果二者都走过了两个链表长，始终不相等，则说明不相交




```

## 这里要注意的是，split里面是正则表达式，有的符号可以直接放，有的不行，（特殊情况有 * ^ : | . \）
## 像想按"."分割，直接用split(".")是没有用的。必须要split("\\.") 才能正确分割

# 字符串问题
```
》有时候逐字符的回溯是比较能想到的简单方法，可以尝试一下，尽管对于难题来说可能超时，但简单题还是能A的： 3
》String.valueOf(97) 不是a，而是“97”，必须先把数字转成字符，即 String.valueOf((char)97);


》字面量创造的字符串（不用new），就在字符串常量区，用new的就在堆
~~~java
String s = new String("abc");
String s1 = new String("abc");

String s2 = "abc";
String s3 = "abc";

System.out.println(s==s1);  //false，在堆中创建不同的对象
System.out.println(s==s2);  //false，堆和常量区两个不同的对象
System.out.println(s2==s3); //true，都指向了字符串常量区的同一块区域
~~~


》给定一个字典和一串字符串s，字典中词长度相同，在s中找到所有子字符串，该串是字典中每个单词的一次连接，并且不包含任何中间字符。：30
    关键在于字典中词长度相同，所以若字典中所有词一共有w个字母，则在原串中，以w为窗口，每次挪动一个字符，每次对w中的子串做判断

    》判断一个字符串中是否只包含一些等长单词，要求串中包含且只能包含该单词一次
        将这些单词放入map中，由于是等长，则将串分割成该长度，一个词一个词遍历并加入map；当map中有1个该词时，加入，当有多个时，说明失败；若出现不在字典中的词时，也说明失败


》归类单词，给一个字符串数组，挑出其中包含一样字母的组成的放到一个数组中：49
    该题的关键就在于把给定单词转成字典序，如果字典序相同，那么一定包含一样的字母及个数
    》转换成字典序
        用26长度的int数组表示每个字母出现的次数，遍历单词并填该数组
        然后遍历数组，按照从头到尾，和相应字母个数来构造一字符串，就是原单词的字典序



》问题要求我们从字符串S返回最小窗口，该字符串具有字符串T的所有字符。如果它包含来自T的所有字符，那么让我们称之为窗口。： 76
    我们可以使用简单的滑动窗口方法来解决这个问题。
    在任何基于滑动窗口的问题中，我们有两个指针。一个right指针，其工作是扩展当前窗口，然后我们有left指针，
    其工作是收缩一个给定的窗口。在任何时间点，这些指针中只有一个移动而另一个保持固定。
    解决方案非常直观。我们通过移动右指针继续扩展窗口。当窗口具有所有所需字符时，我们收缩（如果可能）并保存最小窗口，直到现在。
    答案是最小的理想窗口。
    例如。 S =“ABAACBAB”T =“ABC”。然后我们的答案窗口是“ACB”，下面显示的是可能需要的窗口之一。

    算法

    我们从两个指针开始，left和right最初指向字符串SS的第一个元素。
    我们使用right指针展开窗口，直到我们得到一个理想的窗口，即包含T的所有字符的窗口。
    一旦我们有一个包含所有字符的窗口，我们就可以将左指针一个接一个地向前移动。如果窗口仍然是理想的窗口，我们继续更新最小窗口大小。
    如果窗口不再是包含所有所需字符，我们重复步骤2。

    还有一个难点是如何判断窗口的字符串包含T，使用一个HashMap m1保存T中出现过的字母和对应的频次
    窗口中的字母也用一个HashMap m2维护，对应的也是字母和出现的次数，设置一个int satisfied
    它代表窗口中的有几种字母已经满足了T，
    比如：T=AABC, S=ABCDBBDC
    当窗口为ABC时，satisfied=2，因为窗口中B满足，C满足，但A不满足（个数不够），
    设satisfied=0，count=T中的不同的字母个数，当satisfied==count时，说明窗口包含了T所有的字母
    当窗口增加一个字母时，m2中该字母对应的k值+1，如果此时该m1的键值等于m2的该键值，则satisfied++(大于不加)，
    相反当窗口减少一个字母时，m2中该字母对应的k值-1，如果此时m2的键值小于m1的该键值，则satisfied--

    这样判断的好处在于，当增减一个字母时，不用重新遍历整个窗口去匹配T，而是利用之前的信息。

# 双Map法：判断一个序列里是否包含另一个序列，且元素是无序的

    还有个好处也在于map的getOrDefault函数，用来读取次数最合适不过，因为如果有就返回，没有就设为0并返回，语义容易理解，没有的时候可以用递减到0
    而不用直接删除这个key

        ## 一定要掌握这种字符串的匹配方式，即通过两个HashMap分别存目标串中每个元素的次数和当前窗口内的元素的次数，
        ## require保存已经满足的条件的个数, count保存目标串中不同字符的个数

    # 这里吧这种方法叫双Map法，（或者双HashMap法），用在判断一个序列里是否包含另一个序列，且元素是无序的。


》解码字符串：394
    如 s = "3[a]2[bc]", return "aaabcbc"，s = "3[a2[c]]", return "accaccacc".
    维持一个倍数栈和字符串栈，

    如果是数字，加入数字栈，这里要注意对10以上的数字，要循环直到不是数字
    如果是字母，则直接附加到字符串栈顶
    如果是[,栈顶加一个""，作为括号内外的分隔符，再下面的字符串就要往它上附加了，
    如果是]，数字栈顶出栈为x，字符串栈顶的出栈，做x倍数，然后附加到字符栈顶
    最终的答案就是栈中元素的累积
    （附加：先把栈顶元素弹栈，然后把其他字符附在它后面，然后再把这个复合字符压栈）


》给定一个字符串s和一个非空字符串p，在s中找到所有p中字母组合的起始索引。：438
    Input:
    s: "cbaebabacd" p: "abc"
    Output:
    [0, 6]  //cba,bac

    先把p中的每个字母及其出现次数放入数组对应的位置pCount[26]中，并统计其长度为len，
    建立一个头指针start，尾指针end，并有一个标志flag，代表当前 [start, end]是否满足条件

    新建一个数组 sCount = int[26]
    一开始start和end都是在0处，先让end移动到len-1处，每移动一位，flag对应位置+1，当end-1移动到len-1时，
    比较sCount和pCount，如果每一位都相等，则flag=true

    从这里开始，end和start同时往后移，移动后 sCount[s.charAt(start-1)-'a']--,sCount[s.charAt(end)-'a']++
    若flag=false，则再次对比sCount和pCount，如果每一位都相等，则flag=true，否则为false
    若flag=true，则比较s.charAt(start-1)和s.charAt(end)，若等则flag=true，否则为false

    其实还是滑动窗口的思想，窗口大小一定(p的长度)，每次都看窗口内元素是否满足条件,不要用每次 s.substring和p去比，可以做但很慢，可以利用的点是，当s[i...j]和p匹配时，如果s[i]和s[j+1]相等，则s[i+1...j+1]和p匹配,即不用再去全量比较了


》词语转换word ladder，把beginword转成endword的最小花费，只能转成词典中的词语，且只能相互转换，一次只能转一个字母：127
    对每个词进行广度优先遍历，遍历当前已到达的词能到达的所有词，即逐个替换每个字母
    把所有词都放入一个词典set中，再有一个表示一个当前到达词的reachSet，遍历reachSet中的每一个词，将它能转换成的所有词的形式都扫描一遍，如果这个能转换的词在字典中，则把它加入一个临时toAddSet，同时把它从字典中删掉，当当前到达词都遍历完后，把当前到达词的reachSet换成这个临时toAddSet，继续遍历reachSet...
    当当前到达词中有endword时，说明已经转换成功
    当临时toAddSet中没有词时，说明字典中的词已经全部转过了，无法达到目标，则返回0


》word ladder2,给定两个单词(开始词和结束词)和一个字典的单词列表，找到从开始词到结束词的所有最短转换序列:126
    这个比Word Ladder复杂了一个维度，Word Ladder仅仅要求找到最小距离，这个需要把所有最小距离的路径全部显示出来。
    用bfs，找到dict中所有的词到起始词的最短路径，这一步是Word Ladder的一个加强版，因为要多一步记录距离，但核心步骤不变，仍然是遍历-发现在字典中-放入set-从字典中删除-继续遍历，但同时要用map记录距离，并且用一个list记录字典中每个词能转换的邻居，如，A和B可以换一个字母后互相得到，且AB都在字典中，则AB就是邻居。但要注意的是，只有距离start近的节点加距离远的节点，反过来不行，
    例如，A距离startword近，而B远一步，neighbor(A)中有B，但neighbor(B)中没有A，这是为了更好地为dfs服务
    然后用dfs，其实也就是trackback，从beginwor开始找到每一个距离值大一的词，并加入队列。直到当前词为endword，则找到一个答案序列





》即给一个字符串，给一个字典，要求把字符串分割成字典中单词的组合，求出所有的组合方式（相对顺序不能变）：140
    以字符串为主体进行dfs，这里节省时间的核心是用map来保存已经检查过的字符串对应的结果，过程如下代码：
    List<String> DFS(String s, List<String> wordDict, HashMap<String, List<String>> map){
        //map是用来复用结果的，如果被检查的字符串已经遍历过了，直接使用结果
        //这个map也是节省时间的核心
        if(map.containsKey(s)){
            return map.get(s);
        }

        //本层的结果
        ArrayList<String> res = new ArrayList<>();
        if(s.length()==0){
            res.add("");
            return res;
        }

        for(String word: wordDict){
            //如果当前串以word开头，当然对于一个s，只能有一次成功
            if(!s.startsWith(word)) continue;
            String sub = s.substring(word.length(), s.length());
            //找到余下部分的结果列表，并把本单词加到余下部分每个结果的开头，作为本层结果的开头
            //如果subList为空，则res也加不进去word
            List<String> subList = DFS(sub, wordDict, map);
            for(String per: subList){
                res.add(word + (per.isEmpty()?"":" ") + per);
            }
        }

        //将本次的结果存入map以便于复用
        map.put(s, res);
        return res;
    }


》单词s是否是单词t的改变字母顺序的结果：242，c-p242
    》方法一：用数组
    用两个数组分别记录两个单词中每个字母的个数，然后比较两个数组对应位置的值是否相同

    》方法二：用map
    用hashmap，key为字符，value为出现次数，遍历str1，把所有字符及次数都放入map中，然后遍历str2，每出现一个字符，若其在map中没有，直接返回false，若有，次数-1，当次数为0时从map中删除这个key，最后看map的size是否为0,



》给定一个字符串，找到其中第一个不重复的字符并返回它的索引。如果它不存在，返回-1。：387
    保存一个数组，表示每个字母出现过的次数，先遍历字符串保存出现过的次数
    再遍历第二遍，当次数为1时即为要找的字母


》给定一个字符串s由大写/小写字母和空空格字符' '组成，返回字符串中最后一个单词的长度。：58
    如果最后一个单词不存在，返回0。
    String[] strs = s.split(" "); //按空格分离
    if(strs.length==0) return 0;
    return strs[strs.length-1].length();


》给定两个二进制字符串，返回它们的和(也是一个二进制字符串)。：67
    输入字符串都是非空的，并且只包含字符1或0。
    两个字符串先变成一样长（根据更长的标准来），然后从低位到高位一位一位加，记录每一位的进位，将每一位的计算结果插入到结果字符的首位，注意处理最终可能出现的进位


》给定一个单词数组和一个width maxWidth，对文本进行格式化，使每一行都具有精确的maxWidth个字符，并且完全(左对齐和右对齐)。：68
    你应该用贪婪的方式来包装你的话;也就是说，在每一行中尽可能多地填充单词。在必要时填充额外的空格，以便每行都有精确的maxWidth字符。
    单词之间的额外空格应该尽可能均匀地分布。如果一行的空格数不能在单词之间平均分配，那么左边的空格将比右边的空格分配更多的空格。
    对于最后一行文本，它应该左对齐，并且单词之间不应该插入额外的空格。

    注意:
    一个单词被定义为一个由非空格字符组成的字符序列。
    每个单词的长度保证大于0且不超过maxWidth。
    输入数组单词至少包含一个单词。

    遍历字符串数组：
        若当前行的长度小于宽度
            如果是该行第一个串，则只需要该串长度小于宽度即可添加
            如果如果不是第一个字符串，则需要该字符长度+1小于宽度才可添加
            若当前行长度小于宽度，但当前串无法加到该行中了，则对该行进行补空格对其至宽度
        若当前行长度等于宽度
            结果集增加当前行，重置当前行为空。

    对最后一行进行特殊处理，与上面的不全空格的方法不同，空格要尽可能多的放在最后面

    补全空格的方法：    
        1. 先找有空格的地方，顺序从左到右去每个位置补空格，一遍不够再来一遍。。。
        2. 字符串中如果没有空格，则直接在字符串末尾补足maxwidth-n个空格, n是当前串的长度


》给定一个文件的绝对路径(unix风格)，简化它。换句话说，将它转换为规范路径。：71
    在unix风格的文件系统中，句号.引用当前目录。
    此外，双倍.将目录向上移动一级。有关更多信息，请参见:Linux/Unix中的绝对路径与相对路径

    注意，返回的规范路径必须始终以斜杠/开头，
    而且两个目录名之间必须只有一个斜杠/。
    最后一个目录名(如果存在)不能以/结尾。
    此外，规范路径必须是表示绝对路径的最短字符串。

    这里有个重要的点是，一旦返回一个目录的上级，这个目录就不要了
    用栈来做，当遇到/时，将其后面第一个不为/的字符串（压栈），如果后面是"."，则不动，如果后面是“..”则当前栈弹栈
    最后的路径是栈中元素倒过来


》打乱的字符串：给定一个字符串s1，我们可以递归地将它划分为两个非空子字符串，从而将它表示为二叉树。：87
    下面是s1 = "great"的一种可能表示:

        great
       /    \
      gr    eat
     / \    /  \
    g   r  e   at
               / \
              a   t

    要打乱字符串，我们可以选择任何非叶节点并交换它的两个子节点。
    例如，如果我们选择节点“gr”并交换它的两个子节点，它将生成一个打乱的字符串“rgeat”。

        rgeat
       /    \
      rg    eat
     / \    /  \
    r   g  e   at
               / \
              a   t
    我们说“rgeat”是一串“great”的乱串。
    如果我们继续交换节点“eat”和“at”的子节点，它会生成一个打乱的字符串“rgtae”。
    我们说“rgtae”是一串“great”的乱串。
    》
    判断s2是否是s1的乱串
    如果s1和s2相同，则是。
    首先要判断s1和s2中出现的字母及个数是不是完全一样，不一样则不是

    还是要用递归判断：
    遍历s1，位置索引为i
        如果s1[0,i)是s2[0,i)的乱串，且s1[i,len)是s2[i,len)的乱串，则s1是s2的乱串
        如果s1[0,i)是s2[len-i,len)的乱串，且s1[i,len)是s2[0,len-i)的乱串，则s1是s2的乱串
    //这个很关键，可以是s1的头对应s2的头，也可以是s1的头对应s2的尾，只要有一种情况满足，那总体就是满足的
    遍历完s1若都不满足，则返回false

    # 总体的思路就是分割子问题，持续把问题范围变小再解决


》比较两个版本号version1和version2。：165
    如果version1 > version2返回1;如果version1 < version2返回-1，否则返回0。
    您可以假设版本字符串是非空的，并且只包含数字和.
    .字符不表示小数点，用于分隔数字序列。
    例如，2.5并不是“2.5版”或“到第三版的半路”，它是第二次一级修订的第5次二级修订。
    您可以假定版本号的每个级别的默认修订号为0。例如，版本号3.4的第一级和第二级修订号的修订号分别为3和4。第三、四级修订号均为0。

    版本字符串由点号分隔的数字字符串组成。这个数字字符串可能有前导零。
    版本字符串不会以点开始或结束，它们也不会是两个连续的点。

    》方法一：
        直接从前往后比较即可，把每个版本号按“.”分割成数组，以其中短的长度为基准从前往后（从大版本到小版本）比较。如果这些都相同，则再将长的版本号剩下的部分提取出来， 如果这些是0，则两版本一样大，若不是0，则是长版本的大

    》方法二：
        以长的为主导，从前往后比较，每次比较当前位对应的数字，如果短的不够了，直接补上0，如果在当前位能分出大小，则直接返回，当前位相等则继续比较下一位，全部比较完还没分出大小则二者相等

    # 这里要注意的是，split里面是正则表达式，有的符号可以直接放，有的不行，（特殊情况有 * ^ : | . \）
    # 像这道题，直接用split(".")是没有用的。必须要split("\\.") 才能正确分割


》所有的DNA都是由一系列核苷酸组成的，缩写为A、C、G和T，例如:“ACGAATTCCG”。在研究DNA时，有时识别DNA中的重复序列是有用的。：187
    编写一个函数来查找一个DNA分子中不止一次出现的所有10个字母长的序列(子串)。
    最简单的做法就是用窗口法，每次一个字母，一次取10个字母往后取，且放入set中，要已经出现过，则说明是重复的


》给定两个字符串s和t，判断它们是否同构。：205
    如果可以将s中的字符替换为t，则两个字符串是同构的。
    必须用另一个字符替换出现的所有字符，同时保留字符的顺序。没有两个字符可以映射到同一个字符，但是一个字符可以映射到它自己。
    用map保存映射关系，如果遍历到一个字母已经映射过但不是它将要映射的字母，返回false,要注意的是两边都是一一映射，不能只保存一个映射，而应该两边都保存
    ## 同构字符串：两个字符串的字符之间一一映射


》最长不含重复字符的子字符串：j48-p236
    请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度，假设字符串中只包含a-z的字符，例如，在字符串arabcacfr中，最长不含重复字符的子字符串是acfr，长度为4
    》方法一：
        使用窗口法，前后两个指针front和tail，tail往前移动，每遍历一个字符，对应的数组位置+1，当该位置数字为2时，tail不动了，front向前移动，去掉的字母的对应的计数-1，直到该位置的数字变成1。
        count[26]是当前窗口内各个字母的个数。
        这有几个需要注意的点：用1个boolean b控制front和tail哪个走。若字符串长度为0或者1时，直接返回答案。否则先把str[0]，加算进去，front=0,tail=1。front一轮更新后在窗口内，往前走时，也是先从窗口中剔除，对应的count-1，若重复的字母就是当前字符，b=!b,front再++；tail一轮更新后在窗口外，往前走时，先把此时tail的字符加入窗口，对应的count+1, 若该count>1，则b=!b  否则 更新最长子字符串。
    》方法二：动态规划
        dp[i]表示以第i个字符结尾的不包含重复子字符串的最长长度，如果第i个字符之前没有出现过，则dp[i]=dp[i-1]+1
        如果第i个字符之前出现过，设当前位置距离上一次出现过的位置为d
            若d<=dp[i-1],则说明第i个字符上次出现在dp[i-1]所对应的最长子字符串中，dp[i]=d;
            若d>dp[i-1]，则说明第i个字符上次出现在dp[i-1]所对应的最长子字符串之前，则dp[i]=dp[i-1]+1
        用数组pos[26]来记录当前字符上一次出现的位置,一开始全部设置为-1，表示没出现过。


》第一个只出现一次的字符  j50-p243
    》方法一：
        用一个数组保留每个字母出现的次数，用一个hashmap映射每个字母第一次出现的位置，只需遍历一遍字符串就可以构建出来，再依次遍历每个字母，当出现次数为1，且位置小于当前最小位置时，更新该最小位置(只对出现全小写字母或者全大写字母管用)

    》方法二：
        遍历串，将hashmap存入每个字符出现的次数，然后再遍历串，让该字符出现次数为1时，返回该位置（针对任意大小写的字符）



》定义一个函数，输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符：j-p246
    将第二个字符串中所有字符及出现次数全部存在hashmap中，再遍历第一个字符串，当出现字符在map中对应的次数大于0时，结果集不加它，且map中对应的次数-1。


》定义一个函数，删除字符串中所有重复出现的字符，如google变成gole  j-p246-2
    将字符串中所有字符及出现次数全部存在hashmap中，并且再设置一个map记录当前结果集中该字符出现的次数，再遍历一遍原串，当其在原串出现次数大于1且在当前结果集中出现次数等于1时，不加入结果集；否则加入结果集


》字符流中只出现一次的字符：j-p247
    请实现一个函数，用来找出字符流中第一个只出现一次的字符，例如，当从字符流中只读出前两个字符“go”的时候，第一个只出现一次的字符是“g”，当从该字符流中读出前6个字符“google”时，第一个只出现一次的字符是“l”

    把读入的字符及其对应的次数放入hashmap中，并且按序放入一个队列中，每当读入一个字符时，查看队头的字符对应的次数是否为1，如果是，队列不变，否则，出队直到队列头的字符次数为1


》给定一个模式和一个字符串str，查找str是否遵循相同的模式。：290
    Input: pattern = "abba", str = "dog cat cat dog"
    Output: true

    Input:pattern = "abba", str = "dog cat cat fish"
    Output: false

    这里的follow表示完全匹配，即模式中的字母和str中的非空单词之间存在双射。
    用map保存模式和对应的词的关系即可,但还是要注意是双向匹配，即a对应x，则b不能再对应x，
    所以要用两个map，char-string 和 string-char
    边遍历边加，如果当前有个map中string和char对应关系不对，则是false

    还有要注意的一点是，必须先判断str中的词数和pattern中的字符数是否相等，若不等返回false，否则会误判


》翻转字符串：j58-p284，c-p262.1
    把“student. a am I”翻转为：“I am a student.”
    》方法一：
        很简单，用split按空格分割，然后倒序组成一个新的字符串，但要注意全空格的情况，这样split的字符串数组是空的，则直接返回原字符串即可
    》方法二：
        先把字符串整体倒序，然后再每个单词做倒序，就可以得到答案


》循环左移字符串：c-p262.2
    给定一个字符类型的数组chas和整数size，请把大小为size的左半区整体移到右半区，右半区整体移到左半区
    如chas看作字符串"ABCDE", size=3,则调整为"DEABC"
    这里其实是循环左移size位
    不论对于循环左移还是右移，首先让k=k%len;
    循环左移k位：先把原串分成[0...k-1]  [k...len-1]两部分
        两部分先各自翻转：[k-1...0] [len-1...k]
        然后字符串整体翻转： [k...len-1] [0...k-1]

    循环右移k位相当于循环左移 len-k 位



》加法数是一个数字可以构成加法序列的字符串。：306
    一个有效的加法序列应该包含至少三个数字。除了前两个数字外，序列中的每个后续数字都必须是前两个数字的和。
    给定一个只包含数字“0”-“9”的字符串，写一个函数来确定它是否是一个加法数字。这里序列必须是连着的直到最后字符串结束
    如上面，1，99，100，199 ，  1+99=100，99+100=199
    注意:加性序列中的数字不能有前导零，因此序列1、2、03或1、02、3无效。
    这里使用简单的递归思想，如果x1，x2的和等于下一个数字为x3，则则再判断x2和x3的和，持续往下走
    //这个题需要看一下代码：
    public boolean isAdditiveNumber(String num) {
        int len = num.length();
        for(int i=1;i<=len / 2;i++){  //i不超过总长度除以2，由于奇数除以2向下取整，所以这里必须用小等于号
            //i是第一个数字的长度
            //取[0,i), 第0个数字为0且有效的情况，只能是第一个数字就是0，否则都无效
            if (num.charAt(0) == '0' && i > 1) return false; //若有前导0
            BigInteger x1 = new BigInteger(num.substring(0, i)); //取(0,i)

            //显然两个加数的长度都不能大于和的最大长度（两个加数的长度分别为i和j，它们两和的长度一定不小于它们，且字符串剩下的可用长度是len-（i+j））
            //这个就是它们和的长度的上限
            for(int j=1;Math.max(i,j)<=len-(j+i);j++){
                //j是第二个数字的长度
                if(num.charAt(i) == '0' && j > 1) //第二个数若有前导0，不要直接返回，而是跳出此次循环，让第一个数增长一位（后面加上0），这样第二个数就没有前导0了
                    break;
                BigInteger x2 = new BigInteger(num.substring(i, i+j));
                if(isValid(x1, x2, i+j, num)) return true;
            }
        }
        return false;
    }
    boolean isValid(BigInteger x1, BigInteger x2, int startPos, String num){
        if(startPos==num.length()) return true;
        BigInteger sum = x1.add(x2);
        return num.startsWith(sum.toString(), startPos) && isValid(x2, sum, startPos+sum.toString().length(), num);
    }


》统计字符串（只有小写字母）中相同字符出现的次数，并按字典序输出字符及其出现次数。：b21
    例如字符串"babcc"归一化后为"a1b2c2"。
    很简单，26大小的数组存储每个字母的次数，然后顺序输出字母和次数即可


》一个数据集，其中每个样本都是一个字符串（长度小于100），字符串后六位是纯数字，将所有样本的后六位数字提取出来，对其进行排序并逐行输出：b22
    提取每个样本的后六位很简单，得到字符串后能知道长度len，直接substring(len-6,len)即可
    不要全部提取出来然后排序，最好是每提取一个就排序，可以用构建二叉排序树的方式构建一个二叉排序树，每提取一个数字，将其插入到树中，最后对树进行中序遍历即可，要注意的是，树节点要有一个cnt记录有多少个当前值，因为数字有可能重复，所以输出的时候按照出现的次数输出节点值


》给定一个只包含小写字母的字符串，删除重复的字母，使每个字母只出现一次。您必须确保在所有可能的结果中，您的结果按字典顺序是最小的。：316
    例如：
    Input: "cbacdcbc"
    Output: "acdb"

    对于当前串中的的最小字母，我们一定选最左边的这个字母进入答案，例如，串中有多个a，一定是最左边的a能保证后面跟的串有可能最小

    遍历串，记录当前串中每个字母出现的个数
    遍历串，记录当前最小且最左的字母的位置pos，作为答案串开始的位置，当出现一个字母只出现这一次时，跳出循环，因为pos不能比这个字母的位置更右，否则该字母就进不到答案串里了,设pos对应的字符是x
    返回 x + sub.      sub = 递归（ s.substing(pos+1)且消除了其中所有的x的字符串 )


》有一个只包含26个小写字母的字符串，再从26个字母中随机拿出一个，插入字符串的任意一个位置，组成新的字符串，问新的字符串一共有多少种可能性：b25
    用set保存所有可能性，然后把26个字母依次添加到字符串中的所有可用位置即可。要注意，StringBuilder.insert无法插入到末尾，插到末尾用append


》给定一个字符串数组单词，找出长度(word[i]) * 长度(word[j])的最大值，：318，b33
且这两个单词不共享公共字母。您可以假设每个单词只包含小写字母。如果不存在这两个单词，则返回0。

    》方法一：
        关键在于如何快速判断一个单词中的字母是否在另一个单词中，如果使用set，可以但是不够好。
        因为小写字母只有26个，考虑对每个单词使用一个整数（31位，不考虑符号位），若有字母x，则让该整数二进制的第x-'a'位为1，否则为0，若要判断两个单词是否有同样的字母，只需让两个单词对应的这个整数做与操作，如果不为0则说明有相同的字母

    》方法二：
        已知一个字符串数组words，要求寻找其中两个没有重复字符的字符串，使得这两个字符串的长度乘积最大，输出这个最大的乘积。如：words=["abcd","wxyh","defgh"], 其中不包含重复字符的两个字符串是"abcd"和"wxyh"，则输出16 words=["a","aa","aaa","aaaa"], 找不到满足要求的两个字符串，则输出0

        检测直接用暴力破解即可，对比两个字符串中是否有重复字符，可以先用hashset把str1中的每个字母保存，这里有个窍门，当set中的元素个数为26时，就说明所有字母都包含了，直接返回true即可

        》剩下要注意的点在于ArrayList转数组
        不能用如下方法强转
            String[] strs = (String[]) list.toArray();  //会报错，类型转换错误
        必须用如下方法：
            String[] strs = list.toArray(new String[list.size()]);

        还有一点要注意，split方法可能会返回一个长度为1的字符串数组，这个唯一元素长度为0，即""。如果对该元素处理往往出错，要注意规避。



》我们定义字符串包含关系：字符串A=abc，字符串B=ab，字符串C=ac，则说A包含B，A和C没有包含关系。：b27
    两个字符串，判断这个两个字符串是否具有包含关系，测试数据有多组，请用循环读入。如果包含输出1，否则输出0.

    用字符串的contains即可判断，要注意的是是否有包含关系，包括A包含B，也包括B包括A，两者都要考虑。
    多行数据，用Scanner的hasNextLine来判断是否有下一行数据



》字符串压缩：b30
    对字符串进行RLE压缩，将相邻的相同字符，用计数值和字符值来代替。例如：aaabccccccddeee，则可用3a1b6c2d3e来代替。
    遍历字符串，如果当前字符等于pre，则计数+1，如果不等，则将当前计数和pre放入答案集中，然后更新计数为1，pre为当前字符



》解析加减法运算：b31
    解析加减法运算
    如：
    输入字符串："1+2+3" 输出："6"
    输入字符串："1+2-3" 输出："0"
    输入字符串："-1+2+3" 输出："4"
    输入字符串："1" 输出："1"
    输入字符串："-1" 输出："-1"

    已知条件：输入的运算都是整数运算，且只有加减运算
    要求：输出为String类型，不能使用内建的eval()函数

    关键之处在于要能把大于1位的数准确识别出来
    设置基础值ans=0，判断第一个字符是不是符号，用preOp表示上一个符号，preOpPos表示上一个符号的位置
    则，当遇到一个符号时(其位置为i)，前一个数字就是substring(preOpPos+1,i)，其符号就为preOp，把它加到ans上。
    当遍历完时，再把最后一个数也加上即可


》双生词：bb3
    双生词是满足两个条件的字符串：s和s'
    1.s与s'长度相同
    2.将s首尾相接绕成环，再选一个位置切开，顺时针或逆时针能得到s'
    给出测试组数t，表示共有多少组数据
    对于每组数据，第一行表示共有多少个字符串，接下来n行，每行一个字符串
    对于每组数据，如果存在双生词，输出Yeah，否则输出Sad

    每个字符串能得到的双生词有 2len 个，len是字符串长度
    对于一个组
    把第一个词能构成的双生词全部构造出，放在以这个词为key的map中，然后遍历剩下的词，只要有一个能满足，剩下的就不用再构造了，返回Yeah
    如果第一个试了不行，再把第二个构造出，以此类推


》字节2019笔试题2：
    3个同样的字母放在一起，去掉一个；AABB型的，去掉一个B
    第一次遍历，发现连续有3个一样的字符，把第一个替换为#（发现#则继续往后看，#视为没有即可）
    第一次遍历，发现连续有AABB，把第一个B替换为# （发现#则继续往后看，#视为没有即可）
    再次遍历，遇到不为#的就把它加到答案字符串中


》字符串中数字子串求和：c-p243
    给定一个字符串str，求其中全部数字所代表的数字之和
    1.忽略小数点符，如"A1.3" 其中包含两个数字1和3
    2.如果紧贴数字子串的左侧出现字符"-",连续出现的数量为奇数时，数字视为负，连续出现的数量为偶数时，数字视为正，例如，"A-1BC--12"，其中包含数字为-1和12
    例如：str="A1CD2E33" 返回36
         str="A-1B--2C--D6E" 返回7

    首先遍历的时候如果遇到数字，则持续走到没数字位置，把连着出现的数字作为一个数，然后往前找它的符号，直到不是"-", 如果-是奇数则取反，否则不变，把这个数加到结果上


》去掉字符串中连续出现的k个0的子串：c-p245
    给定一个字符串str和一个整数k，如果str中正好有连续的k个'0'字符出现时，把k个连续的'0'字符去掉，返回处理后的字符串

    str='A00B' k=2 返回 AB
    str='A0000B000' k=3 返回"A0000B"

    遍历字符串，设一个记录累计0的个数cnt，当是0时+1，不是0时检查这个cnt是否为k，若为k则把答案串的后k个字符删除掉。 做完上述操作后，cnt重置为0。
    把字符加入答案集中。这样做可能会漏掉最后的部分，遍历完后再看一次cnt是否为k，是则删除答案串的后k个字符
    时间复杂度O(n), 空间复杂度O(1) （为了方便用了toCharArray，其实可以不用）



》判断两个字符是否互为旋转词：c-p247
    判断一个字符串str，把字符串str前面任意部分挪到后面形成的字符串叫做str的旋转词，如str="12345",str的旋转词有"12345", "23451", "34512", "45123" 和"51234"。给定两个字符串a和b，请判断a和b是否互为旋转词

    把a放入一个builder中，然后每次把开头的字符放到后面，每次放1个，共放len-2次，每次看builder.substring(i+1)与b是否相等,这里不要delete，因为删除会引起builder底层的数组进行重新组织，很费时间。


》替换字符串中连续出现的指定字符串：c-p251
    给定三个字符串 str，from，to，把str中所有的from子串全部替换成to，对于连续出现from的部分要求只替换成一个to
    如 str=123abc from=abc to=4567  返回1234567
    str=123 from=abc to=456 返回123
    str=123abcabc from=abc to=X 返回123X

    遍历str，对于每一个位置i，看substring(i)是不是以from开头的，如果是，那么标记一个flag=true，并且把to加到答案中
    如果flag已经为true，则直接跳过这么长的，继续看下一个，如果不是，则让flag=false，
    如果不是，则把当前的这个字符加到答案中



》字符串的统计字符串：c-p253.1
    给定一个字符串，返回str的统计字符串，例如，aaabbadddffc的统计字符串为a3b2a1d3f2c1
    遍历，维持一个遍历的数字cnt，和前一个字符pre，如果cur==pre，则继续cnt++，否则，输出cnt+pre，然后让cnt=1，pre=cur，这样最后的字符需要额外再加一遍


》c-p253.2
    给定一个字符串的统计字符串，再给定一个整数index，返回cstr所代表的原始字符串上的第index字符，例如 "a_1_b_100",所代表的原始字符串上第0个字符是'a',第50个字符是'b'

    把cstr按"_ " 分割成字符串数组，则第偶数位一定是字符，奇数位一定是数字 （因为从0开始的）
    i从1开始，i=i+2;
    用一个cnt记录当前到多少个字符了，cnt += strs[i] 若index+1 <= cnt 则字符就是strs[i-1];


》判断字符数组中是否所有字符都只出现过一次：c-p255
    给定一个字符类型数组chas[]，判断chas中是否所有的字符都只出现过一次
    如chas['a','b','c'] 返回true，chas['1','2','1']返回false

    时间和空间O(N)的做法：用HashSet即可，很简单
    空间O(1):将chas排序，排序后如果一样的就一定在一起，关键是要用空间复杂度O(1)的排序算法：
    其实只有冒泡空间复杂度是O(1),堆排和快排由于是递归，空间复杂度是O(logn),但冒泡的时间效率低于快排和堆排


》字符串的调整与替换：c-p260.1
    给定一个字符类型的数组chas[], chas右半区全是空字符，左半区不含有空字符。现在想将左半区中所有的空格字符替换为%20，假设chas右半区足够大，可以满足替换所需要的空间，完成替换函数
    举例：如果把chas的左半区看作字符串，为"a b  c",假设chas的右半区足够大，替换后，chas左半区为"a%20b%20%20c"
    替换函数的时间复杂度是O(n), 额外的空间复杂度是O(1).

    先遍历一遍数组，看左半区有多大，记为len，其中的空格个数为num，那么总的需要的长度为len+2* num，则一个指针p1指向整个数组的最后，一个指针p2指向左半区的最后，p2如果不是空格，则把p2的字符放到p1处，p2--，p1--。如果p2是空格，则依次把%，2，0放到p1中，这样就可以得到替换后的数组


》字符串的调整与替换2：c-p260.2
    给定一个字符类型数组chas[],只含数字字符和'* '字符，现在想把所有的* 挪到chas左边，数字字符挪到右边，完成调整函数，要求空间复杂度为O(1)
    先遍历一遍数组，找出其中数字的个数，让一个指针p1在数组尾部，一个指针p2在最后一个数字字符处，如果p2是数字字符，则让chas[p1--]=chas[p2--].，否则只让p2--，这样就能把所有数字字符按原顺序复制到数组尾部，然后再在数组前面替换掉原星号个数个星号即可


## 上述两题都是利用倒着复制的技巧，很多字符串问题和这个技巧有关，要重视


》数组中两个字符串的最小距离：c-p266.1
    给定一个字符串数组strs，再给定两个字符串str1和str2，返回strs中str1与str2的最小距离，如果str1或str2为null，或不在strs中，返回-1；
    strs=["1","3","3","3","2","3","1"] str1="1", str2="2",返回2.
    strs=["CD"], str1="CD", str2="AB", 返回-1.

    遍历数组，记录str1和str2最近出现的位置pos1和pos2，当遍历到str1时，看i与pos2的差的绝对值是多少，更新pos1=i；遍历到str2时，看i与pos1的差的绝对值是多少，，更新pos2=i，最后只保留最小的答案即可

    》c-p266.2，承接上题
        如果查询的次数有很多，如何把每次查询的时间复杂度降为O(1)?
        首先可以把所有的字符串去重后放进一个list，然后构建一个矩阵dis[size][size]
        dis[i][j]就是list中第i个元素与第j个元素之间的距离，而且为了O(1)的查找效率，把list中每个字符串的索引作为value，字符串作为key放到一个map中。
        对于strs中每一个位置的string，用一个list保存每一个字符串的最新的位置，在每遍历到一个位置后，去检查其与其他字符的最小距离变了没，变了的就更新。
        最终统一dis[i][j] 让dis[i][j]等于dis[i][j]与dis[j][i]中的小值，就完成了距离矩阵
        查询时只需要找到str1和str2对应的索引i和j，然后返回dis[i][j]即可，

        建立时的复杂度 tO(n^2), sO(n^2)
        查找时的时间复杂度tO(1)


》0左边必有1的二进制字符串数量：c-p278
    给定一个整数n，求由0字符与1字符组成的长度为n的所有字符串中，满足0字符的左边必有1字符的字符串数量

    n=1， 0，1 只有1满足要求，返回1
    n=2， 00，01，10，11 只有 10和11满足要求，返回2
    n=3 000 001 010 011 100 101 110 111    只有101 110 111满足要求，返回3

    p[i]表示0到i-1位置上的字符已经确定，这一段符合要求且第i-1位置的字符为’1‘时，如果穷举i到n-1位置上的所有情况会产生多少种符合要求的字符串，比如n=5，p(3)表示0到2位置上的字符已经确定，且这一段符合要求且位置2上的字符为’1‘是，假设为”101..“，在这种情况下，穷举3-4位置所有可能情况会产生多少种符合要求的字符串，因为只有10101、10110、10111，所有p(3)=3,也可以假设前三位是111.. p(3)同样也为3
    根据p(i)的定义，位置i-1的字符为1时，位置i的字符可以是1，也可以是0，如果位置i的字符是1，那么穷举剩下字符的所有可能性，，且符合要求的字符串数量就是p(i+1)的值，如果位置i的字符是0，那么位置i+1的字符必须是1，那么穷举剩下字符的所有可能性，，且符合要求的字符串数量就是p(i+1)的值
    则p(i)=p(i+1)+p(i+2), p(n-1)表示除了最后位置的字符，前面的子串全符合要求，且倒数第二个字符为’1‘，此时剩下的最后一个字符既可以是’1‘，也可以是’0‘，所以p(n-1)=2。p(n)表示所有的字符串已经完全确定，且符合要求，最后一个字符(n-1)为’1‘，所以此时符合要求的字符串数量就是0到n-1全体，不再有后续可能性，所以p(n)=1

    i< n-1时，p(i)=p(i+1)+p(i+2)
    i= n-1时，p(i)=2
    i=n 时，p(i)=1
    可以写出递归的形式，

    根据上面的结果，n为1，2，3，4，5，6，7时，结果为1，2，3，5，8，13，21，34
    形如斐波那契数列，只不过初始项是1，2所以可以用更快的方法
    dp[i]=dp[i-1]+dp[i-2];

    （不太理解为什么p(i)是前面确定的情况下能代表整个字符串的情况）



```



# 需要注意的是，in.nextInt()后面跟一个in.nextLine(), nextLine不会换行读取，而是读当前行第一个整数后面的部分
    6
    5
    in.nextInt()：6
    in.nextLine()： '\n' :即就读了个换行符
    所以想第一个数字后就换行的话，用如下方式：
    Integer.valueOf(in.nextLine()); ： 6
    in.nextLine()  ： 5

    nextLine是读取当前缓冲区一直到 \n 或 \r 为止（包括）。


## 负-负不会溢出，负-0不会溢出，0-负可能溢出，正-负可能溢出，负-正可能溢出，正-正不会溢出（同号相减一定不溢出，异号相减可能溢出）
## 正+正可能溢出，正+负不会溢出，负+负可能溢出  （同号相加可能溢出，异号相加一定不溢出）
## 一旦溢出，结果的符号一定会和预期符号不同




```数学问题

》给定两个整数的被除数和除数，在不使用乘法、除法和余运算符的情况下对两个整数进行除法。 ：29
    想法是计算最大的k，
    使得2^k * y <= x，且2^(k+1) * y > x 然后从x减去2^k * y并且将2^k加到商上。 ：(2^k * y + 2^m1 * y + 2^m2 * y + ...) + s = x

    例如 - 如果x = 11（1011） 且y = 4（10），则k = 2，因为2 * 2^2 <= 11
    且2 * 2^3> 11.我们从11（1011）中减去2 * 2^2= 8（1000）得到 3（11），
    向商添加2^k = 2^2 = 4（100），并通过将x更新为 3（11）继续。

    使用2^k * y的优点是可以使用移位非常有效地计算，并且在每次迭代中x减半。 
    如果需要n位来表示x / y，则存在O（n）次迭代。 如果通过迭代k计算最大k使得
    2^k * y <= x，并且由于每次迭代具有时间复杂度O（n），这导致O（n^2）算法。

    # 一遇到以2为底的乘除法就要想到移位运算，尽可能尝试移位
    ## 2^k = 1 << k;
    ## y * 2^k = y << k;
    ## y / 2^k = y >> k;

    这样可能不够直观，但思考一个问题：除法的本质就是算x中有多少个y.一般的做法，是从x中去掉一个y，再去掉一个y。。。一直去到不能再去为止。这里的做法是，通过移位，知道x中至少有 2^k个y，但没有 2^(k+1)个(但可能有 2^k + b 个)，那么先去掉2^k个y，得到的结果为x1，再通过移位知道其中有2^m个y，但没有 2^(m+1)个，那么再从x1中去掉2^m个y，得到的结果是x2.。。。最后直到结果为 xn时，里面已经没有y了，就作罢，除法答案就是上面的 2^k + 2 ^m + ....



》给定一个数，它最少能被几个完全平方数的和表示出来：279
    如 12=4+4+4，答案为3；13=4+9 答案为2
    对于数x来说，其完全平方和的表达式若为f(x),如f(12)=4+4+4
    对于每一个i，循环j从1到j^2==i, f(i)=j * j + f(i - j * j)，因此，若dp[i-j^2]是i-j^2中的最少的完全平方和个数，
    则dp[i] = min(dp[i-j^2]+1) , j: 1->sqrt(i)


》数值的整数次方（乘方）：j16-p110，50
    考虑自顶向下的动态规划
    //为了高效，奇偶判断也不用 %2==1or0，而使用 与1做与运算，若1为奇若0为偶
    a^n  如果n是偶数，则 a^n = (a^(n/2) * a^(n/2))   //为了高效，n/2最好换成n>>1
         如果n是奇数，则 a^n = (a * a^(n/2) * a^(n/2))

    终止条件是 n==0时，a^n=1

    而且要用HashMap保存中间结果防止重复计算
    还要注意有可能指数可能是负数，在先把它变成正数来进行DP，直到最后时取个倒数即可，（负数只有可能在最终结果，因为处理后，子问题中的n都是正数）
    要考虑边界条件，基数是0且指数是负数的情况下，取倒数就出问题，所以直接在基数为0的情况下返回0（0的0次方在数学上没有意义，但要考虑这种边界）


》输入数字n，按顺序打印出从1到最大的n位十进制数，如输入3，则打印1、2、3一直到最大的3位数999： j17-p114
    要注意的是，可能n会非常大，要考虑大数的问题，用long long都不够，因为n可能取到的是最大整型

    显然用字符串比较合理，在字符串上模拟加法就是关键，加法的进位至多只能是1，且是每次都加1，针对字符串中每一位都是一个数字，从低位到高位加(所以要反着遍历字符串)，处理好进位就问题不大

    要考虑边界值，当n<=0时直接返回
    如果循环条件每次都要遍历一遍字符串得出长度，效率不高。好办法是设置一个全局变量，在+1的时候从0开始顺便累加字符串长度，即累加该变量
    循环条件是该变量不大于n



》两个大数相加减 ： j-p119(具体见实现)
    大数问题都使用字符串很方便，核心还是逐个遍历两个字符串，从低位开始往高位加，但这里要注意，由于两数不一定一样长，所以要先让两个字符串一样长，
    短的在高位补0

    大数相减，等于大绝对值-小绝对值，要注意符号和绝对值大的数一致，两数相减的话直接就用绝对值减，要注意做单数位的减法，要先借位（借10），减完如果还不上，就标记借位，如果还的上（差大等于10），则不标记借位


》求两数的汉明距离,直接把两数异或，可以得到一个数，它们的汉明距离就是这个数中1的个数：461


》对数列：1, 12, 123,...12345678910,1234567891011...。计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。：b2
    如：l=2，r=5：12，123，1234，12345 其中12，123，12345可以被3整除，即答案为3

    1代表第i个数不是3的倍数，0代表是3的倍数

    i = 1 ----> 1   1
    i = 2 ----> 0   12
    i = 3 ----> 0   123
    i = 4 ----> 1   1234
    i = 5 ----> 0   12345
    i = 6 ----> 0   123456
    i = 7 ----> 1   1234567
    ………………
    也就是说[1,x]中共有f(x)=(x+2)/3 个数不是3的倍数

    即[1,2]中是 1，12  其中有1个1，即1---》1
    [1,3]中是1，12，123   f(3)=(3+2)/3=1 个1 ，即 1---》1
    [1,4]中是1，12，123，1234，f(4)=(4+2)/3=2 个1 即 1---》1， 4--》1234
    因此，边界为l到r之间的数字共有 f(r)-f(l-1)个数不是3的倍数，而l到r之间共有r-l+1个数
    因此 l到r之间的3的倍数的个数为 r-l+1-f(r)+f(l-1)   （具体证明见题目下）


》用数组模拟一个数然后算+1：66
    显然主要的难点在于解决进位
    从后往前遍历加，要加1相当于一开始就从后面有一个进位
    # 还是很重要的一点：加法的进位最多只能是1


》计算一个数的平方根(开方/根号)：69
    有两种办法：一是二分搜索，二是牛顿迭代法。
    》1. 二分搜索
    对于一个非负数n，它的平方根不会大于（n/2+1）（谢谢@linzhi-cs提醒）。在[0, n/2+1]这个范围内可以进行二分搜索，求出n的平方根。
    ///计算过程可能会溢出，所以都用long表示

    》2. 牛顿迭代法
    计算x^2 = n的解，令f(x)=x^2-n，相当于求解f(x)=0的解，可以画个图看
    首先取x0，如果x0不是解，做一个经过(x0,f(x0))这个点的切线，与x轴的交点为x1。
    同样的道理，如果x1不是解，做一个经过(x1,f(x1))这个点的切线，与x轴的交点为x2。
    以此类推。
    以这样的方式得到的xi会无限趋近于f(x)=0的解。
    判断xi是否是f(x)=0的解有两种方法：
    一是直接计算f(xi)的值判断是否为0，二是判断前后两个解xi和xi-1是否无限接近（判断两数的整数部分是否相同，相同就算是满足接近的要求了）。


》杨辉三角，给定层数，获得一个杨辉三角：118
    对于每一行的第i个元素，等于上一行的第i-1个元素和第i个元素之和（除了第一个元素和最后一个元素都是1）


》给出两个正整数n和k，求满足以下条件的数对(x,y)的个数：x和y均不大于n, 并且x除以y的余数大于等于k。：b5
    x可以在 [1, n] 上取，但是y只能在 [k, n]上取，因为k以下都不存在大于等于k的余数。
    所以遍历y，对于每一个y，统计符合的x的个数，加到count里。

    先假设x可以从 [0, n]中取值，那么这段区间至少可以分成(n/y)个完整的、长度为y的区间。
    x = 【0，1……y-2，y-1】【y，y+1，……，2y-2，2y-1】……【……】……【……，n】
    在每个小区间a上，第i个数a[i]%y的余数是i。这样每一小段上大于等于k的x有y-k个（显然当k=0时，y个数都满足题意）。
    【0，1，……，k，k+1，……，y-1】

    需要注意的是，上面x要从0开始算区间长度，所以一定会余下一个区间，比如对于n=5，y=3
    划分后为[0,1,2],[3,4,5] 而5/3=1，则最后的区间没有算进去
    若n=5，y=5
    划分后为[0,1,2,3,4],[5] 5/5=1，最后一个区间还是没算进去。因此，这种方法，至少剩了一个数，至多会把一个整区间（数量为y）都剩下来

    前面区间有n/y个，每个区间中除以y余数大等于k的数字共有y-k个，因此对于任意一个y，前面区间中满足条件的数一共有 n/y* (y-k)个

    但是无论如何，最后这个区间last的第i个数last[i]%y一定是i。则最后一个数（n）的余数就是n%y。
    如此一来，此区间内从 [k,n%y] 包含共计 n%y-k+1 个数。不过如果算出小于0的数，则不需要减回去，直接当没有就可以了。
    所以最后一个区间里包含了 max(n%y-k+1, 0) 个满足条件的x。

    对k=0时单独处理，当k=0时，不论x和y取什么值，都能满足条件，共有n* n个数字
            for(long y=k+1;y<=n;y++){
                long res =  n/y* (y-k) + Math.max(n%y-k+1, 0);
                ans+=res;
            }


》给定一个整数n，计算所有小于或等于n的非负整数中出现的数字1的个数。：233，j43-p221
    0, 1, 2, 3 ... 9 (1)
    10, 11, 12, 13 ... 19 (1) + 10
    20, 21, 22, 23 ... 29 (1)
    ...
    90, 91, 92, 93 ... 99 (1)
    100, 101, 102, 103 ... 109 (10 + 1)
    110, 111, 112, 113 ... 119 (10 + 1) + 10
    120, 121, 122, 123 ... 129 (10 + 1)
    ...
    190, 191, 192, 193 ... 199 (10 + 1)

    1)如果我们不看那些特殊的行（以1X、11X等开头），我们知道每10个数字中有一个1在个位，每100个数字中有10个1在十位，每1000个数字中有100个1在百位，以次类推
    让我们从个位开始并计算有多少个1在这个位置，设k=1，根据上面所说，每10个数字1会出现1次在十位上，所以我们有多少10个数字？
    答案为 (n/k)/10
    现在计算十位，设k=10，每100个数字中有10个1在十位，所以我们有多少100个数字
    答案是 (n/k)/10，所以在十位上的1的个数为 (n/k)/10* k
    设 r=n/k 现在我们有了公式计算k位上的1的个数： r/10* k

    2).我们现在解决特殊行
    使用模运算，举10，11，12为例，假如n是10，则个位中1的个数是 (n/1)/10* 1=1,正确，但计算十位上时，(n/10)/10 * 10=0,错误，因为有1个1在十位上。
    从10到19，我们总是有1在十位上，设 m=n%k,在这个特殊位置上的1的个数是m+1，显然特殊行都是1打头的行
    即：  r/10 * k+(r%10==1?m+1:0)   (r%10==1代表的是若n的最高位就是第k位，且这个最高位是1，那么要额外计算以1开头的这些数，例如，对180，180%100=80,且(180/100)%10==1,因此180中以1开头的3位数共80个，而前面r/10 = 180/100/10 = 0, 因为不够1000个数字)

    3）如果对于20，21，22呢？
    对于20，使用上述公式会得到十位上的1的个数是0，但实际上是10（10到19）,如何修正？我们知道一旦数字大于2，我们应该在十位上的1的个数中加上10，一个聪明的办法是在r上加上8，公式如下：
    (r+8)/10* k + (r%10==1?m+1:0)，循环的条件是n>=k

    举例：加入对于225来说
    个位上1的个数：k=1时，r=225  (225+8)/10=23, 
    十位上1的个数为 k=10时，r=22   (22+8)/10 * 10=30：21X ，11X，1X
    百位上1的个数为 k=100时，r=2， （2+8）/10 * 100 = 100   ：1XX
    共153



》给定两个表示分数的分子和分母的整数，以字符串格式返回分数。如果小数部分是重复的，则将重复部分用括号括起来。：166
    这个题的难点在于怎么判断重复的部分
    还有一个重要的是在考虑这个问题时要考虑所有的边界情况，包括:负整数、可能的溢出等。
    在进行除法时，使用HashMap存储余数及其相关索引，以便每当出现相同的余数时，我们知道存在重复小数部分。

    如对于2/3：商0余2，整数部分为0，开始计算小数部分，设为s，2* 10=20  20/3 = 6，s插入6，20%3=2  2* 10=20 20已经出现过了，其索引为0，所以把括号插入到s中索引为0的地方，即(6 ,再在s末尾添加上 ）因此结果是0.(6)

    ## 整数和小数：
    先处理负数的符号,用异或处理，如果两个数同号，则为正，否则为负
    res.append(((numerator>0)^(denominator>0))?"-":"");
    对于被除数n和除数d，其整数部分是： n/d
    其小数部分如果用一个str存储
    map保存出现过的被除数及其出现的位置，一旦再次出现，说明进入了循环,获取到这个第一次出现循环的位置，然后插入括号，跳出循环
    n = n%d; //这一步保证剩下的都是小数部分，因为是取余，能除成整数的已经没有了
    i=0
    while(n!=0){
        n * = 10;
        if(map.containsKey(n)){
            str.insert(map.get(n), "(");
            str.insert(")")
            break;
        }
        map.put(n, i)
        str += (n/d);
        n %= d;
        i++;
    }
    在小数部分中，当n在之前出现过时，说明进入了循环,则在第一次n出现时的 n/d之前加（，在此时str中加），退出循环，即能实现循环部分括起来



》给定中缀表达式，求表达式的值  ：227
    显然需要把中缀表达式转换成后缀表达式，再使用栈去解决

    中缀-》后缀：这里栈是个暂时存放的地方，最终后缀表达式是输出的东西

    如果是数字则直接输出，如果是操作符，放入栈中：
    -》如果是左括号，直接放入栈中
    -》如果是右括号，则将栈元素弹出，将弹出的操作符输出到遇到左括号为止（左括号只弹出不输出）
    -》如果是其他的操作符（加减乘除），从栈中弹出元素直到栈顶是更低优先级的元素(或者栈为空，或者是括号)为止。弹出完这些元素后，（元素弹出后输出）才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到" ) "的情况下我们才弹出" ( "，其他情况我们都不会弹出" ( "。
    -》如果我们读到了输入的末尾，则将栈中所有元素依次弹出。

    后缀表达式：遍历表达式，直接用栈来计算值：遇到数字放入栈，遇到符号，(次栈顶 符号 栈顶) 然后把结果压栈


》公式字符串求值：c-p276
    给一个字符串str，str表示一个公式，公式里可能有整数、加减乘除和左右括号，返回公式计算结果
    str=48 * ((70-65)-43)+8 * 1 返回-1816
    str=3+1* (-4) 返回-1
    str=3 + (1* 4) 返回7

    显然是先中缀表达式转后缀表达式，然后后缀表达式求值
    如果是数字，直接放在后缀后面，如果是符号，则出栈直到栈顶是左括号或者优先级比自己低，然后把自己压栈；如果是左括号，直接入栈；右括号，出符号直到遇到左括号，把左括号出栈。

    这里需要额外考虑负数的情况，每当遇到数字时，检查它前面是不是负号，如果是，且再前面是左括号，或者再前面就没了，说明这是负数，直接取负，然后把前面的负号出栈

    后缀表达式求值：
    遍历表达式，直接用栈来计算值：遇到数字放入栈，遇到符号，(次栈顶 符号 栈顶) 然后把结果压栈




》给出一组代表闹钟的时间(H:M), 一个分钟数x，及另一个时间AB（A：B） 求出满足在AB的x分钟前的离AB最近的闹钟：b7
    用A和B，及x计算出最晚的起床时间T，再从闹钟中挑一个时间最晚且早于T的时间即为答案
    //把时间单独摘出来做一个类，便于操作（h,m）
    T的计算方法： 
            Time getPreTime(int x){  //计算当前时间的x分钟之前的时间
            int h = hour;
            int m = min - x;
            if(m<0){
                m = 60+m;
                h = h-1;
            }
            if(h<0){
                h = 24 + h;
            }
            return new Time(h, m);
        }
    从闹钟中挑：
        int sub = (T.h* 60+T.m) - (clocks[i].h * 60 + clocks[i].m)
        挑出满足sub>=0的情况下，最小的sub对应的clocks即为答案


》给一个长度为n的数组，里面的元素是从0取到n，（数组长度为n，元素个数为n+1）,找到缺少的那个数：268
    算出0到n的和，再算出数组中的和，一减就是差的那个数


》0到n-1中缺失的数字：j-p266
    一个长度为n-1的递增数组中所有数字是唯一的，并且每个数字都在0到n-1的范围之内，在0到n-1内的n个数字有且只有一个不在该数组中，找到这个数字
    比上一个题多的条件是排序的，若还用上一题的办法，则没有用到排序的条件
    为0到n-1这些数字再数组中是排过序的，因此数组中开始的一些数字和它们的下标相同，也就是说，0在下标为0的位置，1在下标为1的位置，以此类推，如果不在数组中的那个数字记为m，那么所有比m小的数字的下标都与他们的值相同，因此转换成在排序数组中找出第一个值和下标不相等的元素
    仍可利用二分查找,区别代码如下：
        int low = 0;
        int high = array.length - 1;
        int mid = -1;
        while (low <= high) {
            mid = (low + high) >> 1;
            if(array[mid] != mid){ //若索引和值不等时，若该索引为0，或前一个数等于其索引，则返回该索引即为答案，否则high=mid-1
                if(mid==0 || array[mid-1]==mid-1){
                    return mid;
                }else{
                    high = mid-1;
                }
            }else{ //索引值
                low = mid+1;
            }
        }
        return mid; 


》数组中数值和下标相等的元素 j-p267
    假设一个单调递增的数组里每个元素都是整数且是唯一的，实现一个函数，找出数组中任意一个数值等于其下标的元素
    如{-3,-1,1,3,5} 数字3与其下标相等
    遍历的复杂度是O(n)

    由于数组是单调递增的（索引也是单调递增的），因此可以用二分查找算法来优化，如果某一步抵达数组中第i个数字，假设该数字正好是i，则找到了
    如果数字小于其索引i,则说明还在后面，更新low
    如果数字大于其索引i，说明在前面，更新high



》判断一个数是否是3的次方数：326
    注意的是，1是任何数的次方数（0次方）
    public boolean isPowerOfThree(int n) {
        return n > 0 && (n==1 || n/3==0 && isPowerOfThree(n/3));
    }



》计算两个数的和，但是不能用+和-（不用加减乘除做加法）：371，j65-p310
    思路：两个数的加法分为两步，对应位相加和进位。
    我们平时计算时是将对应位相加和进位同时计算，其实可以保留下进位，只计算对应位相加，保留进位的位置（值）。接下来，将进位向左移动一位，将上一步的结果与移位后的进位值进行对应位相加，直到没有进位结束。

    为了好做，则把使用数字的二进制，用以下操作：
    对于二进制数的而言，对应位相加就可以使用异或（xor）操作（对于二进制，不考虑进位的加运算和异或运算是等价的。），计算进位就可以使用与（and）操作，在下一步进行对应位相加前，对进位数使用移位操作（<<）。

    而且由于整数是补码形式存在的，所以正数负数无所谓，加出来还是补码

    假如算13+22
    13二进制：1101
    22：10110

     1101
    10110

    进位数：作与操作：100
    和数：异或操作：11011

    进位数左移一位：1000，与上一步和数再求进位数和和数

    进位数： 1000
    和数：  10011

    进位数左移一位：10000，继续：

    进位数： 10000
    和数：  11

    进位数左移一位 100000 继续：

    进位数： 0
    和数： 100011  

    进位数为0，停止，此时和数为最终结果 100011二进制转为十进制 为 35



》数字根：给定一个非负整数，重复添加它的所有位上的数字，直到结果只有一个数字。：258
    》方法1
    用双层循环，逐个把它们的各位加到一个整数，然后再把该整数转成字符串继续该操作，直到该字符串长度只有1，tO(n^2)，sO(1)

    》方法2
    该问题其实是数字根问题：
    数字根就是这样一种数字：重复添加它的所有位上的数字，直到结果只有一个数字。
    对于以b为基底(十进制情况b = 10)的整数n，其数字根为:
    dr(n) = 0 若n=0 （如果是0，则数字根为0）
    dr(n) = (b-1)如果n != 0且 n % (b-1) == 0（如果是9的倍数，则数字根为9）
    dr(n) = n mod (b-1)如果n % (b-1) != 0 （如果不是9的倍数，则数字根为该数除以9的余数）
    或

    （上述三个公式综合为1个）dr(n) = 1 + (n - 1) % 9

    注意，当n = 0时，因为(n -1) % 9 = -1，所以返回值为0(正确)。

    由公式可知，该问题的结果具有内在的周期性，周期为(b-1)。
    小数输出顺序(b = 10):
    
    ~输入:0 1 2 3 4…
    输出:0 1 2 3 4 5 6 6 7 8 9 1 2 3 4 5 6 8 9 1 2 3

    因此，我们可以编写以下代码，其时间和空间复杂度都是O(1)。
    int addDigits(int num) {
        return 1 + (num - 1) % 9;
    }

    证明过程为：https://blog.csdn.net/ray0354315/article/details/53991199



》给两个字符串表示的整数，求它们的乘积：43

    num1和num2的长度都小于110。
    数字1和数字2都只包含0-9。
    除了数字0本身之外，num1和num2都不包含任何前导零。
    您不能使用任何内置的BigInteger库或直接将输入转换为integer。

    对于一个数a，表示为数组a[] 高位在前低位在后， 如 123 = [1,2,3]
    与数b的乘积为num，起始可以令num为全0数组

    num为乘积数组，是int类型的
    那么 a[i] * b[j] = c， c有两位，高位为c[0],低位为c[1]
    把c[0]加到num[i+j]，c[1]加到num[i+j+1]，当所有a中数字和b中数字乘完之后
    从低位到高位依次遍历num，当某一位大于10时，保留个位数为该位的值，然后往前进一
    这样的结果就是最终的乘积

    其实就是把每一位的竖式乘法再分步


》编写一个程序来检查给定的数字是否是一个丑数。
    丑数是正数，它的质因数只有2,3,5。
    1始终被视为丑数，0不是
    用最简单的办法，逐个除以2、3、5，若最后结果是1，则是丑数，否则不是
    public boolean isUgly(int num) {
        if(num==0) return false;
        while(num%2==0){
            num = num>>1;
        }

        while(num%3==0){
            num /= 3;
        }

        while(num%5==0){
            num/=5;
        }
        return num==1;
    }


》找到第n个丑数，丑数是正数，它的质因数只有2,3,5。1始终被视为丑数：264， j49-p240
    如果直接遍历判断每个数是否是丑数会超时
    
    假设我们现在已经有了一个丑数的有序数组，如果要找到下一个丑数，则可以将数组中的每一个数乘以2，并将其中第一个大于当前丑数的的结果记为M2，同样将当前有序数组每一个数都乘以3，第一个大于当前丑数的的结果记为M3，同样方式得到乘以5的第一个大于当前丑数的结果记为M5。可以下一个丑数必然是min(M2, M3, M5)。


》超级丑数：313
    编写一个程序来找出第n个超级丑数。
    超级丑数是正数，它的所有质因数都在给定的质数列表中，质数列表的大小为k。

    用求第n个丑数的思想：在当前已有的丑数中依次乘以每个因子，取出所有第一个比当前最大丑数大的数，并取其最小值。但不能直接套用，否则会超时，需要改进一下，
    若当前丑数为x，需要保存每个质因子乘以某丑数后比x更大的第一个丑数的索引，相比上面的，就是以空间换时间
    public int nthSuperUglyNumber(int n, int[] primes) {
        int[] ugly = new int[n];
        int[] index = new int[primes.length];
        ugly[0]=1;
        Arrays.fill(index,0);
        int minLarger = Integer.MAX_VALUE;
        for(int i=1;i<n;i++){
            for(int j=0;j<primes.length;j++){
                ugly[i] = Math.min(primes[j] * ugly[index[j]]);
            }
            //对于每个质因数primes[j]，找到与其相乘后第一个比ugly[i]大的那个丑数的索引，由于index[j]存的是与primes[j]相乘后第一个比ugly[i-1]大的丑数的索引，
            //而ugly[i]大于ugly[i-1]，所以现在要找的索引只可能大等于index[j]。只需要在它的基础上递增试验即可,所以index[j]的值是只增不减的
            for(int j=0;j<primes.length;j++){
                while(ugly[i] >= primes[j] * ugly[index[j]]) index[j]++;
            }
        }
        return ugly[n-1];
    }




》计算给定3个数a，b，c，（abc的顺序不变）在它们中间添加"+"， "* "， "("， ")"符号，能够获得的最大值：b13
    有以下几种可能的算法：
    先算ab，在算c ： (a+b)+c  (a+b)* c  (a* b)+c  (a* b) * c
    先算bc，再算a    a+ (b+c) a* (b+c)  a+ (b* c) a* (b* c)


》数字序列中某一位的数字：j44-p225
    数字以0123456789101112131415的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等，写出一个函数，求任意第n位对应的数字
    
    1位的数字共10个，2的位数字共(10-99) 9 * 10=90个,共90* 2位，3位的数字共（100-999）9 * 10 * 10共900个，共900 * 3位，4位的9000个。。。
    若n小于10，直接返回n，否则，n所在的位置的这个数的位数如下算法：（2位的数字，10<=位置<190(10+90* 2), 3位的数字，190<=位置<2890(10+90* 2 + 900 * 3)）
        int k=90;
        int w = 2;
        int count = 10+k* w;
        int pre = 10;
        while(n>=count){
            k * = 10;
            w++;
            pre = count;
            count += k* w;
        }
    得到的w就是n所在的位置的这个数的位数，count是截止到这么大位数的最大位置，pre是之前的位数的最大位置
    i = n-pre 可得到n在从w位数开始算起是第几个，假如是3位数，即从100开始算起，是第几位，如：100101102 第8位是2
    假如就按3位数举例，再看i是从100开始第几个数字中的，i/3表示是第从第一个3位数即100开始第几个数中的(100算第0个数), i%3表示是这个数字中的第几个数
    因此i所在数就是：t = 10^(w-1)+(i/w)  (w位的数字，第0个数是10^(w-1)， 所以第x个数就是在后面加上x)
    然后在t在找到第i%3个数即可：
    s = String.valueOf(t);
    int ans = s.charAt(i%w)-'0';


》给定一个非空整数数组，每个元素出现三次，只有一个元素出现一次。找到那一个。：137，j-p278
    注意:您的算法应该具有线性运行时复杂度。你能在不使用额外内存的情况下实现它吗?
    既要O(n)的时间复杂度，又要O(1)的空间复杂度

    假设输入中没有single number，那么输入中的每个数字都重复出现了数字，也就是说，对这32位中的每一位i而言，所有的输入加起来之后（每一位的和都是独立的10进制数），第i位一定是3的倍数。现在增加了single number，那么对这32位中的每一位做相同的处理，也就是说，逐位把所有的输入加起来，并且看看第i位的和除以3的余数，这个余数就是single numer在第i位的取值。这样就得到了single number在第i位的取值。这等价于一个模拟的二进制，接着只需要把这个模拟的二进制转化为十进制输出即可。
    
    为了完成上面的过程，需要使用一个数组 int a[ 32 ]来模拟位运算。
    可以看出来，这个做法对于功力的要求非常高，需要看到数字的时候，眼前展现的是数字背后的二进制组成，要不然很难想到可以逐位去处理。
    例如，[5，5，5，1]  5的二进制：101  每一个数字转成二进制后，叠加逐个位，但叠加的和是以10进制的形式的，如 3个5逐位叠加后是 303， 1的二进制是001，加上后是304  3%3=0，0%3=0，4%3=1  故唯一的那个数的二进制表示是001

    另外，这个做法可以扩展，如果有一堆输入，其中1个数字出现了1次，剩下的数字出现了K次，这样的问题全部可以使用这样的办法来做。


》你和你的朋友在玩下面的尼姆游戏:桌子上有一堆石头，每次你们轮流移走1到3块石头。谁把最后一块石头搬走谁就是胜利者。你将在第一个回合移走石头。：292
    你们俩都很聪明，在游戏中都有最佳的策略。写一个函数来确定你是否可以赢得游戏给定的石头堆的数量。

    输入:4
    输出:false
    说明:如果堆里有4块石头，你就永远赢不了游戏;无论你移走1块、2块还是3块石头，最后的那些石头永远可以被你的朋友拿走了。
    不能用trackback，其关键在于，两人都很聪明，所以每一步都是要以赢的想法去做的，有些操作不会做，而trackback会导致所有的操作都做，就会产生错误

    定理：若n是4的倍数，第一个得到的数字的人将输掉，否则他/她将获胜。
        若n是4的倍数，那么第二个人始终只拿到4的倍数为止的数字即可获胜：如第一个人拿1，2；则第二个人拿3，4. 第一个人拿1，则第二个人拿2，3，4
        若n不是4的倍数，则第一个人始终只要保证剩下的牌数（注意是牌数）是4的倍数，即可获胜

    证明：
        1. 基本情况：当n = 4时，如问题提示所提示，无论第一个玩家是哪个号码，第二个玩家都将始终能够选择剩余的号码。
        2. 对于1 * 4 < n <2 * 4（n = 5、6、7）
            第一个玩家可以将初始号码减少为4，这会将死亡号码4留给第二个玩家。即数字5、6、7是任何首先获得该数字的玩家的获胜数字。
        3. 现在到下一个周期的开始，n = 8，无论第一个玩家选择哪个号码，它总是将获胜号码（5、6、7）留给第二个玩家。因此，8％4 == 0，再次是死亡数字。
        4. 在第二种情况之后，对于（2 * 4 = 8）和（3 * 4 = 12）之间的数字，即9、10、11，再次成为第一位玩家的获胜数字，因为第一位玩家总是可以减少该数字进入死亡数字8。
    根据上述定理和证明，解决方案再简单不过了：

    public boolean canWinNim(int n) {
        return n%4!=0;
    }


》您正在和您的朋友一起玩以下Bulls and Cows游戏：您写下一个数字，并请您的朋友猜出数字是多少。 ：299
    每次您的朋友进行猜测时，您都会提供一个提示，指示该猜测中有多少位数字与您的秘密号码在数字和位置上都完全匹配（称为“ bulls”），有多少位数字与秘密号码匹配但位于错误的位置 （称为“cows”）。 您的朋友将使用连续的猜测和提示来最终得出秘密号码。
    根据密码和朋友的猜测编写一个函数以返回提示，用A表示bulls，用B表示cows。
    请注意，密码和朋友的猜测都可能包含重复的数字。
    Input: secret = "1807", guess = "7810"
    Output: "1A3B"
    Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.

    Input: secret = "1123", guess = "0111"
    Output: "1A1B"

    先顺序遍历两个串，把相同数字对应的个数都弄出来，放入一个数组a[10]中，然后再把secret中每个数字的个数放入s[10]中，guess个数放入g[10]中
    A就是遍历a中的所有数字之和， 再同时遍历s和g，countB +=  min(s[i]-a[i], g[i]-a[i])。  该题的切入点就是：cows就是secret中有，guess中有，但是位置不对的数字



》n个骰子的点数：j60-p294
    把n个骰子扔到地上，所有骰子朝上的一面的点数和为s，输入n，打印出s所有可能的值出现的概率
    本质是一个概率论问题， 点数和最小为 n* 1； 点数和最大为 n * 6； 二者的概率都是 1/(6^n)

    》方法一：
    骰子所有点数的排列数为6^n，如果基于递归求骰子点数，时间效率会很低
    定义一个长度为6n-n+1的数组，将和为s点数出现的次数保存到数组的第s-n个元素中。

    》方法二：基于循环求骰子点数，时间性能好
    考虑用两个数组来存储骰子点数的每个总数出现的次数。在第一轮循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。下一轮循环中，加上一个新的骰子，
    此时和为n的骰子出现的次数应该等于上一轮循环中骰子点数和为n-1,n-2,n-3,n-4,n-5,n-6的次数的总和，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1,
    n-2,n-3,n-4,n-5,n-6个数字之和
        int[] sum1 = new int[6* n+ 1];
        int[] sum2 = new int[6* n+ 1];
        int cnt = 0;
        //如果是1个骰子，直接计算
        for(int i=1;i<=6;i++){
            sum1[i]=1;
            cnt++;
        }
        boolean isEven = true;
        for(int dieCnt = 2; dieCnt<=n;dieCnt++){ //加入的骰子个数，从第二个开始算
            int[] cur = isEven?sum2:sum1;
            int[] another = cur==sum1?sum2:sum1;
            cnt = 0;
            for(int i=1 * dieCnt;i<=dieCnt * 6; i++){ //和的上限是本次的骰子数 * 6； 下限是骰子数 * 1
                for(int j=1;j<=6;j++){
                    if(i-j<=0) break;
                    cur[i] += another[i-j];
                }
                cnt += cur[i];
            }
            isEven=!isEven;
            Arrays.fill(another, 0); //一定要有这个，把待填充的数组清空，否则会影响到下一次的填充
        }


》扑克牌中的顺子：j61-p298
    从扑克牌中随机抽5张牌，判断是不是一个顺子，即这五张牌是不是连续的，A为1，J为11，Q为12，K为13，大小王可以看成任意数字
    可以先把大小王视为0，然后对抽出的5张牌排序，，然后可以用0去补满数组中的空缺，如果相邻的两个数字相隔若干个数字，只要我们有足够的0补满这两个数字间的空缺，那么这个数组实际上还是连续的。 
    于是需要做3件事：首先把数组排序；其次统计数组中0的个数；最后统计排序之后相邻数字之间的空缺总数。如果空缺总数小于等于0的个数，那么数组就是连续的，否则不连续


》求1+2+3+...+n：j64-p307
    求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

    java创建数组的时候只会分配内存而不会调用数组对象的构造函数，只有当真正new对象的时候才会调用构造器（而C++不同，只要创建数组就会真正去构造对象填充数组，因此只需构造n个对象，利用静态变量记录个数即可）
    除了逻辑跳转，java中0不是false，剩下能实现跳转的，就是异常，只要在抵达边界条件时构造出一个异常，转入异常处理的代码，就实现了跳转
    public int Sum_Solution(int n) {
        return sum(n);
    }
    int sum(int n){
        try{
            int i = 1/n;
            return n+sum(n-1);
        }catch(Exception e){
            return 0;
        }
    }


》4的幂次：342
    给定一个整数(有符号的32位)，写一个函数来检查它是否是4的幂。能否不使用递归或循环判断？

    》方法一：
        递归或循环很简单，一直在保证余数为0的情况下除以4若最后能等于1则为4的幂。负数一定不是幂次

    》方法二：
        数学方法：
        很容易发现4的幂有这3个共同的特征。首先,大于0。其次，二进制符号中只有一个1位，所以我们用x&(x-1)来删除最低的1位，如果它变成0，就证明只有一个1位。第三，唯一的“1”位应该位于奇数位置，例如16。二进制是00010000。因此，我们可以使用'0x55555555'来检查'1'位是否在正确的位置。有了这个想法，我们可以很容易地把它写出来!
        0x5的二进制： 0101 即只在奇数位有1，偶数位为0，将0x55555555与该数做与，若该数的1在奇数位，则结果不是0。

        一行语句搞定：return num>0 && ((num&(num-1))==0) && ((num & 0x55555555)!=0);  


》今年的第几天。输入年、月、日，计算该天是本年的第几天。：b34
    闰年：
    1.是4的倍数且不是100的倍数
    2.是400的倍数
    剩下的只需要把该月之前的月份天数全加上，再加上当前是本月的多少号即可




```


#几何问题
```
》求二维平面上两个矩形（矩形一定是长与x轴平行，宽与y轴平行）所覆盖的总面积。：223
    总面积=两个矩形面积-重合面积
    不重合的条件：top1<bottom2 || top2<bottom1 || left1>right2 || left2>right1 （定死矩形1的位置，拿矩形2与它做交集来得出不相交的条件）


》给定二维平面上的n个点，求同一直线上的点的最大数目。：149

    对于一个点p0，如果p1，p2与它在同一直线上，则y1-y0/x1-x0  == y2-y0/x2-x0
    所以左侧上下都除以上下的最大公约数后为 y/x，右侧上下都除以上下的最大公约数后也必为y/x
    这样以这个x,y作为key存储在这条直线上的点数

    用Map<Integer,Map<Integer,Integer>> map = new HashMap<Integer,Map<Integer,Integer>>();记录x-y对应下的
    （这个Map套Map十分关键, 适用于有两个关键字存值的情景，比如这里的关键字就是一个斜率的分子分母，二者共同确定一个斜率）
    result=0
    for(i){
        map.clear()
        max=0;
        overlap=0
        for(j){
            xx = points[j].x-points[i].x;
            yy = points[j].y-points[i].y;
            if(xx==0&&yy==0){
                //points[i]与points[j]重合，不论哪条直线，两者一定在同一直线(因为就是一个点)
                overlap++;
                continue;
            }
            gcd = getGCD(xx,yy)找到xx和yy的最大公约数
            x = xx/gcd, y=yy/gcd
            将 map.get(x).get(y)的值加1，意味着该斜率下，又有一个点与points[i]在一条直线上
            max = Max(max, map.get(x).get(y)); //记录当前与points[i]在同一条直线上的最多的点数
        }
        result = Max(result, max+overlap+1) 
        //对于每个点points[i]来说，都要计算与其在同一直线上的最多点数+自己本身+与自己重合的点，其中的最大值即为所求
    }



》矩形重叠：平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。：b6
如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。
    注意的是，是最多的地方有几个矩形重叠，而不是最多有几个矩形重叠！
    比如像奥迪的标志，最多有3个矩形重叠，中间的和两边的重叠，但一个地方最多只有2个矩形重叠！

    这里列举的不光是所有现有矩形的左下角，而是考虑了所有左下角横和左下角纵的组合
    因为无论何种情况，重叠区域也是四条边组成。
    而且是取自于这n个矩形中的某四条边，而且重叠区域矩形的左下角一定是某个矩形的下边和某个矩形的左边相交而成的。这两个矩形可能相同可能不同
    因此遍历所有矩形之间下边和左边能形成的交点，并看该交点在几个矩形中，因为该交点是重叠区域矩形的左下角点，对于一个矩形，

    若 矩形左边界<=该点横坐标< 矩形右边界 且 矩形下边界<=该点纵坐标< 矩形上边界 则该矩形和该重叠区域有交集
    对于边界条件的解释：
        如果交点在该矩形的下边或左边上，该交点算作在该矩形中
        若该交点在该矩形的上边或右边上，则不算在该矩形中，这是当然的，因为该交点是重叠矩形的左下角。



》阶乘中的0：要求n!末尾有多少个0，：172
    对于任意一个数m，它可以被写成：m=2^x * 5^y * (...其他部分)

    0只能是m中的2和5相乘得到的，而在1到m（m任意）这个范围内，2的个数要远多于5的个数，
    所以这里只需计算从1到n!这个范围内有多少个5就可以了。即上面y的个数


    考虑n!的质数因子。后缀0总是由质因子2和质因子5相乘得来的，如果我们可以计数2和5的个数，问题就解决了。
    //考虑例子：n = 5时，5!的质因子中(2 * 2 * 2 * 3 * 5)包含一个5和三个2。因而后缀0的个数是1。
    //n = 11时，11!的质因子中((2 ^ 8) * (3 ^ 4) * (5 ^ 2) * 7)包含两个5和八个2。于是后缀0的个数就是2。
    //我们很容易观察到质因子中2的个数总是大于等于5的个数,因此只要计数5的个数即可。
    //那么怎样计算n!的质因子中所有5的个数呢？一个简单的方法是计算floor(n / 5)。例如，7!有一个5，10!有两个5。
    //除此之外，还有一件事情要考虑。诸如25，125之类的数字有不止一个5。
    //例如n=25, n!=25*24*23*...*15...*10...*5...*1=(5*5)*24*23*...*(5*3)*...(5*2)*...(5*1)*...*1，其中25可看成5*5,多了一个5，应该加上
    //处理这个问题也很简单，首先对n/5，移除所有的单个5，然后/25，移除额外的5，以此类推。下面是归纳出的计算后缀0的公式。
    //n!后缀0的个数 = n!质因子中5的个数= floor(n / 5) + floor(n / 25) + floor(n / 125) + ....
    //例如对于30，单个的5有：30、25、20、15、10、5。其中25多个5，因此共7个5
    即如下代码：第一遍是求n/5 第二遍是求n/5/5即n/25...
        int result = 0;
        while(n>0){
            n /= 5;
            result += n;
        }



》城市天际线：218
    城市的天际线是城市中所有建筑从远处看形成轮廓的外部轮廓。现在，假设您得到了城市景观照片(图a)中所示的所有建筑物的位置和高度，编写一个程序来输出这些建筑物共同形成的天际线(图B)。

    每个建筑的几何信息由一个整数三联体[Li, Ri, Hi]表示，其中Li和Ri分别为第i个建筑左右边缘的x坐标，Hi为其高度。保证0≤Li, Ri≤INT_MAX, 0 < Hi≤INT_MAX, Ri - Li > 0。你可以假设所有的建筑都是完美的矩形，在高度为0的平面上。

    例如，图A中所有建筑物的尺寸记录为:[[2 9 10]，[3 7 15]，[5 12 12]，[15 20 10]，[19 24 8]]。

    输出为[[x1,y1]， [x2, y2]， [x3, y3]，…这是天际线的独特定义。关键点是水平线段的左端点。请注意，最后一个关键点，也就是最右边的建筑结束的地方，只是用来标记天际线的结束，并且总是没有高度。此外，任何两座相邻建筑之间的地面都应被视为天际线的一部分。

    例如，图B中的skyline应该表示为:[[2 10]，[3 15]，[7 12]，[12 0]，[15 10]，[20 8]，[24,0]]。
    注:

    任何输入列表中的建筑物数量都保证在[0,10000]范围内。
    输入列表已经按左x位置Li的升序排序。
    输出列表必须按x位置排序。
    输出天际线中不能有等高的连续水平线。例如,[…[2 3]，[4 5]，[7 5]，[11 5]，[12 7]…是不可接受的;在最终的输出中，高度5的三行应该合并为一行，如下所示:[…[2 3]，[4 5]，[12 7]，…]

    》解题方法：
    从左往右扫描，当遇到矩形边时，假设其横坐标为x，找到该x上最高的那一个点，如果最高点和前面的高度一样，则不记录，否则记录
    为了不漏掉高度为1的点

    把l和r都存入一个数组中，并且将其排序，结果为list。即list中为所有矩形的左右边界，且其排好了序
    遍历list，若当前为x，求出x对应的最高高度hh（遍历所有的建筑物，满足x>=l 且 x< r的最大h, 如果没有建筑物满足当前x，则x对应的最高高度为0）
    把[x,hh]加入结果集

    遍历结果集，如果连续多个同高，则只保留最前面的一个。如 [3,10], [6,10], [11, 10] 只保留[3,10]



》有n个点组，每个点组包含4个点的横纵坐标，对于一个组中的某个点(ai,bi)，都有一个它对应的中心坐标(xi,yi)，每次可以让该点围绕它的中心点逆时针旋转90度，旋转一次将耗费一次移动次数，当一个点组中的四个点能构成一个面积不为0的正方形，则说该点组是紧凑的，计算每个点组需要几步移动才能使它变得紧凑，如果不能则返回-1：b12

    ## 笛卡尔坐标系内点旋转公式：
    (a,b)为旋转中心，（x,y）为旋转初始点，(x',y')为旋转目标点

    θ 是逆时针的旋转角
    x' = xcosθ  - ysinθ  + a(1-cosθ ) + bsinθ 
    y' = xsinθ  + ycosθ  + a(-sinθ ) + b(1-cosθ) 

    当θ = 90°时
    x' =  -y + a + b
    y' = x -a + b

    对每一组点，能构成的排列组合形式有 4* 4* 4* 4共256种可能性，可以直接枚举。

    ## 如何判断四个点能否构成正方形
        判断方法如下：
        若有3个点的x相等或3个点的y相等，直接为false
        选定1个点p1, 则其余3个点分别为：p2,p3,p4
        始终以p1作为要判断的角的顶点，则有如下几种可能：
            p1与p2对角，p1p3 = p1p4=p2p3=p2p4，且p3p1p4为直角
            p1与p3对角，p1p2 = p1p4=p3p2=p3p4，且p2p1p4为直角
            p1与p4对角，p1p2 = p1p3=p4p2=p4p3，且p2p1p3为直角

    1.距离：
    两个点(x,y), (x',y')之间的距离为sqrt((x-x')^2+(y-y')^2)
    仅做相等判断的话，则可不用根号，直接用根号内的公司判断即可

    2.角度
    判断三点连续构成的角是否为直角，第一个点参数为顶点：(两直线垂直，则其斜率互为负倒数)
    bool IsRightAngle(int x1,int y1,int x2,int y2,int x3,int y3){
        if((x2-x1)* (x3-x1)+(y2-y1)* (y3-y1)==0)
            return true;
        return false;
    }


》已知iPhone屏幕的高为H，宽为W，若字体大小为S(假设为方形），则一行可放W / S(取整数部分）个文字，一屏最多可放H / S （取整数部分）行文字。：b24
    已知一篇paper有N个段落，每个段落的文字数目由a1, a2, a3,...., an表示，月神希望排版的页数不多于P页（一屏显示一页），那么最大可使用多大的字体呢？
    注意这里的段落，因为有段落的存在，所以不能直接用所有的字符数的和，因为段落可能会造成结尾句的空白字符，这也是要算进去的。

    如果不考虑分段的话：
    设一页能显示的文字是 (w/s) * (h/s) = m 个  ， 最终的页数为x，则  x <= p ,   m * x >= (Σai)
    得   (Σai)/m <=x<= P  因此求能满足P大等于(Σai)/m 的最大的s，移项得：
    ((Σai)/p) <= (w/s) * (h/s)，因此就是求最大的s使得不等式成立
    这样能得出s的大概范围： s = (int) Math.sqrt(w*h*p/sum), 

    但是由于分段的存在，真实字体可能比该值大，也可能比该值小，因此就要以该值为中心计算真正能满足条件的s

    假设当前字号s已确定，如何计算该文章需要的总行数？
    totalLines = Σ(Math.ceil(a[i]/(w/s))) 为该片文章总共所需的行数
    而总页数最大为p，每一页至多能有h/s行，所以行数的上限值为 maxLines = p * （h/s）
    如果字号s有效，则必须满足 totalLines <= maxLines

    如果s满足，则再验证s+1是否满足，若满足再验证s+2是否满足。。。
    如果s不满足，则验证s-1是否满足，不满足再验证s-2是否满足。。。

    这样，不满足时上一个满足的值就是答案。

    例如，从27开始试，27不满足，试26，26满足，设置一个boolean类型，再试27，27不满足，但上一个（26）满足，则答案是26


》一开始有n个灯泡是关着的。第一轮，你先把所有的灯泡都打开。第二轮，将灯泡分为两个为一组，关掉每组的第2个灯泡。在第三轮中，每三个灯泡为一组，你要切换每组的第三个灯泡(    如果是关着的就打开，如果是开着的就关闭)。在第i轮，让灯泡每i个为一组，切换每组的第i个灯泡。在第n轮，你只切换最后一个灯泡。求n轮之后有多少灯泡是亮着的。：319

    灯泡相当于一开始全是灭的，当它切换奇数次时，它就是亮的。
    灯泡i在第d轮切换状态，当且仅当d可以整除i时，因此当且仅当i有奇数个因数时，灯泡i才会亮

    因数是成对出现的，比如i=12时，有1和12，2和6，3和4。除非i是平方数，比如36，有1和36，2和18，3和12，4和9，以及一个单独的6。
    因此当且仅当i是平方数时，灯泡i才会亮着。所以只需要计算1到n之间的平方数的个数即可
    让r = int(sqrt(n)), 即r是1到n之间的最大的平方根，而1是最小的平方根。1到n之间的平方数只能是：1^2, 2^2 .... r^2，共有r个数
    因此该题的答案就是sqrt(n)


》你得到一个n个正数的x数组。从点(0,0)开始，向北移动x[0]
米，向西移动x[1]米，向南移动x[2]米，向东移动x[3]米，以此类推。换句话说，每移动一次，你的方向就会逆时针改变。：335
    编写一个带有O(1)额外空间的单遍算法来确定路径是否与自身相交。

    可以每次以步长1往前走坐标，每过一个坐标，把它加入到set中，当遇到已经访问过的坐标，就是相交了，这样的空间复杂度是O(n)（居然内存使用超过了100%...），时间复杂度是O(n)



```


## 约数个数定理（因数个数定理）：
对于一个大于1正整数n可以分解质因数 n=p1^a1 * p2^a2 ... * pk^ak

则n的正约数个数就是 f(n) = (a1+1)* (a2+1)... * (ak+1)
其中a1,a2...ak 是p1，p2...pk的指数

## 1...n 之间的完全平方数的个数为 sqrt(n),（证明见319）


##不使用新的变量，交换两个变量的值：
基于加减法：
    a = a+b;
    b = a-b;
    a = a-b;

基于位运算：
    a = a^b;
    b = a^b;
    a = a^b;


## 任何数和0(全0)异或都是它自身；任何数和全1异或就相当于各个位取反

## 对于 x和y，若二者符号相同时，取模就是取余 mod == %；二者符号不同时，x % y 取余运算，结果符号和x符号一样；x mod y ，取模运算，结果和y符号一样

下面都讨论符号一样的情况，取模就是取余

## 若计算一个结果的取模，若该结果是多个数字累加形成的，则可以对所有累加的部分全部取模后再累加，再将最终累加的结果取模，结果和先累加再取模是一样的。
即 c = （a1+a2+a3+...+an）
c % x = (a1%x +a2%x +... an%x) % x
也可以是其中任意多项的和求余后相加再求余: c % x = ((a1+a2+a3) % x + (a4+...an) % x) % x
总之，只要分离，分离的每一项都要求余，且阶段性和也要求余


## 笛卡尔坐标系内点旋转公式：
(a,b)为旋转中心，（x,y）为旋转初始点，(x',y')为旋转目标点

θ 是逆时针的旋转角
x' = xcosθ  - ysinθ  + a(1-cosθ ) + bsinθ 
y' = xsinθ  + ycosθ  + a(-sinθ ) + b(1-cosθ) 

当θ = 90°时
x' =  -y + a + b
y' = x -a + b

对每一组点，能构成的排列组合形式有 4* 4* 4* 4共256种可能性，可以直接枚举。

## 如何判断四个点能否构成正方形
    判断方法如下：
    若有3个点的x相等或3个点的y相等，直接为false
    选定1个点p1, 则其余3个点分别为：p2,p3,p4
    始终以p1作为要判断的角的顶点，则有如下几种可能：
        p1与p2对角，p1p3 = p1p4=p2p3=p2p4，且p3p1p4为直角
        p1与p3对角，p1p2 = p1p4=p3p2=p3p4，且p2p1p4为直角
        p1与p4对角，p1p2 = p1p3=p4p2=p4p3，且p2p1p3为直角

1.距离：
两个点(x,y), (x',y')之间的距离为sqrt((x-x')^2+(y-y')^2)
仅做相等判断的话，则可不用根号，直接用根号内的公司判断即可

2.角度
判断三点连续构成的角是否为直角，第一个点参数为顶点：
bool IsRightAngle(int x1,int y1,int x2,int y2,int x3,int y3){
    if((x2-x1)* (x3-x1)+(y2-y1)* (y3-y1)==0)
        return true;
    return false;
}



#转换问题
```
》对于一些转换后可能出错（如溢出等）用try-catch来捕获异常并返回默认值，可以处理那种有可能出现错误但有错误时默认值的情况

一开始会很庞大，要按不同情况分步讨论就会容易一些

对于数字转换的问题（像字符串转数字），一定要考虑到溢出，即是否超过上下限：8

》数字转罗马字：最好一开始就把罗马字放入数组中相应位置中，计算时能充分利用下标：12
如：
        String[] KILO = new String[]{"", "M", "MM","MMM"};
        String[] HUND = new String[]{"", "C", "CC","CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
        String[] DECA = new String[]{"", "X", "XX","XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
        String[] UNIT = new String[]{"", "I", "II","III", "IV", "V", "VI", "VII", "VIII", "IX"};
        对于一个数字，只需要分别计算出千位，百位，十位，个位对应的数字，再找出相应数字对应的罗马字组合即可


》罗马字转数字：也要借助上面的数组（转换的问题，如果能找出数组字典，是最好不过的）：13
    把罗马字从前往后搜寻，逐个找到符合的前缀，并将该前缀转换成数字，最终加和。如 XLVI，从长到短去对照表中找，如上面前缀最长是4位，则一开始搜寻长度为4
    即XLVI，找不到该前缀，搜3个，即XLV，也找不到，搜2个，即XL，找到了，那么把它转换为数字，剩下的都是这个过程。

    这个题的关键在于找出合适的转换方式，即由长到短由大到小将罗马字拆解成每一位上的数字，这是因为它不是前缀编码，即X是XL的前缀，但X,XL是两个不同的符号，所以由长到短由大到小是处理办法。


》用A表示1列，B表示2列.。。。Z表示26列，AA表示27列，AB表示28列.。。。以次类推，
    》编写一个函数，输入用字母表示的列号编码，输出它是第几列： j-p99，171
        将A...Z看成26进制，直接10进制转26进制即可
        比如BAZ = B * 26^2 + A * 26 + Z  (再把字母换成对应的数字)

    》编写一个函数，输入用数字表示的列号，输出它的字母表示的编码：168
        看成10进制转26进制，但区别在于，由于这里26进制的符号表中没有代表0的符号（最小是A，表示1），所以要做特殊处理
        public String convertToTitle(int n) {
            final String[] symbol = {"Z", "A","B","C","D","E","F","G","H","I","J","K",
                "L","M","N","O","P","Q","R","S","T","U","V","W","X","Y"};
            StringBuilder builder = new StringBuilder();
            while(n>0){
                int cur = n%26;
                builder.insert(0, symbol[cur]);

                n /= 26;

            //这一步及其重要，其意义在于，如果当前n是26的倍数，再除以26的时候会多算一遍，所以要减去
            //如52对应 AZ，当52%26=0，而52/26=2 这个2其实应该是1，因为这里的进制没有代表0的符号（如0，10，20这种数），所以要减去进位时多算的一个
            //53对应 BA 53%26=1 53/26=2 由于不是26的倍数，所以就不用减1
                if(cur==0)
                    n--;
            }
            return builder.toString();
        }


》输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。：j15-p100， 191，338
    》方法一：
        数字不断无符号右移1位，然后和1做与，如果得1，则证明当前最后一位是1，累加，直到右移到该数字为0
        还可以不动数字，动1，如数字先和1做与，然后把1左移1位和数字做与，然后再左移一位。。
    
    》方法二：
        把数字减去1，那么其二进制最右端的1会变成0，然后这个1再往右的所有0会全部变成1
        然后再喝原整数做与运算，会把该整数最右边的1变成0，那么一个整数的二进制中有多少个1，就可以进行多少次这样的操作

    》方法三：
        # 对于任何一个数，只要它乘以2，就相当于它整体左移一位，右边补0，所以对于任何偶数x，1的个数=（x/2）的1的个数
        # 对于奇数，它 = 比它小一的偶数 + 1，而比它小一的偶数最低位一定是0，所以对于任何奇数x，1的个数 = (x-1)的1的个数 + 1

    # 又由这道题可知，偶数的二进制最低位一定是0，奇数二进制最低位一定是1(奇数等于比它小的偶数+1)



》用一条语句判断一个整数是不是2的整数次方。 ：j-p103，231
    2的次方有且只有1个1，对于某个数x，x-1后二进制会使最右边的1变成0，再往右的0全变成1，与x做与运算，结果是x二进制中最右边的1变成0，其余位均不变
    如：10100(2)， 减一后变成 10011(2)，做与后变成 10000
    因为2的次方有且只有1个1，所以这么做完后，如果变成0，说明里面只有一个1；即是2的次方数，否则不是
    要注意的是非正数一定不是次方数


》输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n： j-p103
    两个数求异或，则他们二进制中一样的位就会变成0，不一样的就会变成1，因此可以先求这两个数的异或，然后统计异或结果中1的位数    


》载有字母A- Z的讯息正使用以下映射编码成数字：91，c-p225
    A - > 1
    “B”- > 2
    ...
    “Z”- > 26
    给定一个只包含数字的非空字符串，确定解码它的方法的总数。 如226的答案为3，因为可被解码为 "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6)
    》如果使用递归
    当扫描到一个数字，有两种办法，一种是只取它，一种是取它和它后面的数字组合（前提是不超过26）但这种做法会超时

    》考虑动态规划
        令dp[i]为str[0...i]转成的最大个数
        dp[0]=(str[0]>=1 && str[0]<=9) ? 1:0
        如果dp[0]=0，则整体一定转换不成功
        若str[i]==0
            若str[i-1, i]满足条件，dp[i]=dp[i-2]
        否则：
            dp[i] = 0 //初始化
            若str[i]满足条件 ：dp[i] += dp[i-1]
            若str[i-1, i]满足条件，dp[i] += dp[i-2]

        判断str是否满足条件的函数：
        //注意如果出现前导0，一定不满足
        public boolean isValid(String s){
            try{
                int t = 0;
                for(int i=0;i<s.length();i++){
                    //如果出现前导0，则一定不成立
                    if(t==0 && s.charAt(i)=='0') return false;
                    t = t*10 + s.charAt(i) - '0';
                }
                return (t<=26 && t>=1);
            }catch(Exception e){
                return false;
            }
        }



》把一个整数的二进制翻转，变成一个新的整数：190
    Integer.toBinaryString(int n)用于把一个整数转换成其二进制表示的字符串，但会删去前面的0：比如 0001，会直接转成 1
    stringBuilder.reverse()  翻转字符串(builder)
    因为新的整数必须为32位，但由于上面转换的时候删去了头上的0，所以此时应该要在后面补，要提前补好再转换
    如，若整数为6位：n: 00110  转成二进制时会把前面的0去掉，转换后是 11（即011），因此需要在后面补全0，即 1100
    然后再把1100转成整数即可


》计算小于n的素数的个数：204
    使用素数筛法：使用一个数组来标志若为素数，则flag[i]=false否则为true，当遍历到一个数x是素数时，即flag[i]=false，循环将 2x，3x...n全部标记为非素数，即将flag[2x] flag[3x]。。。全部标记为true


》将非负整数转换为其英文单词表示形式。给定的输入保证小于2^31 - 1。：273
    2^31-1: 2 147 483 647  ：最大的就是billion，  billion，million，thousand，把它们记为 “分位号”
    英文数字都是3个3个一组来看的
    把数字分成三个三个一组，例如对于abc，每个组的读法都是： a hundred (b==1 则连着后面的c一起念，b==0，则不念，b>1则念成相应的 xxx ty) c + 相应分位号
    需要注意的有以下几点：
        1.要是输入0直接返回Zero
        2.在一组数字（3位）中，遇到0就直接看下一位
        3.如果一组数字全是0，则该组不输出任何字符串


》把数字翻译成字符串 j46-p231
    给定一个数字，按照如下规则把它翻译成字符串：0翻译成a，1翻译成b。。。。 11翻译成l，25翻译成z，一个数字可能有多种翻译
    例如，12258有5种不同的翻译，分别是 bccfi,bwfi,bczi,mcfi,mzi 实现一个函数，用来计算一个数字有多少只不同的翻译方法

    》方法一：
        显然用带start的trackback即可(深度优先遍历),每次遍历，因为一个字母最大只有两位数，所以遍历sub(start, start+1) 和 sub(start, start+2)即可，若
        s[start]是0，则不需要遍历后者（不用看以0开头的两位数）

    》方法二：
    使用题目91中的动态规划是更好的方法  
        dp[i]是截止到第i个数字的翻译方法数
        若第i个数字是0，则dp[i] = dp[i-2]
        若第i个数字不是0，若sub(i-2,i)是合理的数字，则dp[i] = dp[i-1]+dp[i-2]
                        若不是合理数字，则dp[i] = dp[i-1]



》把字符串转换成整数：j67-p318
    题目描述
    将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0

    该题主考的就是边界条件
    1.字符串为空或长度为0时，返回0；
    2.如果首字符是+或-，遍历从第1个开始，否则从第0个开始
    int sum
    遍历：
        如果当前字符不在 '0'到'9'之间，返回0
        boolean min_ready = false; //设置是否已到达边界
        int pre = 0;
        如果sum==Integer.MIN_VALUE/10
            min_ready=true
            pre = sum
        sum = sum * 10 - (c-'0'); //用减法，因为负数范围大于正数
        //抵达最小值，并且新和比旧和大（因为一直是减法，所以新和应该小于旧和）,则溢出了
        if(min_ready && sum >= pre){
            //溢出
            return 0;
        }

    如果是负数，返回sum
    如果是正数，如果0-sum小于0，则返回0（正数溢出）
              否则返回sum


》36进制加法：b35
    36进制由0-9，a-z，共36个字符表示，最小为'0'
    '0'~'9'对应十进制的0~9，'a'~'z'对应十进制的10~35
    例如：'1b' 换算成10进制等于 1 * 36^1 + 11 * 36^0 = 36 + 11 = 47
    要求按照加法规则计算出任意两个36进制正整数的和
    如：按照加法规则，计算'1b' + '2x' = '48'
    要求：不允许把36进制数字整体转为10进制数字，计算出10进制数字的相加结果再转回为36进制

    说的是不允许整体转，那就一位一位转着加




```

## 两数做加法进位只能进1！！！（不论是几进制，两数做加法只能进位1，但3个及以上就不一定了，可能进位更多）

## 余数只能小于除数（要是大等于，则商就可以加1了）

## 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1变成0，很多二进制问题都可以用这种思路解决


## 判断两个double或者float数相等时不能用 == ，因为在计算机内表示小数时都有误差。判断两个小数是否相等，只能判断它们的差的绝对值是不是在一个很小的范围内，如果两个数差很小，就可以认为它们相等
```java
boolean Equal(double a, double b){
    if((a-b>-0.0000001) && (a-b<0.0000001))
        return true;
    else
        return false;
}

```


## 进制转换
》x进制转10进制，这里假设x进制下的数字以字符串表示
```java
int sum=0
for (int i=0; i<s.length(); i++) {
    s.charAt(i)对应的符号在10进制中的值是 value[i];
    sum *= x;
    sum += value[i];
}
return sum;
```

》10进制转x进制
```java
while(t>0){
    k=t%x;  //把k换成x进制下表示k这个数的符号，即为该位 
    t=t/x;
    //这里要注意，如果x进制的符号表中没有表示0的符号，要做点特殊处理,如leetcode 168
}  

//如 78转16进制， 78%16=14, 14在16进制中符号是E, 78/16=4  4%16=4，4在16进制下符号是4， 4/16=0  所以78在16进制下是 0x4E 
```

## 顺时针旋转矩阵90度可分为两步(这里说的都是方阵，坐标原点为矩阵中心点)：
    1.将矩阵中关于主对角线对称的元素交换(关于y=-x做轴对称)，即 num[i][j] swap num[j][i]
    2.交换后的矩阵，每一行都做镜面交换：即：num[i][j] swap num[i][n-1-j]
    即可完成旋转。

    在矩阵中，做y=-x对称 ：num[i][j] swap num[j][i]    ： 横纵坐标交叉相等
        做关于y轴对称：num[i][j] swap num[i][n-1-j]  ：横坐标相等，纵坐标和为n-1 （每一行都做镜面交换）
        做关于x轴对称：num[i][j] swap num[n-1-i][j]   ：横坐标和为n-1，纵坐标相等（每一列都做镜面交换）
        做y=x对称：   num[i][j] swap num[n-1-j][n-1-i] ：横纵坐标交叉和为n-1


#字符表盘and棋盘and矩阵and多维数组问题
```
》锯齿形(Zigzag)转换：6
    用一个方向变量来控制走的方向。字母走势都是从头到底，再从底到头这样，看成是电梯，那么只需要建n个字符串，每个字符串代表一层，每当到一层时，把该层的字母加入该层的字符串，最后把所有字符串连起来就可以了


》二维数组中查找某个值，从上到下和从左到右都是顺序，查找某个值： j4-1, 240，74
    从右上角开始，若大则左移，若小则下移，不移时：找到了或没法再移了。同理从左下角开始，大则上移，小则右移，同样可以解决  


》图像旋转，给一个n*n二维数组当一副图像，将其顺时针旋转90度： 48

    注意，作为图像的坐标轴都是以矩阵中心为原点，而矩阵中的元素坐标都是以左上角为0，0点

    顺时针旋转矩阵90度可分为两步：
    1.将矩阵中关于主对角线对称的元素交换(关于y=-x做轴对称)，即 num[i][j] swap num[j][i]
    2.交换后的矩阵，每一行都做镜面交换：即：num[i][j] swap num[i][n-1-j]
    即可完成旋转。

    在矩阵中，做y=-x对称 ：num[i][j] swap num[j][i]    ： 横纵坐标交叉相等
        做关于y轴对称：num[i][j] swap num[i][n-1-j]  ：横坐标相等，纵坐标和为n-1
        做关于x轴对称：num[i][j] swap num[n-1-i][j]   ：横坐标和为n-1，纵坐标相等
        做y=x对称：   num[i][j] swap num[n-1-j][n-1-i] ：横纵坐标交叉和为n-1

》给定一个2D板和一个单词，找出这个单词是否存在于网格中。：79，j70
    单词可以由顺序相邻的单元格组成，其中“相邻”单元格是水平或垂直相邻的单元格。同一单元格不可使用超过一次。
    >这个题是有顺序的，不用双Map法，可以直接用回溯，将目标单词中字母顺序与遍历序列中的字母匹配，符合就继续匹配该字母周围的字母与单词的下一个字母。否则就退出。这里最好用递归的trackback(dfs)，当遍历完一个位置时，将其标记为已看，然后继续dfs它的周围8个方向的位置，当把它周围的元素后续全部遍历完后，要将其标记为未看，因为它在一个顺序中不满足不代表在另一个顺序中也不满足。
    这里的难点就在于标定已经看过的元素，4个方向的dfs递归，以及遍历过后标为未查看



》给定一个包含0和1的二维二进制矩阵，找出只包含1的最大矩形并返回其面积。：c-p26， 85

        》方法一：c-p26（该方法比方法二要好，方法二有点不好理解，以该方法为准）
            按行遍历，每遍历到一个1的位置时，往它上面看以它为底的这列最多能有多高，然后再向它的两边扩展，看每一个相邻的1所在列的高度能不能达到它的高度，每扩展一个1，计算当前矩形能达到的最大面积，取其中最大的，就是包含该位置的1的矩形能达到的最大面积，遍历所有位置，取其中的最大值作为答案.

            preHeight[] 表示上一行的元素对应列的最大高度

            以当前元素为中心，先向左扩展，计算出以当前列为右边界的矩形的最大面积，计算出左边的最小高度，
            再向右扩展，计算出以当前列为左边界的矩形的最大面积，计算出右边的最小高度，
            再计算出仅有一列的矩形的面积（最高瘦的矩形）
            再计算出宽度最大，高度为左右中的小值的矩形面积（最矮胖的矩形）
            这四个值中的最大值即为当前元素所在所有矩形中最大的。

            遍历所有元素并计算其对应的最大矩形，取其中最大的那个作为答案


        》方法二：85
            用动态规划，DP解决方案从第一行开始逐行进行。 令第i行和第j列的最大矩形区域由[right（i，j） -  left（i，j）+ 1] * height（i，j）计算。
            # 这个算的是这样一个矩形的面积：以元素i所在的行为底边行，且元素i在该矩形之中，且它是元素i当前所在的矩形之中最高的。

            这里不要用下面的方法：
            扫描到元素num[i-1][j]，找以它为左上角/右下角的矩形，诸如此类的以该元素为角点找矩形做法，
            因为如果作为角点，宽和高的选择不好协调, 这样可能会漏情况，如：

            100000
            111111 

            如果优先高度的话，那么maxarea=2（但其实应该等于6），这里因为[1][0]的元素优先到了高度为2，宽度为1的矩形；错过了高为1，宽为6的矩形

            10
            10
            11 

            如果优先宽度的话，maxarea=2（但其实应该等于3），理由类似

            ## 出现这种情况的原因是把当前遍历到的元素视为了角点，而如果不把元素视作角点，而仅仅是是找它所在的最高的矩形，那么它漏掉的情况会由扫描到其他元素的情况补上，

            如，继续用高度优先
            100000
            111111
            对[0][0],area=1，对[1][0]，area=2(因为是高度优先)，对[1][1]，area=6（因为[1][1]不作为角点，它所在的最高矩形高度为1，宽度为6）
            不作为角点的话，就需要找当前元素连续的最左边的1（其位置为curL）和连续的最右边的1（其位置为curR）
            但既然是高度优先，那么如果当前元素上方的元素是1，则当前元素用于计算矩形宽度的有效的L = max(preL, curL)，R=min(preR,curR) (用范围最小的，才能保证覆盖)

            设cur_left是第i行第j个元素往左数最左边1的位置；
            left[i][j]是第i行第j个元素所在的最高矩形的左边界位置，计算的时候只根据元素[i][j]和元素[i-1][j]最左边最近的‘1’定。只需考虑他俩即可。
            设cur_right是第i行第j各元素往右数第最后一个1的位置；
            right[i][j]是第i行第j个元素所在的最高矩形的右边界位置，计算的时候只根据元素[i][j]和元素[i-1][j]最右边最近的‘1’定。同上
            height[i][j]为第i行第j个元素所在最高矩形的高度，一定是以1为宽，往上走能达到的最高高度

            若[i][j]为1
            left[i][j] = max(left[i-1][j], cur_left)
            right[i][j] = min(right[i-1][j], cur_right)
            height[i][j] = height[i-1][j]+1

            若[i][j]为0
            left[i][j] = 0， cur_left=j+1
            right[i][j]=col-1  cur_right=j-1; //这里left和right是为了方便后面计算而设成该值的（因为该0元素不用管），并不是就是该具体值。

            第i行第j个元素所在行为底所在的最高矩形面积为 (right[i][j]-left[i][j] + 1) * height[i][j]


》给定一个“1”(陆地)和“0”(水域)的二维网格地图，计算岛屿的数量。岛屿被水环绕，通过水平或垂直连接相邻的陆地而形成。你可以假设网格的四个边都被水包围着。：200
    计算块的，用广度优先遍历，遍历过的位置标记，如果是1则加入队列，如果是0则跳过，需要注意的是，对于一个块来说，斜方的不算和它同一块的



》给定一个包含0和1的二维二进制矩阵，找出只包含1的最大正方形并返回其面积。：221
    以dp[i][j] 记录以第i行第j列的元素为右下角的最大正方形的边长

    如果
    leftOne[i][j] 表示nums[i][j]从右往左数有几个连着的1（算自己）
    topOne[i][j] 表示nums[i][j]从下往上数有几个连着的1（算自己）

    当nums[i][j]=0,则leftOne[i][j]=0; topOne[i][j]=0;
    当nums[i][j]=1，则leftOne[i][j]=leftOne[i][j-1]+1; topOne[i][j]=topOne[i-1][j]+1;

    如果nums[i][j]=0,则dp[i][j]=0;
    如果nums[i][j]=1
    ```java
    int pre = dp[i-1][j-1];
    //左连1须大等于左上角的边长，右连1须大等于左上角的边长，且左上角边长大等于1，才不会进入循环，否则就进入表示左上角边长太大，需要减
    //这个过程代入个例子想一想很简单的。
    while(!(leftOne[i][j-1] >= pre && topOne[i-1][j] >= pre) && pre>=1){
        pre--;
    }
    dp[i][j] = pre+1;
    最后的答案是 dp[i][j]中最大值的平方


》找出最长的递增子序列的长度（LIS）（这里的子序列不用挨着）：300
    有序序列{a1,a2,...} 求其最长递增子序列的长度，用dp[i]代表递增子序列以ai结束时的长度，dp[1]=1，
    注意到以ax结尾的递增子序列，除了长度为1之外，其他情况，ax都是紧跟在一个由ai(i< x)组成的递增序列之后。要求以ax结尾的最长递增子序列长度
    则要依次比较ax与其之前所有的ai(i< x)，若ai小于ax，则说明ax可以跟在ai结尾的递增子序列后形成一个新的递增子序列
    特殊的，当没有ai(i< x)小于ax，那么以ax结尾的递增子序列最长长度为1，即dp[x] = max {1, dp[i]+1|ai< ax && i < x|}

        dp[i]=1;
        for(int j=0;j< i;j++){
            if(arr[i]>arr[j])
                dp[i] = Math.max(dp[i],dp[j]+1);
        }


》求具体的最长递增子序列：c-p202
    给定数组arr，返回arr的最长递增子序列
    一般求最长递增子序列长度的办法的动态规划法：O(n^2)
    dp[i] 表示arr[0...i]之间且以arr[i]结尾的最长的递增子序列
    dp[i]初始化为1，表示只有arr[i]一个

    dp[i]=1;
    for(int j=0;j< i;j++){
        if(arr[i]>arr[j])
            dp[i] = Math.max(dp[i],dp[j]+1);
    }

    如果要求具体序列的话，可以在dp的过程中加上一个表示上一个索引的数组pre[i]
    ，如pre[i]=x, 表示以arr[i]结尾的最长递增子序列中，arr[i]的上一个数字是arr[x];
    令pre[i]默认为-1，表示没有上一个数字。最后按照pre数组还原出序列

    还原序列的方法2：除了上面用pre来记录上个节点，直接用dp也可以还原序列
    遍历dp数组，找到最大值以及为止，然后从最大值位置开始从右往左遍历，如果对应某一位置i，既有arr[i]< arr[maxi], 又有dp[i]=dp[maxi]-1,说明其可以当做递增子序列的倒数第二个数，然后就可以继续往前走了，直到找到所有的数

    》上面的复杂度是O(N^2)，要想优化为O(NlogN),需要用二分查找优化，见c-p202.2




》确定9x9数独板是否有效。只需要根据以下规则验证已填充的单元格：36
  1.每行必须包含数字1-9而不重复。 
  2.每列必须包含数字1-9而不重复。 
  3.网格的9个3x3子框中的每一个必须包含数字1-9而不重复。
数独板可以部分填充，其中空单元格填充字符'.'

注意：

数独板（部分填充）可能有效，但不一定是可解决的。
只需要根据上述规则验证已填充的单元格。
给定的板只包含数字1-9和字符'。'。
给定的板尺寸始终为9x9。
    
    使用HashSet，对于任意一个数nums[i][j]=k

    set中对于一个数字，保存以下信息：
    k在第i行，被记为"(k)i"
    k在第j列，被记为"j(k)"
    k所在的块的序号为 i/3, j/3  记为："i/3(k)j/3"

    对于每一个值(除了.)，尝试添加上述三个值，如果上述三个信息中有任何一个被添加过了，则说明一定是不符合的。直到把所有数字都执行完发现都可以添加，则一定是符合的

    对于HashSet.add，如果添加一个已经存在的值，则会返回false，否则返回true


》给定一个mxn矩阵，如果一个元素是0，把它的行和列上的元素都设为0：73
    保留两个set，一个存为0的行标，一个存为0的列标，先遍历，把两个set都放满，然后再二重循环去放0，只要某元素的行或列在set中，则置为0



》给定一个包含“X”和“O”(字母O)的2D板，捕获由“X”包围的所有区域。：130
    一个区域是通过在被包围的区域内将所有的O翻转成X来捕获的，把被'X'包裹的'O'块全转成'X'，有点像秦时明月里面那个特殊的围棋玩法

    对于不在边界上的一个'O'，对其广度优先遍历，当遇到相邻的'O'时入队，并做标记，当遇到'O'时在边界上时，说明这个块没有被包裹
    当没有边界上的'O'，且最终队列为空时，说明被全部包裹了，则对它再次广搜（或者记录搜过的行列号），这次把它们全部都变成X
    //对于一次遍历，一定要全部都遍历完了，再做处理，不能半途遇到边界就退出



》单词搜索2：给出一个字典，在版面中找到其中出现过的词，词由相邻的字母组成，一个位置上的字母不能在一个词中出现多次：212
    首先想到的就是深度优先遍历,对一个位置进行深搜时，要用一个flag避免搜到已经搜到过的字母,使用普通递归的深搜会超时

    考虑使用trie结构，并用word，表示它是当前单词的最后一个字母，只有一个trie根

    把字典保存在trie p中，二重循环遍历面板中每一个字母，对其进行dfs
    每当遍历到一个位置时，p也随着到相应的位置，当二者不匹配时，不符合。把遍历过的位置先置为一个特殊字符，比如'#'，防止下次又遍历到它。再深入它的邻居位置，当所有邻居位置都扫描过后，再把它置回。当遍历到一个单词时，p也能到相应的位置，说明匹配，加入结果集，最后结果集要去重（所以可用set）

    这种搜索的题，可以考虑使用trie，配合使用深度优先遍历，可以剪很多枝（避免很多没用的遍历）
    trie：字典树（特里结构、单词查找树）


》顺时针打印矩阵，即打印矩阵的螺旋序 ：j29-p161，54，59
    输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

    还是四个方向，先往右，右到头了向下，要注意的是要遍历的个数每一圈都在减少，直到最后一个遍历完了。
    设置左右上下的边界值，一旦到达边界值，下右边界值就-1，上左边界就+1
    如：example2，一开始从左往右走，右边界为3，当到达第四列时（值为3），则往下走，右边界-1
    往下走到下边界2处，下边界-1，再往右走。。。
    注意的是，可能不是方阵。
    每遍历到一个数时，先加入到结果集中
    在一个方向上运动，如果没到头，该方向上索引继续；如果到头了，更改方向，另一方向上的索引再更新
    循环终止的条件是访问过的节点数等于节点总数。


》给一个m* n的平面中的细胞，每个细胞有1（生）或0（死）两种状态，每个格子可以影响到它周围的8个格子（上下左右，斜方），：289
    按照如下规则：
    任何活的细胞如果少于两个活的邻居，就会死亡，好像是由于人口不足造成的。
    任何有两个或三个邻居的活细胞都能活到下一代。
    任何有三个以上邻居的活细胞都会死亡，就好像是由于人口过剩。
    任何有三个活邻居的死细胞都会变成活细胞，就像通过繁殖一样。
    编写一个函数来计算给定当前状态的下一个状态(在一次更新之后)。下一个状态是通过将上述规则同时应用于当前状态中的每个细胞而创建的，此时出生和死亡同时发生。

    你能就地解决吗?请记住，板子需要同时更新:您不能先更新某些细胞，然后使用它们的更新值来更新其他细胞。
    在这个问题中，我们使用2D数组来表示黑板。从理论上讲，板是无限的，当有源区域侵犯阵列边界时，会产生问题。你将如何解决这些问题?

    如果不用就地解决很好办，直接用另一个二维数组存下一个状态即可

    为了能就地解决，让board既保存原状态，也保存下一个状态，由于状态是非0既1，只用一位就可以表示
    而board的每个元素elem是int
    因此让elem的最低位表示旧状态，次低位表示新状态，
    当新状态更新完后，只需要右移一位即可替换

    ## 这种思想可以借鉴，当要存储的每项数据只有很少的几位，而实际类型却有很多位时，可以考虑复用存储单元



》给定一个整数矩阵，求出最长增长路径的长度。：329
    从每个单元格中，您可以向四个方向移动:左、右、上或下。你不能斜向移动或移出边界(即不允许环绕)。

    可以试一试回退递归，回退递归其实和dfs是一样的，
    这里有个核心地方在于，保存已经遍历过的位置作为出发点的最大路径(不保存再利用的话会超时)

    因此这里的关键在于，从一个cell出发，它的最长路径值是一定的， 不用管它的上一个cell是谁，也不需要用标志数组保存已经遍历过的节点(不存在走回头路的可能，因为回头的cell比当前cell小，走不过去的，而不像一般的dfs，还要保存已经遍历过的标志)

    对一个位置使用dfs去探究它的四个邻居，当邻居值大于它时，递归dfs这个邻居，并且保存其中的能到达的最长路径，将其作为v，保存到缓存数组中
    最后求出所有位置的缓存数组中的最大值


》数独问题：37
    编写一个程序，通过填充空单元格来解决数独难题。
    数独解决方案必须满足以下所有规则:

    每个数字1-9必须在每一行中精确地出现一次。
    每个数字1-9必须在每一列中精确地出现一次。
    每个数字1-9必须在网格的9个3x3子框中精确地出现一次。
    空单元格由字符'.'表示。

    注意:

    给定的板只包含数字1-9和字符'.'。
    你可以假设给定的数独游戏将有一个唯一的解。
    给定的板大小总是9x9。
    解决数独问题

    三重循环+递归

    solve(){
        for i:行
            for j:列
                如果该位置是待填充的位置
                    for c: 1-9
                        if(isvalid()){
                            将c填入该位置
                            if(solve())
                                return true;
                            else
                                将该位置恢复到未填充的状态
                        }
                    //尝试在这个位置上放置所有数字，都无效（都没有返回true），说明此次验证失败   
                    return false

        //全都填满了，但没有返回false，说明成功
        return true;    
    }

    //检查字符c是否可以放在row-col处
    isvalid(char[][] board, int row, int col, char c){
        for(int i=0;i<9;i++){
            if(board[i][col]==c) return false; //检查该列
            if(board[row][i]==c) return false; //检查该行
            //检查3x3方格，注意这个方格不是以row-col为中心的，而是9x9中的3x3大方格
            //要在i从0到8这个过程中检查这9各方格
            //row-col所在的大方格的列是 col/3，所在大方格的行是 row/3
            //为了能遍历完，行上用i/3,列上用i%3,,如果都用i/3或i%3，那么9次只能遍历3个格子
            if(board[(row/3)* 3+i/3][(col/3)* 3+i%3]==c) return false;
        }   
        return true; 
    }


》给定已排序的数组号，删除重复项，使重复项最多出现两次，并返回新的长度。
    不要为另一个数组分配额外的空间，您必须使用O(1)额外内存修改输入数组。
    由于数组已经是排好序的，而且最后只看前面满足条件的个数，所以直接让需要被替换的地方变成最大的数，最后再对数组排序即可
    遍历数组，记录上一个出现过两次的元素，当再出现时，直接将其替换成最大的数（每当替换一个数，计数器+1，最终新的数组长度=原数组长度-计数器）

    例1：0,0,1,1,1,1,2,3,3-》0,0,1,1,3,3,2,3,3--》0,0,1,1,2,3,3,3,3。
    例2：1,1,1,2,2,3-》1,1,3,2,2,3 -》1,1,2,3,3



》给定s1 s2 s3，找出s3是否由s1和s2交叉组成。：97
    这里的交叉，应该是拿s2中的字母去随便插入s1的位置，而不是整个s2插入s1中

    ## 这道求交织相错的字符串和之前那道 Word Break 拆分词句 的题很类似，
    ## 就想我之前说的只要是遇到字符串的子序列或是匹配问题直接就上动态规划DynamicProgramming，
    ## 其他的都不要考虑，什么递归呀的都是浮云，千辛万苦的写了递归结果拿到OJ上妥妥Time Limit Exceeded，能把人气昏了，
    ## 所以还是直接就考虑DP解法省事些。一般来说字符串匹配问题都是更新一个二维dp数组，核心就在于找出递推公式。

    s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"

      Ø d b b c a
    Ø T F F F F F
    a T F F F F F
    a T T T T T F
    b F T T F T F
    c F F T T T T
    c F F F T F T

    首先，这道题的大前提是字符串s1和s2的长度和必须等于s3的长度，如果不等于，肯定返回false。那么当s1和s2是空串的时候，s3必然是空串，则返回true。所以直接给dp[0][0]赋值true，然后若s1和s2其中的一个为空串的话，那么另一个肯定和s3的长度相等，则按位比较，若相同且上一个位置为True，赋True，其余情况都赋False，这样的二维数组dp的边缘就初始化好了。下面只需要找出递推公式来更新整个数组即可，我们发现，在任意非边缘位置dp[i][j]时，它的左边或上边有可能为True或是False，两边都可以更新过来，只要有一条路通着，那么这个点就可以为True。那么我们得分别来看，如果左边的为True，那么我们去除当前对应的s2中的字符串s2[j - 1] 和 s3中对应的位置的字符相比（计算对应位置时还要考虑已匹配的s1中的字符），为s3[j - 1 + i], 如果相等，则赋True，反之赋False。 而上边为True的情况也类似，所以可以求出递推公式为：

    例如对于第二行第二列(a,d)，如果从上面更新过来，说明此时的字符串是da，如果从左面更新过来，说明此时字符串是ad，只要有一种情况能成立，此位置就是T，否则就是F
    使用这样boolean类型字符表盘，屏蔽了当前字符串具体是什么，只需知道能不能成为它即可。

    即一个位置只能由它的左边或上边更新过来，如果是从左边更新过来，意味着增加了s2的一个字母；如果是从上边更新过来，意味着增加了s1的一个字母；

    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i - 1 + j]) || (dp[i][j - 1] && s2[j - 1] == s3[j - 1 + i]);

    其中dp[i][j] 表示的是 s2 的前 i 个字符和 s1 的前 j 个字符是否匹配 s3 的前 i+j 个字符



```


#图算法
```
》核心是求一个图的拓扑排序：207，210
    把每个节点的前驱节点都保存到各自的一个数组中
    保存每个节点的入度数，每次都遍历入度为0的节点，然后把它的后继节点的入度都-1，持续这个过程，
    如果最终能遍历完所有节点，则遍历的序列就是一个拓扑排序，否则不能拓扑排序。（也可以用出度，但就是得从后往前遍历）


》给定连接的无向图中节点的引用，返回图的深度副本(克隆)。图中的每个节点都包含一个val (int)及其邻居的列表(list [node])。：133
    从起始点开始，以深度优先的形式，克隆每个节点，
    遍历该节点的每一个相邻节点，若相邻节点对应新节点存在，则直接将其与该节点连接起来，否则，递归克隆该相邻节点
    很关键的一点是要用一个map保存新节点和旧节点的对应关系


》最小高度树：310
    对于具有树特征的无向图，我们可以选择任何节点作为根。 结果图就是一棵有根树。 在所有可能的有根树中，具有最小高度的树被称为最小高度树（MHT）。 给定这样一个图，编写一个函数来查找所有MHT并返回其根标签列表。（这里不是二叉树，只需是树即可）
    该图包含从0到n-1标记的n个节点。将为您提供数字n和一个无向边的列表（每个边是一对标签）。
    您可以假定边缘中不会出现重复的边缘。 由于所有边缘都是无方向的，因此[0，1]与[1，0]相同，因此不会一起出现在边缘中。
    归结到图算法中，其实是求图中每个节点到图中其他节点的最大距离中的最小值。

    》超时方法
        广度优先遍历每一个节点，计算每个节点到图中其他节点的最大值，在这些最大值中挑出最小的，这个起始点就是一个MHT的根
        这里的广度优先遍历要记录每次遍历的层级，采取这样的方法：
        while(队列不空){
            for(i<当前层的节点数){
                if(当前层的节点的邻节点有 没有被访问过的，将这个邻节点加入队列，且下一层节点数++
            }
            当前层节点数 = 下一层节点数
        }
        使用这种普通广搜方法会超时，需要考虑更特殊的解法

    》AC方法：
        我们的问题是要我们找到最小高度树并返回其根标签。首先，我们可以考虑一个简单的案例-路径图。
        对于n个节点的路径图(本质是链表)，发现最小高度树是微不足道的。只需将中间点指定为根即可。
        尽管有两个循环。尽管琐碎，让我们设计一个算法来找到它们。
        假设我们不知道n，也没有节点的随机访问权。我们必须遍历。很容易得到两个指针的想法。两端各有一个，并以相同的速度移动。当它们相遇或相距一步之遥时（取决于n的奇偶性），我们就有了想要的根。

        这给我们提供了许多有用的想法来破解我们的实际问题。
        用拓扑排序的思想，每次都删除度为1的节点，最终剩下的一个或两个节点就是这个根
        而且要注意的是如何保留一个节点所有的邻节点，只需要用ArrayList<HashSet<Integer>> list:  list.get(i)中包含了i节点的邻节点
        时间复杂度和空间复杂度均为O（n）。

        ## 这里有一个重要的思想是，当一个节点度不为1时，删除了一轮度为1的节点后，它的度变成了1，唯一的可能性是它是上一轮度为1的节点的邻节点。在树中，就是一个节点从非叶子节点变为叶子节点，唯一的可能性是它是上一次叶子节点的邻节点


```


#划分和合并
```
》4是一道典型的划分题，划分题要找好规律，并且要考虑到所有边界情况：4
    有两个大小分别为m和n的排序数组nums1和nums2。
    求两个排序数组的中位数。总的运行时复杂度应该是O(log (m+n))。
    您可以假设nums1和nums2不能同时为空。

    难度在于怎么把时间复杂度控制在log(m+n),一般只要出了log的复杂度，那就是二分查找这种类型的。

    把A和B分别分成两个集合（A长m，B长n），A1,A2,B1,B2；,A1中的元素都小于A2中的元素；B1中的元素都小于B2中的元素，要把它们合起来，变成A1+B1 和A2+B2,前面集合中的元素必须都小等于后面集合的元素。（即A[i-1]<B[j] 且 A[i]>B[j-1]）
    分成两个大集合
               left_part          |        right_part
         A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
         B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
    如果A1中元素有i个，则A2中有m-i个，同理，B1中有j个，则B2中有n-j个
    要取A+B的中位数，则：
    #1。如果A+B的长度为奇数，则要使A1+B1的长度 比 A2+B2的多1，中位数就是多出来的那个数。
    #2。如果A+B长度是偶数，则要使A1+B1的长度 == A2+B2的长度，中位数=（前面集合中的最大数+后面集合中的最小数）/2
    i和j需满足的条件是：i+j=m-i+n-j（或m-i+n-j+1（当n+m为奇数））则 j=（m+n）/2-i 或（m+n+1）/2 -i （为了方便起见，由于若m+n是偶数时，(int)(m+n+1)/2 == (int)(m+n) /2）
    所以统一写为 j=(m+n+1)/2-i。

    i的范围是0~m时（i是要进行搜寻的变量，所以以他的范围为标准来界定j的范围），则为了让j满足 0~n，则需要使 n>=m,因为：
    m≤n,i<m⟹j=(m+n+1)/2−i>(m+n+1)/2−m≥(2m+1)/2−m≥0
    m≤n,i>0⟹j=(m+n+1)/2−i<(m+n+1)/2<=(2n+1)/2−m<=n
    如果n<<m，而i要是取个m-1，j=(m+n+1)/2-(m-1)=(n-m+3)/2如果m远大于n，则这个值可能是负值，那就出错了。（所以要选取短的那个数组做A）

    所以要做的事情就变成了在A中搜一个下标i，使得搜出的i满足上述条件。
    搜i的方法要使用二分查找，只有二分查找能达到log的时间复杂度
    一开始限定i的范围为 imin=0，imax=m，则i= （imin+imax）/2
    搜i的过程中可能会遇到以下情况：
    * A[i-1]<B[j] 且 A[i]>B[j-1] 符合条件，退出搜索
    * A[i-1]>B[j]（A[i]>B[j-1] 一定成立）说明i太靠后了，修改imax的限定范围为  i-1,  则      i=（imin+i-1）/2，继续搜索。
    * A[i]<B[j-1]（A[i-1]<B[j] 一定成立）说明i太靠前了，修改imin的限定范围为  i+1  ,则i=（i+1+imax）/2，继续搜索。

    当遇到边界情况
        当i=0时，说明A中所有元素都在右边，B不可能都在右边
        当j=0时， 说明B中所有元素都在右边，A不可能都在右边
        当i=m时，说明A中元素都在左边，B不可能都在左边
        当j=n时，说明B中元素都在左边 ，A不可能都在左边

    # 如果借鉴求流中中位数的方法，使用两个优先级队列可以很方便地求出中位数，但由于优先级队列的插入复杂度是logn,(优先级队列的底层实现是堆)，
    所以总的复杂度会成为(m+n)log(m+n),因此仍然不满足时间条件




》给定一组区间，合并所有重叠的区间：56
        不能直接顺着去合并，会漏掉情况，比如 {[2,3],[4,6],[7,9],[1,10]}
        顺着去合并，只能成为{[1,10],[4,6],[7,9]}，如果多次检查的话，会导致复杂度特别高

        事实上，把interval按照start的排序，然后就可以顺着去合并了（interval简写成inter）
        如上面的，排完序是{[1,10],[2,3],[4,6],[7,9]}
        首先将第一个inter加入解集
        然后遍历所有inter进行合并，每遍历到一个inter，比较当前inter和解集中的最后一个inter
        如果两个interval的start一样，则该inter合并到解集中的inter，
        如果两个start不一样，但解集中的的start大于这个的end，则该inter合并到解集中的inter，
        否则，这个inter和解集中的inter无交集，把这个inter加入解集，从下一个inter再重新开始比较

        ## 这种interval的题，一定要先把所有inter排序了再处理（一般是按照左边界排序）


》给定一组不重叠的区间，在区间中插入一个新的区间(如果需要合并则合并)。：57
    您可以假设这些区间最初是根据它们的开始时间排序的。

    遍历所有区间和新区间，如果当前遍历到的区间和新区间有重合，则将新区间更新为并集，然后继续这个过程，期间把没有重合的单独保存在结果集
    最终的结果就是新区间以及没有重合的区间，只需要将新区间放入答案集中，然后排序（需要重写Comparator）即可




》给定一个数组，有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口看到k个数字。每次滑动窗口右移一个位置，算一个新的窗口。返回每个窗口中的最大数值组成的数组。：239，j59-p288
    》方法一：（这种方法很难记忆，还是推荐方法二）
    例如：A = [2,1,3,4,6,3,8,9,10,12,56]，w = 4

    将数组分区为大小为w = 4的块。 最后一个块可能少于w。
    2,1,3,4 | 6,3,8,9 | 10,12,56 |

    从头到尾遍历列表并计算max_so_far。 在每个块边界（w个元素）之后重置最大值。
    left_max [] = 2,2,3,4 | 6,6,8,9 | 10,12,56

    类似地，通过从末端到开始遍历来计算未来的最大值。
    right_max [] = 4,4,4,4 | 9,9,9,9 | 56,56,56

    现在，在当前窗口中的每个位置i处滑动最大值，sliding-max（i）= max {right_max（i），left_max（i + w-1）}
    sliding_max = 4,6,6,8,9,10,12,56

    left_max[i]表示以nums[i]为右边界，左边界为nums[i]所在块的左边界  这个区间中最大的数
    right_max[i]表示以nums[i]为左边界，右边界为nums[i]所在块的右边界 这个区间中最大的数。

    则对于任意ans[i]，则是nums[i]为左边界，nums[i+w-1]为右边界的区间中的最大数

    比如对 4,1,2,3 | 6,3,8,9 | 10,12,56 |
    ans[2]对应的区间是： 2 3 | 6 3，left[5]=6 , right[2]= 4  故ans[2]=6

    对于该区间，计算的是，2<-3中最大的值，与6->3中最大的值，即为6
    对于区间 1,2,3 | 6 计算的是 1<-2<-3中最大的值与6中的最大值 即为6
    对于区间 3 | 6 3 8  计算的是 3的最大值与6->3->8的最大值，即为8
    对于不跨区间的  4,1,2,3 | ，即ans[0]  left[3] = 4, right[0]=4 

    一定要学会这种方法解决类似的问题：滑动窗口中的最值，核心在于划分区域+左右遍历

    》方法二：
    另一种做法，使用窗口法,借助双端队列 deque

    双端队列中放入的是索引
    若待加入的数字大于队头索引对应的数字，则清空队列加入该索引
    若待加入的数字小于队头索引对应的数，则和队尾索引对应的数的比较：
        若大于队尾对应的数，从队尾出队直到队尾对应的数大于该数，向队尾插入该数的索引
        若小于队尾对应的数，向队尾插入该数的索引

    若待加入的数字的索引和队头索引差大等于过size，则出队直到索引差小于size

    出队头，将其对应的数字加入答案集（该步从第size个数，下标为size-1时再开始做）


    对于
    {2,3,4,2,6,2,5,1}   w=3
    遍历到的数字     队列中的索引(对应的数字)（队尾-----队头） 
    2                   0(2)
    3                   1(3)
    4                   2(4)
    2                   3(2)  2(4)
    6                   4(6)
    2                   5(2) 4(6)
    5                   6(5) 4(6)
    1                   6(5)
    双端队列就使用LinkedList




》给一个n x n的矩阵，每一行每一列都是排好序的，找到矩阵中第k小的元素：378
    简单的做法，每一行都维持一个头指针，每次取头指针中最小的值，然后该头指针后移，再次比较，直到比较第k次为答案


》n-皇后难题是将n个皇后放在n×n的棋盘上，使没有两个皇后互相攻击。：51
    给定一个整数n，返回n-queens谜题的所有不同解。
    每个解决方案包含一个不同的董事会配置的n皇后的位置，其中的'Q'和'。“这两个字母分别表示女王和空格。
    每个皇后周围的8个格子内不能有别的皇后,而且每一列，每一行，每一斜线只能有一个皇后
    
    先把二维数组填充满"." (表示待放置皇后)

    trackback(char[][] board, int n, int row, int queenCount){
        //皇后数不能超过n
        if(queenCount>n) return;
        //皇后数为n时，即为一个解
        if(queenCount==n){
            addOneList(board, n);
            return;
        }
        每一行只能有一个皇后，在该行(row)中如果该位置(row,j)可以放置皇后，则再到下一行(row+1)放置皇后。
        由于在该行可能不止该列能放置皇后，所以在trackback，回退去检查该行的其他位置
        遍历
        for(int j=0;j<n;j++){
            if(isValid(row, j,board,n)){
                board[row][j]='Q';
                trackBack(board, n,row+1,queenCount+1);
                board[row][j]='.';
            }
        }
    }
    //判断当前位置(i,j)放置皇后是否合法
    boolean isValid(int i, int j, char[][] board, int n){
        先检查该位置四周8个位置是否有其他皇后，有则返回false
        再检查该列上是否有别的皇后 //由于上面的tackBack能保证一行只有一个皇后，所以这里只需要判断该列是否有别的皇后即可
        再检查两条斜线上的,分别有右上，右下，左上，左下四种情况
        如果上述检查都通过，则返回true;
    }
    //增加到结果集
    StringBuilder s = new StringBuilder();
    //把当前的二维数组转成List
    void addOneList(char[][] board, int n){
        List<String> tmp = new ArrayList<>(n);
        for(int i=0;i<n;i++){
            s.delete(0, s.length());
            for(int j=0;j<n;j++){
                s.append(board[i][j]);
            }
            tmp.add(s.toString());
        }
        res.add(tmp);
    }


》n皇后2，返回的不是结果集，而是结果个数，和上面的一脉相承：52，c-p238
    》基本方法：
        把结果集改成个数即可，递归+遍历的做法（本质是trackback），递归每一行，如果该行该位置能放置，则进入下一行。这样做法在n大时会非常非常慢，（在n=14时为10s）


    》更好的方法：（好像比较超自然）：c-p238
        变量upperLim表示当前行的那些位置是可以放皇后的，1代表可以放置，0代表不能放置。
        8皇后问题中，初始时upperLim=00000000000000000000000011111111，32皇后问题中，初始时upperLim=11111111111111111111111111111111
        colLim表示递归计算到上一行为止，哪些列已经放置了皇后，1代表已经放置，0代表没有放置。
        leftDiaLim表示递归到上一行为止，因为受已经放置的所有皇后的左下方斜线的影响，导致当前行不能放置皇后，1代表不能放置，0代表可以放置。举个例子，如果在第0行第4列放置了皇后。计算到第1行时，第0行皇后的左下斜方影响的是第1行第3列，当计算到第二行是，第0行皇后的左下斜影响的是第二行第2列，leftDiaLim每次左移一位，就可以得到之前所有皇后的左下方斜线对当前行的影响。
        rightDiaLim表示递归到上一行为止，因为受已经放置的所有皇后的右下方斜线的影响，导致当前行不能放置皇后，1代表不能放置，0代表可以放置。rightDiaLim每次右移一位，就可以得到之前所有皇后的右下方斜线对当前行的影响。

        变量mostRightOne代表在pos中，最右边的1是什么位置，然后从右到左一次筛选出pos中可选择的位置进行递归尝试




》给定一个2D矩阵matrix，求给定的左上角(row1, col1)和右下角(row2, col2)所定义的矩形内元素的和。：304
    范围和查询2D
    上面的矩形(带有红色边框)由(row1, col1) =(2,1)和(row2, col2) =(4,3)定义，其中包含sum = 8。
        Given matrix = [
        [3, 0, 1, 4, 2],
        [5, 6, 3, 2, 1],
        [1, 2, 0, 1, 5],
        [4, 1, 0, 1, 7],
        [1, 0, 3, 0, 5]
        ]
    sumRegion(2, 1, 4, 3) -> 8
    sumRegion(1, 1, 2, 2) -> 11
    sumRegion(1, 2, 2, 4) -> 12
    你可以假设矩阵不变。
    对sumRegion函数的调用有很多。
    您可以假设row1≤row2, col1≤col2。
    由于调用很多，所以不能每次调用都去遍历计算

    》方法一：
        设dp[i][j]是第i行，前j个元素的和,从第0个开始算
        dp[i][j] = dp[i][j-1]+nums[i][j]
        sumRegion(row1, col1, row2, col2) = for(int i=row1,i<=row2;i++) sum += dp[i][col2]-dp[i][col1-1]
        边界判断：
            if(matrix==null || matrix.length==0 || matrix[0].length==0) return;

    》方法二：
        设dp[i][j]是(0,0)为左上角，(i,j)为右下角的矩形中的和
        则有递推公式：dp[i][j] = dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+nums[i][j]
        i=0时，dp[i][j] = dp[i][j-1]+nums[i][j]
        j=0时，dp[i][j] = dp[i-1][j]+nums[i][j]
        dp[0][0] = nums[0][0]
        计算结果:
            int sum = dp[row2][col2];
            if(row1>0)
                sum -= dp[row1-1][col2]; //去掉上侧的一块
            if(col1>0)
                sum -= dp[row2][col1-1];  //去掉左侧的一块
            if(row1>0 && col1>0)
                sum += dp[row1-1][col1-1]; //加上被多去掉的一块，即左上角那一块
            return sum;


》给定以成对的出发地和到达机场为代表的机票清单，请按顺序重构行程。 所有的票都属于一个从JFK出发的人。 ：332
    因此，行程必须从JFK开始。

    如果有多个有效路线，则当以单个字符串形式读取时，应返回词汇顺序最小的路线。 例如，行程[“ JFK”，“ LGA”]的词序比[[JFK]，“ LGB”]的词序小。所有机场都用三个大写字母（IATA代码）表示。

    遍历出所有可能性，将所有可能性序列排序，取出其中最小的，这种方法超时

    一开始考虑过用Map<String, PriorityQueue>的方式，但想的是从前往后走，
    一旦遇到像 A->B, A->C，C->A这种情况，正常的顺序应该是A->C->A->B，但从A只能搜出来B，就卡壳了。
    但其实是逆向思考的，从A开始如果能往下走则一直往下走，直到走不动，就把这个值加入答案中，然后再回溯。答案是从后往前添加的。

    例如 A->B, A->C，C->A，从A开始

    map中：A：B,C;   C：A
    从A开始遍历其map，先取出的是B，
    B的map为空，所以把B加入答案中,此时答案是 B
    A的map剩下C，继续遍历C的map
        C的map剩下A，继续遍历A的map
            A的map为空，把A插入答案中，注意这里用头插法，所以此时答案是 AB
        C的map为空，把C插入答案中，所以此时答案是 CAB
    A的map为空，把A插入答案中，所以此时答案是 ACAB

    ## 这种方法用来找有向图的边遍历路径，即该路径包含了有向图的所有边。



```

#回文问题
```
》找回文：以每个字母为中心点（中心扩散法）：5，b29
如果是奇数长度，回文，向两边拓展，左右分别是 left=i-1和right=i+1,   left--, right++
如果是偶数回文，左右分别是 i, i+1,回文一般用这种方法比较好判断：    

》回文的判定：一串字符正着和反着一样则是回文：9，125
    如果忽略大小写，则先全转成大写或小写，再看正着和反着是否相同

》最短回文：给一个字符串s，在s前面添加最少字符使得其成为一个回文串，找出这个回文串：214
    遍历i，从0到s.len，把s从后往前依次去掉i个字符看是否是回文，若是，则i就是最少要添加的字符，s.substring(s.len-i, s.len)就是要添加的字符串
    把这个串翻转然后加到s最前面，就是要求的最短回文 (注意要处理i=0，或者s为null或""的情况)

》找出字符串中回文子串的个数：647
    每次针对一个字符，分别找以它为中心的回文字符，要分奇数和偶数两种情况（中心扩散法）
    对于nums[i]，以它为中心的回文子串分两种情况
        奇数长度情况下：left=i,right=i, left--,right++;
        偶数长度情况下：left=i,right=i+1, left--,right++;


》给定一个字符串s，分区s使得分区的每个子字符串都是一个回文。返回所有可能的s的回文分区。：131
    如果输入是“aab”，检查[0,0]“a”是否是回文。 然后检查[0,1]“aa”，然后检查[0,2]“aab”。
    在检查[0,0]时，字符串的其余部分为“ab”，使用ab作为输入来进行递归调用。
    比如
    检查[0]是回文，
        再检查[1]
            再检查[2]
        再检查[1,2]

    检查[0,1]
        检查[2]

    再检查[0,1,2]
    ...整个过程如此


》对于找连续子串是否是回文，除了上面的中心扩散法，还可以用动态规划，状态转移方程：如果头尾字符相等并且中间也是回文


》不连续回文字符串：b23
    最大回文子串是被研究得比较多的一个经典问题。一个变种：对于一个字符串，如果不要求子串连续，那么一个字符串的最大回文子串的最大长度是多少呢。
    dp[i][j]表示 s[i...j]中最长的回文子串长度
    dp[i][i] = 1
    若 s[i]==s[j], dp[i][j] = dp[i+1][j-1] + 2  (s[j]和s[i]也加入这个最长回文)
    若 s[i]!=s[j], dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])  (s[j]加入回文，或者s[i]加入回文)

    这里的问题是不能对i和j都从头到尾遍历，因为dp[i][j]会依赖于dp[i+1][x]，而i是小等于j的，所以外层循环是j从0到n-1，然后内层i的循环从j-1到0


》添加最少字符使字符串整体都是回文字符串：c-p269.1
    给定一个字符串str，如果可以在str的任意位置添加字符，返回在添加字符最少的情况下，让str整体都是回文字符串的一种结果

    str=ABA，str本身就是回文，不需要添加字符，所以返回ABA
    str=AB，则可以返回BAB，也可以返回ABA

    不要与214题混淆，214是简单情况，只在str的前面添加，这道题是任何位置都可以添加
    先看str是不是回文，若是则直接返回


    使用动态规划：dp[i][j]代表子串str[i...j]最少添加几个字符可以使str[i..j]整体都是回文串
    1.如果str[i..j]只有一个字符，那么dp[i][j]=0，因为它已经是回文串
    2.如果str[i..j]只有两个字符，那么dp[i][j]=0，如果不等，那么只用添加一个字符即可，即dp[i][j]=1
    3.如果str[i..j]多于两个字符，
        若str[i]==str[j]，那么dp[i][j]=dp[i+1][j-1]
        若str[i]!=str[j],要让str[i..j]变成回文串有两种方法：
            >1.让str[i..j-1]先变成回文串，然后再左边加上字符str[j]
            >2.让str[i+1..j]先变成回文串，然后在右边加上字符str[i]
        取两种办法中的更小情况，即dp[i][j]= 1+ min{dp[i+1][j], dp[i][j-1]}

    然后根据dp矩阵，求在添加字符最少的情况下，让str整体都是回文字符串的一种结果：
    dp[0][n-1]的值代表整个字符串最少添加几个字符，如果最后的结果记为字符串res，res的长度=dp[0][n-1]+str长度，然后依次设置res左右两头的长度。此时res左右两头的字符为str[i]，然后继续根据str[i+1..j]和矩阵dp来设置res的中间部分
    1.如果str[i..j]中 str[i]==str[j]，那么str[i..j]变成回文串的最终结果=str[i]+str[i+1,j-1]变成回文串的结果+str[j]
    2.如果str[i..j]中str[i]!=str[j]看dp[i][j-1]和dp[i+1][j]哪个小，如果dp[i][j-1]更小，那么str[i..j]变成回文串的结果=str[j]+dp[i][j-1]变成回文串的结果+str[j]，然后继续根据str[i..j-1]和矩阵dp来设置res的中间部分
    否则str[i..j]变成回文串的结果=str[i]+dp[i+1][j]变成回文串的结果+str[i]，然后继续根据str[i+1..j]和矩阵dp来设置res的中间部分


》进阶回文字符串：c-p269.2
    给定一个字符串str，再给定一个最长回文子序列字符串strlps，请返回在添加字符最少的情况下，让str整体都是回文字符串的一种结果，进阶问题比原问题多了一个参数，请做到时间复杂度比原问题的实现低

    举例：str=A1B21C strlps=121  返回AC1B2B1CA 或者 CA1B2B1AC 总之，只要是添加的字符数最少，只返回一种结果即可。

    求解的时间复杂度可以加速到O(n),如果str的长度为n，strlps的长度为m，则整体回文的长度应该是2n-m. 提供的解法类似于”剥洋葱“的过程：
    以str=A1BC22DE1F，strlps=1221 举例
    洋葱第0层由strlps[0]和strlps[m-1]组成，即1...1 从str最左侧开始找字符'1'，发现A是第0个字符，'1'是str第1个字符，所以左侧第0层洋葱圈外的部分为"A", 记为leftPart。从str最右侧开始找字符'1'，发现右侧第0层洋葱圈外的部分是rightPart。把（leftPart+rightPart逆序）复制到res左侧未设值的部分，把（rightPart+leftPart逆序）复制到res右侧未设值的部分，即res变为”AF...FA“把洋葱的第0层复制进res的左右两侧未设值的部分，即res=AF1..1FA，至此，洋葱第0层被剥掉。洋葱的第1层由strlps[1]和strlps[m-2]组成，然后继续。。。
    整个过程就是不断找洋葱圈的左部分和有部分，把（leftPart+rightPart逆序）复制到res左侧未设值的部分，把（rightPart+leftPart逆序）复制到res右侧未设值的部分，洋葱剥完则过程结束




```


## 如果面试题是按照一定要求摆放若干个数字，则可以先求出这些数字所有的排列，然后一一判断每个排列是不是满足题目给定的要求

#排列组合问题
```
》给一个字典序排列，找到这个排列中所有元素组成的下一个字典序排列：31
    1,2,3 → 1,3,2
    3,2,1 → 1,2,3
    1,1,5 → 1,5,1

    （以 1243为例）从后往前，找到第一个减小的数字x(2),再从x往后找，找到最后一个大于x的数字y(3)，交换x和y(1342)，
    然后翻转新的x后面的序列为顺序（1324），即为下一个字典序（因为交换掉以后，x后面是逆序的，大值的权值高，此时x已经变大了，
    后面的序列的值应该是最小的）。   该题口诀：“从后往前找减小，从前往后找增大，排成顺序找到它”

    同理，如果要找上一个字典序(以 12435为例)，则先找到增大的数字(4)，然后找到减小的最后一个数字(3)，交换(12345)，然后后面的排成逆序(12354)

    又如 158476531

    从后往前找到第一个下降的数为4，从4的后面往后找最后一个大于4的数字，找到5
    交换4，5： 158 5 76 4 31
    让交换的5后面的序列翻转成顺序：158513467

    因为要找下一个字典序，就找的是比他大一点点的一种数字组合，如 1,3,2，下一个就是2,3,1，为什么要从后往前找，因为先动
    的肯定是权值小的位。x与权值最小的比他大的数字交换，能保证带来的增大幅度是最小的。

    这种做法对于求下一个字典序，上一个字典序的题都是通用的。，不论其元素是数字，字母，字典是不是特定的。
    # 记住这种方法

    如果要求上一个字典序，则从后往前找第一个上升的，然后从该数开始找后面最后一个比它小的，交换，然后让后面的都是逆序
    151237，找到 5，他后面最后一个比它小的是3
    交换为：131257，让3后面为逆序：137521，则151237的上一个字典序是137521

    ## 就地翻转数组的代码也要记住 (//要交换的每两个值的下标都满足和为sum)



》给一个数组，求以该数组中所有元素组成的全排列：46
    使用trackback， 函数签名：trackback(原数组，当前排列已经有的元素索引set, 答案序列ans)
    当ans序列长度等于数组长度时，记录当前ans
    其中的for循环原型：
        for(int i=0;i<len;i++){ //从头到尾遍历
            if(set.contains(i)) continue;  //当该元素就在本次的序列中，跳过
            set.add(i); //不在就加入
            ans.add(i);
            trackback(nums, set);  //继续递归
            set.remove(i);  //回溯，删除i
            ans.remove(i);
        }


》给出一个非负整数的数组，组合它们使其成为能组成的最大数字：179
    这里直接用排序的工具Comparator，重写对于数组的排序算法，对于两个数a和b
    如果ab大于ba，则a排在b的前面，直接将nums进行这样的排序，可得答案
    需要特殊处理的是，如果数组中全是0，则直接返回0


》集(1、2、3……，n]共包含n!独特的排列。将所有排列按顺序列出并标注，得到n = 3的序列如下:：60
    "123"
    "132"
    "213"
    "231"
    "312"
    "321"
    给定n和k，返回第k个排列序列。

    n从1到9，k从1到n!

    以数字x开头个数有 (n-1)!个 再里面以数字y开头的个数有 (n-2)!个。。。

    将9个数字依次放入一个list 
    (k/(n-1)!)是该排列的第一个数字,令为i，在list中顺序选出第i个数字，选出后，从list中去掉该数字
    让k = k%((n-1)) , n=n-1 重复上面的过程

        List<Integer> list = new ArrayList<>();
        for(int i=1;i<10;i++)
            list.add(i);
        int count = n;
        //为了顺序从0开始，k先-1
        k = k-1;
        while(count>0){
            int num = k/factorial(n-1); //factorial是计算阶乘的函数
            builder.append(list.get(num));
            //每加入一个数，就从list中删掉该数
            list.remove(num);
            k = k%factorial(n-1);
            n = n-1;
            count--;
        }


》给定两个整数n和k，返回1…n中任意k个数的不同的组合。：77
    简单的回退递归，传入的参数有start的（前面的不要）。
    void trackBack(int start, List<Integer> preList, int n, int k){
        if(preList.size()==k){
            List<Integer> cclone = new ArrayList(preList);
            res.add(cclone);
            return;
        }

        for(int i=start; i<=n; i++){
            preList.add(i);
            trackBack(i+1, preList, n, k);
            preList.remove(preList.size()-1);
        }
    }


》字符串的排列：j38-p197
    输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
    典型的回退递归，trackback，要加一个flag表征已经加入过的字符,当答案字符串中长度等于原串长度就找到了一个答案。其他的没什么不同之处，有点区别的是该答案集中要求不能有重复的，而且答案排列要按序排列，
    因此，先把所有可能的答案加入到HashSet中(去重)，然后用该set初始化一个ArrayList，再把该list排序即可


》字符串的组合：j38-p199
    如abc，它们的组合有：a、b、c、ab、ac、bc、abc
    也使用回退递归，更新每次遍历的起点start，当遍历到某个字符时直接把当前遍历到的路径加入答案集


》输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方形的8个顶点上，使得正方体三组相对的面上的4个顶点的和都相等：j38-p200

    这相当于先得到a1,a2,a3,a4,a5,a6,a7,a8这8个数字的所有排列，然后判断有没有某个排列符合题目给定的条件，即同时满足下面三个等式
    a1+a2+a3+a4=a5+a6+a7+a8, a1+a3+a5+a7=a2+a4+a6+a8, a1+a2+a5+a6=a3+a4+a7+a8
    把所有的排列的出来，对于任意一个排列x, a1相当于x[0]，把上面的ai变成 x[i-1] 求上述三个等式在该排列下是否都成立
    若成立，则是一种答案。



》灰色代码是一个二进制数字系统，其中两个连续的值只相差一位。：89
    给定一个非负整数n表示代码中的总比特数，打印灰色代码序列。灰色代码序列必须以0开头。

    对于给定的n，灰色代码序列可能不是唯一定义的。
    例如，[0,2,3,1]也是一个有效的灰色代码序列。

    说明:我们定义了从0开始的灰色代码序列。
    一个n的灰度编码序列大小为2n，当n = 0时，大小为20 = 1。
    因此，对于n = 0，灰度编码序列为[0]。

    灰色代码总数是2^n个，先从全0开始。对任意一个序列，遍历其每一位，把该位取反，然后查看结果集中是否有该序列，若没有则加入结果集，把该新序列更新为要遍历的序列，否则继续遍历该序列。直到结果集中的总数为2^n个，所有序列都已求得


》给定一组可能包含重复数、数字的整数，返回所有可能的子集(幂集)。：90
    注意:解决方案集不能包含重复的子集。

    带start的trackBack



》给定一个只包含数字的字符串，通过返回所有可能的有效IP地址组合来还原它。：93
    Input: "25525511135"
    Output: ["255.255.11.135", "255.255.111.35"]
    使用带start的trackBack，因为是ip地址，所以每个数字是0-255，最少一位最多3位。

    》
    void trackBack(int start, String s, List curList, int cnt){
        if(cnt>4){  //已经攒了4个以上数，肯定不对
            return;
        }
        if(cnt==4&& start!=s.length()){  //攒了4个数，但是没到头，不对
            return;
        }
        if(start==s.length() && cnt==4){  //攒了4个数，且到头了，是一个答案
            addOneAns(curList);
            return;
        }
        for(int i=start;i<3+start;i++){  //因为是0-255,所以每个数字最少1位最多3位
            if(i+1>s.length()) break; //当超过长度时就不要了
            String sub = s.substring(start, i+1);
            if(isValidNum(sub)){ 
                //如何判断是有效数字：
                //如果开头是0，但整个数字又不是0，则该数字不行，如010，会被解读为10，但实际上不能丢掉任何一位数
                //如果是00，这种也不合法，如果是0，那么只能是单纯一个0。
                //否则该数必须是0-255范围之内
                curList.add(Integer.valueOf(sub));
                trackBack(i+1, s, curList, cnt+1);
                curList.remove(curList.size()-1);
            }
        }
    }



》把数组排成最小的数：j45-p227
    输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
    
    》最简单的办法就是求出所有排列，然后求其中最小的。

    》更好的办法是对数组进行排序 例如对于两个数字 m和n，若mn< nm 则m应该排在n的前面，把数组中的数存入list，根据重写Comparator很容易实现对list的重排序，
    根据上述规则重排序后，将其按顺序组合成字符串即为答案

    在定义了新的排序规则后，如何证明该规则是有效的？要证明1.自反性，2.对称性，3.传递性， 证明过程见 j-p229


》即n个a和m个z组成的字符串。找出第k个单词是什么，没有则返回-1：b15
    这个题能想到组合数就好办多了，C(a,b):从a个不同的物品中取出b个，不考虑顺序的取法
    n个a和m个b，相当于一共有m+n个空位，从中取出n个来放置a，则取法一共有C(m+n,n)种，因此，组合的个数一共有C(m+n,n)

    思路：
    1.假设第一个字符为a，则剩下n-1个'a'和m个'z'组成的子序列只能构成count(n-1+m,n-1)个单词，且是字典中前count(n-1+m,n-1)个单词。
    2.比较k和count(n-1+m,n-1)，若k小，说明k是前count(n-1+m,n-1)个单词，则第一个字符必为'a'。子问题化为在子序列(n-1个'a'和m个'z')找到第k个单词
    3.若k大，则说明第一个字符必为'z',单词是以'z'开头的单词中的第k-count(n-1+m,n-1)个。子问题化为在子序列(n个'a'和m-1个'z')找到第k-count(n+m-1,m-1)个单词。

    eg:n=2,m=2,k=5
    假设第一个字符为a,则剩下1个a,2个z只能构成3个单词，且是字典中前3个单词(aamm,amam,amma)
    k>3，则第一个字符必为z。原问题化为在n=2,m=1,k=2，即在剩下2个a，1个z中找到第2个单词
    StringBuilder builder = new StringBuilder();
        while(n>0 && m>0){
            long count = 1;
            for (int i = 0; i < n - 1; i++) {//求组合数c(m+n-1, n-1)
                count *= n - 1 + m - i;
                count /= (i + 1);
                if (count > k)break;//防止越界。count>k就可以退出计算了
            }
            if(count>=k){
                n--;
                builder.append('a');
                //问题缩减为 n-1个a和m个z 中找第k大
            }else{
                m--;
                builder.append('z');
                k -= count; //问题缩减为 n-1个a和m个z 中找第k-count大
            }
        }
        //循环结束后，剩余子序列只存在"aa..aaa" 或 "zz..zzz"1种情况,即n和m有一个用完了，有一个没用完,没用完的全加在后面即可
        //到这一步，范围一定缩小到一个序列了，k=1即是找到剩下序列的第一个序列，即，如果不是，说明就不在这个范围内
        if (k != 1) {//
            System.out.println(-1);;
            return;
        }
        if(n>0){
            for(int i=0;i<n;i++){
                builder.append('a');
            }
        }else if(m>0){
            for(int i=0;i<m;i++){
                builder.append('z');
            }
        }
        System.out.println(builder.toString());





```


## 两种trackback回退递归的使用情景：
    1. 传入start，不需要flag：答案序列中的顺序与原串中的顺序保持不变，即会出现 abc： ab，ac，bc（不会出现ca，cb这种），可以视为组合求法
    2. 不传入start，每次都从头开始，但传入flag表征已经加入答案的元素，避免再用，即会出现abc,ab，ac，ba，bc，ca，cb，可以视为排列求法




#栈和队列和递归问题
```
》如何用两个栈实现一个队列： j9-p68
    用两个栈，一个用来入队，一个用来出队，入队时，压栈stk1；出队时，如果stk2不空，则从stk2弹栈，否则先把stk1中的元素倒入stk2中在从stk2弹栈
    
》如何用两个队列实现一个栈  j9-p71
    队列q1和队列q2，压栈时，往不空的队列中入队，（若都空，则默认往q1中入队）。弹栈时，出队不空的队列中的元素，每出队一个元素，用tmp暂存，如果此时队列还不为空，则把它放入另一个队列，继续出队，直到出队一个元素后队空，则返回该元素，且该元素不入另一个队列



》读与计数，对于1，读取为，1个1：11， ：38
    1：读取为 1个1：11
    11：读取为：2个1：21
    21：读取为：1个2，1个1： 1211
    1211：读取为：1个1，1个2，2个1： 111221

    用两个队列来做,分别存放本次和下次的读取顺序，
    记录一个count，一个item，每次出队一个数，更新item
    如果当前队头的数字等于item，次数+1，直到不等
    另一个队列放入count和item


》以数组的形式给出一个后缀表达式，求该值：150
    后缀表达式，直接用栈即可：遇数字压栈，遇符号弹栈两个，计算后结果再压栈


》输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。：j31-p168
假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

    直观想法就是模拟这个过程，可以这么做：
    用一个指针x保持当前要弹出的数，所以这个数是从第二个序列下标为0开始往后走的

    如果当前要弹出的数和栈顶元素不等，则入栈，直到相等，则弹栈，然后x往后走一位，继续判断要弹出的数和栈顶元素是否相等，等则弹栈。 直到不等后，继续入栈。当数字全部压入，且要弹出的数和栈顶元素不等时，则为false。如果数字全部压入，且全部弹出了，则为true


》如何仅用递归函数和栈操作逆序一个栈：c-p8

    需要做两个递归函数，第一个函数递归获得当前栈的栈底元素（栈底元素出栈，上面的都不动）
    第二个函数逆序一个栈，只需要做3件事：
        1. 调用第一个函数，得到当前栈的栈底元素
        2. 递归该函数
        3. 将刚才的元素压入栈


》用一个栈实现另一个栈的排序：c-p13
    一个栈中的元素为整型，现想将栈从顶到底按从大到小的顺序排列，只可以额外申请一个栈，只允许申请额外的变量，不允许申请额外的数据结构

    将要排序的栈记为stack，辅助栈记为help，在stack上执行pop操作，弹出的元素记为cur
        如果cur小于或等于help中的栈顶元素，，或者help为空，直接将cur压入help。
        如果cur大于help栈顶元素，则将help的元素逐一弹出，逐一压入stack，直到cur小于或等于help栈顶元素，或者help为空，再将cur压入help中。
    一直执行上述操作，直到stack中全部元素压入help中，最后再将help中所有元素逐一压入stack，完成排序。

    如果要求的是栈从顶到底从小到大，则把上述操作的条件中大于和小于互换即可(等于号不换)

    例，stack：2，1，2，3 ,4 左顶右底

        stack            help
        1,2,3,4           2
        2,3,4            1,2
        1,3,4            2,2
        3,4              1,2,2
        2,2,1,4          3
        4                1,2,2,3
        3,2,2,1          4
                         1,2,2,3,4
        4,3,2,2,1




用栈解决汉诺塔问题：c-p14
    汉诺塔的要求是，任何时刻一个盘子上面都不能有比它大的盘子
    最左边的塔不能直接跳到最右边，必须经过中间杆子，打印最优移动过程和最优总步数
    例如对于
    对于每个杆子，按照上--下的顺序, 有的中间步骤就省略了，只保留关键步骤

    左           中          右
    1,2,3        
    2,3          1
    3           2           1
    3                      1,2
                1,3          2
    1           3            2
                1,2,3
    2            3           1
    1,2                      3
                 2           1,3
    1           2            3
                         1,2,3
    可以看成汉诺塔要做的就是想尽一切办法让最下面的盘往右挪

    其实对于每一层的移动，步骤都是类似的。
    》方法一：递归：
        假设要移动第1层，把它移到中，再移到右
        .....移动第二层2，则1在右，把2移到中，再把1移到中，再把1移到左，再把2移到右，再把1移到中，再把1移到右
        移动3，则1到2在右。移3到中，移1到中，移1到左，移2到中，移1到中，移1到右，移2到左，移1到中，移1到左，移3到右，移1到中，移1到右，移2到中，移1到中，移1到左，移2到右，移1到中，移1到右。
        假设当前左边要移动第n层，那么1到n-1层一定都在右，需要做的是，先把n移到中，借它为跳板，把1到n-1移回左，然后把n移到右，然后再把1到n-1移回右
        因此，把1到n-1挪到右用了x步，则把1到n挪到右用如下：
        把n挪到中，1步；把1到n-1经过中间挪回左边，x步；把n挪到右，1步； 把1到n-1经过中间挪回右，x步。加上本来的1到n-1挪到右的x步，因此，
        若1到n-1挪到右用x步，则1到n挪到右用3x+2步。显然如果要打印过程则可以用递归,如果只是要求总步数，直接用动态规划套递推公式即可

    》方法二：非递归，借助栈：
        使用栈模拟，左中右三个地点都是栈，一个动作能发生的先决条件是不违反小压大原则
        还有一个原则是相邻不可逆原则，即：如果上一步的动作是L->M，，那么这一步必不可能是M->L,否则就不可能是最小步数
        因此非递归的核心结论：
        1.游戏的第一个动作一定是L->M
        2.在走出最小步数过程中的任何时刻，四个动作中只有一个动作不违反小压大原则和相邻不可逆原则，其他三个动作一定会违反。
        p18有证明

        为了统一操作，先将3个栈都压入MAX值，这样不影响过程和结果，而且不用单独处理栈空的情况



》汉诺塔问题：c-p206.1
    给一个整数n，代表汉诺塔游戏从小到大放置的n个圆盘，假设开始时所有的圆盘都放在左边的柱子上，想按照规则把所有圆盘移到右边的柱子上，实现函数打印最优移动轨迹
    假设有from柱子，mid柱子和to柱子，都在from的圆盘1到i完全移动到to，最优过程为：
    步骤1为圆盘1到i-1从from移动到mid
    步骤2为单独把圆盘i从from移动到to
    步骤3为把圆盘1到i-1从mid移动到to，如果圆盘只有1个，直接把这个圆盘从from移动到to即可

    这个看起来和 c-p14 不一样，左柱子上的可以直接到右柱子而不用经过中间
    打印最优移动轨迹
    public void func(int n, String from, String mid, String to){
        if(n==1){
            System.out.println("move from " + from + " to " + to);
        }else{
            //把上面的1到n-1从左移动到中
            func(n-1. from, to, mid);
            //把n从左移动到右
            func(1, from mid, to);
            //把1到n-1从中移动到右
            from(n-1, mid, from, to);
        }
    }



》汉诺塔进阶：c-p206.2
    给定一个整型数组arr，其中只含有1，2，3代表所有圆盘目前的状态，1代表左柱，2代表中柱，3代表右柱，arr[i]的值代表第i+1个圆盘的位置，比如arr[3,3,2,1]代表第1个圆盘在右柱上，第2个圆盘在右柱上，第3个圆盘在中柱上，第4个圆盘在左柱上。如果arr代表的是最优移动轨迹过程中出现的状态，返回arr这种状态是最优移动轨迹中的第几个状态。如果arr不是最优移动轨迹过程中出现的状态，则返回-1。

    首先求都在from柱子上的圆盘1到i，如果都移动到to上的最少步骤数，假设为S(i),根据上面的步骤，S(i)=步骤1的步骤总数+1+步骤3的步骤总数=S(i-1)+1+S(i-1) S(1)=1，
    可得到S(i)=2^(i-1)  （步骤1，3的解释见上题）

    对于数组arr来说，arr[N-1]表示最大圆盘N在哪个柱子上，情况有以下三种：
    1.圆盘n在左柱子上，说明步骤1或者没有完成，或者已经完成，需要考察圆盘1到n-1的状况
    2.圆盘n在右柱子上，说明步骤1已经完成，起码走完了2^(n-1)-1步，步骤2也已经完成，起码又走了1步，所以当前状况是最优步骤的2^(n-1)步，剩下的步骤怎么确定还得继续考察圆盘1到n-1的状况
    3.圆盘n在中柱上，这是不可能的，最优步骤中不可能让圆盘n处在中柱上，直接返回-1。

    所以整个过程可以总结为：对于圆盘1到i来说，如果目标从from到to，那么情况有3种：
    1.圆盘i在from上，需要继续考察圆盘1到i-1的状况，圆盘1到i-1的目标为从from到mid
    2.圆盘i在to上，说明起码走完了2^（i-1）步，剩下的步骤怎么确定还得继续考察圆盘1到i-1的状况，圆盘1到i-1的目标为从mid到to
    3.圆盘i在mid上，直接返回-1


》表达式得到期望结果的组成总数：c-p228
    给定一个只由0(假)、1（真）、&（逻辑与）、|（逻辑或）、^（异或）五种字符组成的字符串express，再给定一个布尔值desired。返回express能有多少种组合方式，可以达到desired的结果。

    例如express = 1^0|0|1 desired=false
    只有1^((0|0)|1) 和 1^(0|(0|1))的组合可以得到false，返回2
    express=1，desired=false
    无组合可得到false，返回0

    首先判断表达式是否合法，合法的表达式要求以下3点：
    1.表达式的长度必须是奇数
    2.表达式下标的偶数位置的字符一定是0或者1
    3.表达式下标奇数位置的字符一定是&或|或^

    遍历字符串，每遍历到一个逻辑运算符(&，|，^)，就会把原字符串分成两部分，，再计算这两部分各自要得到一个布尔值的种数
    例如，逻辑运算符是&，目标是true，那就计算它两边各自能成为true的总数，然后乘起来。
    用map保存每个字符串和desired对应的值（双map）,使用“字符串+desired”作为key，因为二者没有重复的地方，所以可以直接连起来


》b38：
一串数字，用五个星号分隔成六段，每段的数值大小不可以大于600，打印出所有可能的结果

    使用trackback，这一题再次提个醒，不是所有的trackback里都要用到循环的，比如这道题就没用。要视具体情况而定。

    直接使用递归，每次要判断当前数字是不是满足条件(包括前导0的判断和数字值的判断)，如果满足再把当前数字加入list往下传，不满足就不传。递归结束后要remove本次的数字，方便下次数字添加



》排成一条线的纸牌博弈问题：c-p233
    给定一个整型数组arr，代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都很聪明，请返回最后胜利者的分数

    例如arr=[1,2,100,4]
    开始时玩家A只能拿走1或4，若A拿走1，则排列变为[2,100,4],接下来B可以拿走2或4，然后继续轮到A，如果开始时A先拿走4，则排列变为[1,2,100]，接下来B可以拿走1或100，然后继续轮到A，A作为聪明的人不会先拿4，因为拿走4后B会拿走100.所以玩家A会先拿1，让排列变成[2,100,4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101.所以返回101。

    arr=[1,100,2],开始时玩家A不管先拿1还是2，B作为聪明人，都会把100拿走，B会获胜，分数为100，所以返回100

    递归的方法。定义递归函数f(i,j),表示如果arr[i..j]这个排列上的纸牌被聪明人先拿，最终能得到什么分数。定义递归函数s(i,j)，表示如果arr[i..j]这个排列上的纸牌被聪明人后拿，最终能获得什么分数。

    首先分析f(i..j)，具体过程如下：
    1.如果i==j，即arr[i..j]上只剩一张纸牌，当然会被先拿纸牌的人拿走，所以返回arr[i]
    2.如果i!=j, 当前拿牌的人有两种选择，要么拿走arr[i],要么拿走arr[j]。如果拿走arr[i],那么排列将剩下arr[i+1,j]。对当前的玩家来说，面对arr[i+1..j]排列的纸牌，他成了后拿的人，所以后续他能获得的分数为s(i+1,j)，如果先拿走arr[j]，那么排列剩下arr[i..j-1]。面对arr[i..j-1]，他成了后拿的人，为了后续他能获得的分数为s(i,j-1)，作为聪明人，必然会在两种决策中选最优的，所以返回max{arr[i]+s(i+1,j), arr[j]+s(i,j-1)}。

    然后分析s(i,j)，具体过程如下：
    1.如果j==i，即arr[i..j]只剩一张纸牌，后拿纸牌的人必然什么也得不到。返回0
    2.如果i!=j。根据函数s的定义，玩家的对手会先拿牌，对手要么拿走arr[i]，要么拿走arr[j]。如果对手拿走arr[i]，那么排列将剩下arr[i+1..j]，然后轮到玩家先拿。如果对手拿走arr[j]，那么排列将剩下arr[i..j-1],然后轮到玩家先拿。对手也是聪明的人，所以必然会把最差的情况留给玩家。所以返回min{f(i+1,j), f(i,j-1)}

    》
    根据递归的方法，很明显可以使用动态规划来改进：
    i依赖i+1，j依赖j-1，所以i要倒序，j要正序
    f[i][j]=Math.max(arr[i]+s[i+1][j], arr[j]+s[i][j-1]);
    s[i][j]=Math.min(f[i+1][j], f[i][j-1]);








```


## 普遍看来，动态规划是要把所有的可能性都记录下来，然后取最终的那个答案

#动态规划问题
```
》对一个数组，取若干个数要求值最大，且取的值不能相邻，求能取得的最大值：198
    遍历数组
    对于遍历到的下标为i的数x来说，include表示截止到x，包含x的最大值，exclude表示截止到x不包含x的最大值
    则对下一个数字y（下标为i+1）来说，include（截止到y，包含y的最大值）=exclude+num[i+1]  (截止到x不包含x的最大值+y)
                  exclude（截止到y，不包含y的最大值）=Math.max ( 前一个include(截止到x包含x的最大值) ,前一个exclude(截止到x不包含x的最大值)
    遍历完后，返回include和exclude的大值即可


》对于一个数组，假设头尾是相邻的，取若干个数要求值最大，且取的值不能相邻，求能取得的最大值：213
    和上面的唯一区别是头尾相邻，由于第一个数和最后一个数是相邻的，所以它们不可能同时出现，所以把原数组分成两种情况使用上面的算法
    即对 num[0...len-2] 和 num[1...len-1] 用上面198的算法，取两个结果中的最大值


》给定一个数组，初始位置是数组的第一个索引。数组中的每个元素表示该位置的最大跳转长度。确定是否能够达到最后一个索引：55
    boolean dp[i] 为是否能跳到索引为i的位置上
    dp[0] = true;   
    dp[i] = (dp[j]==true && i <= j+nums[j])  j=0到i-1，只要有一个能到，那就是能到
    看dp[len-1]是否为true


》在一个棋盘上，左上角的机器人到达右下角的可能走法数，机器人只能右走和下走：62
    dp[i][j]是到达(i,j)的可能走法数
    dp[i][j] = dp[i-1][j] + dp[i][j-1] //每个方格能从它的上方和左方过来
    dp[0][j] = dp[0][j-1];  dp[i][0] = dp[i-1][0]; //左边界上只能由它的上方过来，上边界上只能由它的左方过来


》给定一个m x n的非负数网格，找到一条从左上角到右下角的路径，使其路径上所有数字的和最小化。每个方格能从它的上方和左方过来：64，c-p187
    用和机器人走方阵类似的方法，
    不过这次用矩阵保存的变成能到达本单元格的最小耗费
    每个单元格的耗费 = Math.min (它左边单元格的最小耗费， 它上边单元格的最小耗费) + 它自己的耗费
    dp[i][j] = num[i][j]+Math.min(dp[i-1][j], dp[i][j-1]);
    由于只和上面的和左面的有关，所以可以优化为一维数组
    j之前的都是这一层的，j及j之后的都是上一层的
    dp[j] = m[i][j]+Math.min(dp[j], dp[j-1]);
    优化空间复杂度为O(col)

    # 如果类似本题这种需要二维表的动态规划题目，最终目的是想求最优解的具体路径，往往需要完整的动态规划表，但如果只是想求得最优解的值，则可以使用空间压缩的方法。因为空间压缩的方法是滚动更新的，会覆盖之前求解的值，让求解轨迹变得不可回溯。


》爬梯子/台阶，每次只能爬1或2阶，有多少种方法到顶？：70    
    最典型最简单的dp问题
    到达一阶只能从它的上一个或者上两个而来，如果paths[n]是到达第n层的方法数
    path[1] = 1;
    path[2] = 2; //两个1或一个2
    则 paths[n] = paths[n-1]+paths[n-2];


》共有N个台阶，每次可网上爬2的整数次幂，问共有多少种方法爬上去：b19
    n最大为1000，也就是说最大只有2的10次方，为了防止溢出，可将输出对10^9 + 3取模
    dp[i] 为爬上i层有多少种爬法
    对于层数为i时，
        当i为2的幂次时，dp[i] = 1 + Σdp[i-xx]  (xx为所有小于i的2的幂次数,1表示一步到该层)
        当i不为2的幂次时，dp[i] = Σdp[i-xx]  (xx为所有小于i的2的幂次数)

    可能会溢出，所以每次加的时候，把加数对10^9 + 3取模，且然后把和再取一次模




》给两个单词，找到使得单词1变成单词2的最小步数：72
    有3种操作办法：
        插入一个字母
        删除一个字母
        替换一个字母
    用f[i][j]表示word1的前i个字母变成word2的前j个字母的最小花费 
    #注意的是word1的第i个字母是word1[i-1]; word2的第j个字母是word2[j-1]
    case1：word1[i-1]==word2[j-1] 则 f[i][j]=f[i-1][j-1], 因为 word1[i-1]->word2[j-1]的转换没有花费，所以就等于前面的花费
    case2：word1[i-1]!=word2[j-1] 则我们必须插入，删除或替换，看哪种操作花费更小
        f[i][j] = 1 + min{ f[i][j-1], f[i-1][j], f[i-1][j-1] }  //这里假设三种操作的花费都是1
        //如果每种操作花费不同，则：f[i][j] = min{ f[i][j-1]+insertCost, f[i-1][j]+delCost, f[i-1][j-1]+replaceCost } 

        》f[i][j-1]代表插入操作，
        当要用插入操作使得word1前i字母变成word2的前j字母，那就是word1的前i字母就是word2的前j-1字母，然后再在i后插入一个word2[j]
        》f[i][j-1]代表删除操作，
        当要用删除操作使得word1的前i字母变成word2的前j字母，那就是word1的前i-1字母就是word2的前j字母，然后再把word[i]删了就行
        》f[i-1][j-1]代表替换操作，
        当要用替换操作使得word1前i字母变成word2的前j字母，那就是word1的前i-1字母就是word2的前j-1字母，然后再把word1[i]替换成word2[j]

        基础情况:
        f[0][k] = f[k][0] = k
        word1的前0个字母要变成word2前k个字母，直接增插入k个
        word1的前k个字母要变成word2前0个字母，直接删除k个

        则最终的答案是 f[word1.len][word2.len]


》最小编辑代价：c-p217
    给定两个字符串str1和str2，再给定3个整数ic，dc，rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价
    例如str1="abc", str2="adc" ic=5,dc=3,rc=2
    从abc编辑成adc，把b替换成d是代价最小的，所以返回2
    例如str1="abc", str2="adc" ic=5,dc=3,rc=100
    先删除b，然后插入d是代价最小的，返回8

    dp=int[m+1][n+1]
    dp[i][j]是把str1[0..i-1]变成str2[0..j-1]的最小代价 （注意，这里因为要讨论空的问题，所以i对应str1[0..i-1]）

    dp[0][0]=0  //空变成空，花费0

    dp[0][j]=dp[0][j-1]+ic;
    dp[i][0]=dp[i-1][0]+dc;

    //要使用替换的话，先把str1[i-1]变成str2[j-1](代价为0或rc)，然后把str1[0..i-2]变成str2[0..j-2](代价dp[i-1][j-1])
    若str1[i-1]==str2[j-1]：
        替换：dp[i][j]1=dp[i-1][j-1]  //由于str1[i]==str2[j]，所以最好一个字符不用替换
    若str1[i]!=str2[j]:
        替换：dp[i][j]1=dp[i-1][j-1]+rc 

    插入：dp[i][j]2=dp[i][j-1]+ic   //要使用插入的话，先把str1[0..i-1]变成str2[0...j-2],然后再插入str2[j-1](代价dp[i][j-1]+ic)
    删除：dp[i][j]3=dp[i-1][j]+dc   //要使用删除的的话，先把str1[0..i-2]变成str2[0..j-1],然后再删除str1[i-1](代价dp[i-1][j]+dc)
    dp[i][j] = min(dp[i][j]1, dp[i][j]2, dp[i][j]3);






》求斐波那契数列第n项，和爬梯子一样，典型的动态规划问题：j10-p74
    dp[i] = dp[i-1]+dp[i-2];


》我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形，请问用8个2x1的小矩形无重复的覆盖2x8的大矩形总共有多少种方法？ j-p79
    先把2x8的覆盖方法记为f(8)，用第一个2x1的小矩形去覆盖大矩形的最左边有两种选择：竖着放或者横着放。当竖着放时，右边还剩2x7的区域，这种情形下的覆盖方法记为f(7)，接下来考虑横放的情况，当2x1的小矩形横着放在左上角时，左下角必须也横着放一个2x1的小矩形，而在右边还剩2x6的区域，这种情形下覆盖方法记为f(6)，因此f(8)=f(6)+f(7)。此时可以看出，仍然是斐波那契数列


》给定一个非空字符串s和一个包含非空单词列表的dictionary wordDict，确定是否可以将s分割为一个由一个或多个字典单词组成的空格分隔的序列。:139
    考虑动态规划，dp[i]表示s的前i个字符是否能匹配（匹配指能拆成字典中的单词组合）
    双重循环i，j。检查s[j...i], 如果dp[j-1]匹配，且字典中含有s[j...i]，则dp[i]匹配 对于每一个i，j要试从0到i，
    只要有一个满足字典中含有s[j...i],且dp[j-1]匹配或j为0，那dp[i]就匹配，最后返回dp[s.len-1]
        dp[i] = dict.contains(s.sub(j, i+1)) && (j==0 || dp[j-1]==true)?true:false;


》剪绳子：长为m的绳子剪成若干段，至少剪一刀，每段绳子记为k0,k1,k2...km，问k0*k1*k2...*km的最大可能乘积是多少：j14-p96
    //动态规划，对长为n的绳子来说，剪一刀就变成了长为 i 和 n-i 的两根绳子(只需考虑第一根绳子长度)
    设dp[i]是剪长度为i的绳子的最大乘积，j是剪一刀后第一段绳子的长度，则i-j是第二段绳子长度，这两部分都可以剪或不剪，因此有4种可能的组合
    dp[i] = max(dp[j] * dp[i-j], j* (i-j), dp[j]* (i-j), j* dp[i-j]);
    但对于剪后的两段绳子 j和 i-j来说，都有可能存在不剪的情况，如对于i=5来说，剪一刀即可，即2和3，但对2和3不能再剪
    public int cutRope(int n){
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3;i<n+1;i++){
            for(int j=1;j<i;j++){
                //第一段和第二段都继续剪
                dp[i] = Math.max(dp[j] * dp[i-j], dp[i]);
                //第一段和第二段都不剪
                dp[i] = Math.max(dp[i], j*(i-j));
                //第一段剪第二段不减
                dp[i] = Math.max(dp[i], dp[j]*(i-j));
                //第一段不剪第二段剪
                dp[i] = Math.max(dp[i], j*dp[i-j]);
            }
        }
        return dp[n];
    }

    该题还有贪心算法。


》买卖股票，卖了后的一天不能立即买，要冻结一天，求能获得的最大收益：309

    对于一个股票，可以有买，卖，啥也不干的做法，记录上一个买的价格，如果当前价格高于买入的价格并且已经买了，才能卖
    回退递归太慢了，不能接受。

    这道题可以用动态规划的思路解决。但是一开始想的时候总是抽象不出状态转移方程来，之后看到了一种用状态机的思路，
    觉得很清晰，特此拿来分享，先看如下状态转移图：

    S0 代表没有买入的等待状态，s0可以由s2和s0得来
    S1 代表买入后等待卖出的状态，s1可以由s1和s0得来
    S2 代表卖出后的状态（冻结状态）（s2只能由s1得来，且s2只能转到s0）且冻结状态只有一天

    S2与S0的区别是：因为题目要求卖出后必须cooldown一轮，所以卖出进入S2后，必须再进入S0这个等待买入的状态，这一状态转换代表cooldown一轮

    （这里要明确一点，第i天的状态只能由第i-1天的状态推得，而与更前面的无关，因为日子是一天天过的）
    这里我们把状态分成了三个，根据每个状态的指向，我们可以得出下面的状态转移方程：

    s0[i] = max(s0[i-1], s2[i-1])
    s1[i] = max(s1[i-1], s0[i-1] - price[i])
    s2[i] = s1[i-1] + price[i]
    这样就清晰了很多。
    sx[i]表示第i天保持x状态的最大收益

    s0[0]=0, s2[0]=0, s1[0]=-price[0](买入prices[0]，收益是-price[0])

    最终的结果状态可能是s0，也可能是s2，但不会是s1
    即结果为max(s0[n-1], s2[n-1])



》扎气球，给定n个气球，索引从0到n-1。每个气球上都绘有一个数字。要求你把所有的气球都吹破。如果你的气球爆了，你会得到num[左边]*num[i]*num[右边]  
  的硬币。这里左、右是i的邻指标，扎破i后，左、右变成邻指标。找到你能收集到的最多的硬币。：312
    Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
             coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
    对于气球0。。。。n-1
    考虑扎区间[start, end]
    如果最后扎第i个，那么
    在结束之前，已经扎掉了[start, i-1] 和 [i+1, end] 的所有气球
    现在这个分治递归区间里,只存在三个元素即start-1,i,end+1,因为在[start-1,i-1],[i+1,end+1]这两个区间已经提前被扎爆了，
    而且[start, i-1] 这个区域的取值与[i+1,end]无关，因为num[i]是最后取走的，此时左边的数列永远不会与右边的数相邻。

    如果整个数组最后扎破的是num[i]，那么i的左右邻居都是1。且对于[0,i-1]这个区间，最后一个扎破的气球，其左邻居一定是1，右邻居一定是num[i];
    对于[i+1,n-1]这个区间，最后一个扎破的气球，其左邻居一定是num[i]，右邻居一定是1; 然后再划分，

    发现当考虑一个区间如[0,i-1]时，
    如果它是包含它的大区间(称为父区间，如[0,n-1])的左半边，则该区间最后扎的气球的左邻居就是父区间的左邻居，右邻居就是父区间中最后一个扎破的气球
    如果它是包含它的大区间的右半边，则该区间最后扎的气球的左邻居就是父区间中最后一个扎破的气球，右邻居就是父区间的右邻居

    因此就有递归的形式了：
    maxCoin(start:0, end: n-1, leftNeighbor, rightNeighbor) ，一开始leftNeighbor和rightNeighbor都是1
    = Max(maxCoin(0,i-1, leftNeighbor, nums[i]) + leftNeighbor*nums[i]*rightNeighbor + maxCoin(0,i-1, nums[i],rightNeighbor))
    用dp[i][j]来描述区间[i,j]能取得的最大值

    dp不需要重复计算，如果算过一遍了就可以重复使用，例如，对于dp[i][j]，当考虑的区间是它时，由于上面的算法，那么nums[i-1]和nums[j+1]一定是在它的父区间内考虑的，尽管题目是任意扎，看起来dp[i][j]两边的邻居可能会不同，但由于上述算法的思想，考虑一个区间时，它的真实邻居一定是还未被扎的，所以对任意区间它的邻居是一定的，因此可以重复使用
    public int maxCoins(int start, int end, int leftNeighbor, int rightNeighbor, int[] nums, int[][] dp){
        if(start > end){
            return 0;
        }
        if(dp[start][end]!=0) return dp[start][end];
        for(int i=start;i<=end;i++){
            int val = maxCoins(start, i-1, leftNeighbor, nums[i], nums, dp)+
                    leftNeighbor * nums[i] * rightNeighbor
                    +maxCoins(i+1, end, nums[i], rightNeighbor, nums, dp);
            dp[start][end] = Math.max(val, dp[start][end]);
        }
        return dp[start][end];
    }

    # 这道题的解法是典型的自顶向下的动态规划，即从大的入手，一步步到小的；而剪绳子那题则是典型的自底向上的动态规划，从0，1等初始状态开始，慢慢到最后


》不同的面值组合成一个和t，能的话输出最少纸币数，不能则输出-1 （找零钱）：322，c-p191.1
    👌这个题不能从大到小依次试，因为最大的可能不用（如果面值是从1到n连续的，则可以这么做）

    考虑对于和的表示，其中最大的值是i（可能不是面值中最大的值）
    如果用回退递归，可以解决问题，但是复杂度太高，太慢了

    》自顶向下的动态规划：
    F(s)表示总额为s时用的最少的张数
    F(S)=min F(S−coin[i])+1  i=0...n−1。 S-ci<0时直接跳过
    F(S) = 0 , when S = 0
    F(S)=−1,   when n=0
    S从t开始


    》自底向上的动态规划
    dp[i] = min(dp[i−coin[j]]+1)   j=0…n−1 


    》更容易理解的做法：
        做法是：如果有N张货币（arr大小为N），换钱数为aim，则生成动态规划表：dp[N][aim+1]
        dp[i][j]表示，在任意使用arr[0...i]货币的情况下，组成j所需的最小张数

        dp[i][j] = min {dp[i-1][j-k * arr[i]]+k} (k>=0)
        可以推导得:
        dp[i][j] = min{dp[i][j-arr[i]]+1, dp[i-1][j]}
        可以看到仍然可以使用路径压缩：
        dp[j] = min{dp[j-arr[i]]+1, dp[j]}



》找钱2：给定数组arr，arr中所有的值都为正数，每个值仅代表该面值的一张钱，再给定一个整数aim代表要找的钱数，求组成aim的最少货币数，如果无法组成，返回-1：c-p191.2
    如[5,2,3] aim=20：5，2，3元各有1张，无法组成20元，返回-1
    [5,2,5,3] aim=10  5元的有两张，可以组成10元且用钱最少，返回2
    [5,2,5,3] aim=15  所有的钱加起来才能组成15元，返回4
    [5,2,5,3] aim=0  不用任何货币就能组成0，返回0

    dp[i][j]是前i-1张货币组成j元所用钱的最少数
    dp[i][0]=0;
    dp[0][j]表示只使用这一张钱能达到的钱数，自然让 dp[0][coins[0]]=1, 其他dp[0][i]都为MAX(除了dp[0][0])
    如果不使用arr[i]就能组成j，则dp[i][j]的值可能等于dp[i-1][j]
    因为arr[i]只有一张不能重复使用，考虑dp[i-1][j-arr[i]]，它代表可以任意使用arr[0..i-1]货币的情况下，组成j-arr[i]的最小张数，因此dp[i][j]可能等于dp[i-1][j-arr[i]]+1，如果j-arr[i]<0,则直接让dp[i][j]=dp[i-1][j]

    //注意！这里路径压缩的方法有点不一样，因为dp[i][j]要用到dp[i-1][j-arr[i]]，也就是上一行的前面的数据，所以这里j的遍历要从后往前走，避免上一行的数据被过早覆盖




》安置路灯：小Q正在给一条长度为n的道路设计路灯安置方案。：b3
    为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用'.'表示, 不需要照亮的障碍物格子用'X'表示。
    小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。注意，不论是X还是.都可以放置路灯
    小Q希望能安置尽量少的路灯照亮所有'.'区域, 希望你能帮他计算一下最少需要多少盏路灯。

    照亮i及之前区域，最少用dp[i]个灯
    如果nums[i]='X',dp[i]=dp[i-1]
    如果nums[i]='.' dp=1+Math.min(dp[i-1], dp[i-2], dp[i-3])
    且i=0,i=1,i=2的时候都要单独提出来，上面的循环必须从i=3开始
    最终打印dp[n-1]


》环形路上的加油站：134
    从gas[i]走到gas[i+1]需要消耗 cost[i]的汽油，问从哪个gas开始走，顺时针绕一圈能回到gas[i]
    一开始油箱是空的，油箱是无限大的，假设题目具有唯一解。
    基于一个数学定理：
    ## 如果一个数组的总和非负，那么一定可以找到一个起始位置，从他开始绕数组一圈，累加和不管到哪一步一直都是非负的
    有了这个定理，判断到底是否存在这样的解非常容易，只需要把全部的油耗情况计算出来看看是否大于等于0即可。
    如果我们从第i个气站出发，第一个不能到达的气站Index为j，那么从第i+1..j-1个气站出发也不能到达第j个气站。

    证明如下：
    以从第i+1气站（加油站）出发为例，从第i气站出发到达第i+1气站后剩余的气>=0,再从i+1出发，仍然到达不了第j气站。从第i+1气站出发的话开始剩余的气为0，比上述的情况要糟糕，所以也到达不了第j气站。i+2..j-1个气站出发同理，第i气站到达出发点时剩余的气>=0。

    所以我们可以实现气站的跳跃，从0气站出发，一旦发现到达j+1气站后剩余的气<0(tank+gas[j]-cost[j]<0),
    即不能到达j+1气站，就尝试从j+1气站重新出发。
    因为题目保证具有唯一解，所以只需要记录最后的出发点k即可。
    k前面的点肯定不行，k后面的点如果是解，那k可以到达后面的点，那么k也是解，与具有唯一解矛盾，所以该出发点为唯一解。

    如果油的总量不小于消耗的总量，则一定存在一个解（由上面的数学定理）

    假设t[i] = gas[i]-cost[i] t[i]表示从i到i+1的 纯剩余油量（假设这么叫）
    若Σt[i] >=0 则该题一定有解。

    举个例子：
        cost  2   1    5    2
        gas：1--》3--》2--》4-->1

    从1开始走，1-》3，remain=-1  令remain=0，debt=-1
    重新从当前位置开始走： 3-》2  remain=2  debt=-1
    继续  2-》4  remain=-1  debt = debt-1 = -2，令remain=0
    重新从当前位置开始走：4-》1  remain=2  此时debt=-2, remian=-debt，
    此时遍历完了所有位置，且remain+debt>=0。说明从现在的当前的起始点开始走（注意不是当前点，是当前的起始点），可以把之前欠的都补上，所以当前的起始点就是所求点
    为了更明确过程，继续这个过程：
    继续，1-》3  remain=1
    继续，3->2   remain=3
    继续  2-》4  remain=0，刚好走完


    如果纯剩余油量之和大于等于0，说明有解
        public int canCompleteCircuit(int[] gas, int[] cost) {
            int start = 0; // 起始位置
            int remain = 0; // 当前剩余燃料
            int debt = 0; // 前面没能走完的路上欠的债

            for (int i = 0; i < gas.size(); i++) {
                remain += gas[i] - cost[i];
                if (remain < 0) {
                    debt += remain;
                    start = i + 1;
                    remain = 0;
                }
            }

            //剩余燃料-欠的燃料 = 总的剩余燃料(纯剩余油量)
            return remain + debt >= 0 ? start : -1;
        }


》机器人走有障碍的方格：63
    机器人位于mxn网格的左上角(下图中标记为“Start”)。
    机器人只能在任何时间点向下或向右移动。机器人正试图到达网格的右下角(下图中标记为“Finish”)。
    现在考虑一下是否向网格中添加了一些障碍。有多少条唯一路径?

    在网格中，障碍物和空地分别标记为1和0。

    注意:m和n最多为100。

    dp[i][j] 代表到达(i,j)的唯一路径的个数，每个位置只能由上方或左方移动而来
    dp[0][0]=1;
    dp[i][j] = dp[i-1][j] + dp[i][j-1]
    对于任何nums[i][j]=1，则dp[i][j]=0  //因为此处是障碍


》给定一个三角形，从上到下求最小路径和。每一步都可以移动到下面一行的相邻数字。：120
    [
         [2],
        [3,4],
       [6,5,7],
      [4,1,8,3]
    ]
    如果你能只使用O(n)额外的空间来做这件事，额外的好处是n是三角形的总行数。
    dp[i][j] 是走到第i行第j列的最小和

    if(j==0){
        dp[i][0] = dp[i-1][0] + num[i][0]
    }
    else if(j==最后一列){
        dp[i][j] = dp[i-1][j-1] + num[i][j]
    }
    else{
        dp[i][j] = Math.min(dp[i-1][j-1] + dp[i-1][j]);
    }
    然后求最后一行所有的dp中的最小值即可


》地牢游戏/龙与地下城：174，c-p223
    恶魔抓住了公主(P)，把她囚禁在地牢的右下角。地牢由M x N个房间组成，以二维网格布局。我们英勇的骑士(K)最初被安置在左上方的房间里，他必须通过地牢来营救公主。
    骑士的初始生命值点由一个正整数表示。如果他的健康值下降到0或更低，他会立即死亡。有些房间由恶魔守卫，因此骑士在进入这些房间时失去生命值(负整数);其他房间要么是空的(0)，要么是包含增加骑士生命值的魔法球(正整数)。为了尽快到达公主，骑士决定每一步只向右或向下移动。
    编写一个函数来确定骑士的最低初始生命值，以便他能够拯救公主。
    注意:
    骑士的健康没有上限。
    任何房间都可能包含威胁或能量提升，甚至是骑士进入的第一个房间和公主被囚禁的右下角房间。

    思路：在走完最后一个房间的时候血量至少要剩下１，因此最后的状态可以当成是初始状态，由后往前依次决定在每一个位置至少要有多少血量, 这样一个位置的状态是由其下面一个和和左边一个的较小状态决定 ．因此一个基本的状态方程是: dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]. 
    （因为只需保证一条路能走通即可，所以取min）
    但是还有一个条件就是在每一个状态必须血量都要大于１，因此我们还需要一个方程在保证在每一个状态都大于１，即：dp[i][j] = max(dp[i][j], 1);　也就是说虽然当前的血量到最后能够剩下１，但是现在已经低于１了，我们需要为其提升血量维持每一个状态至少都为１．

    # 这是理解的关键：：
    dp[i][j]是进入该房间之前能保证进入该房间后存活的最小血量(是一个准备进入但还没有进入的状态)
    如果最后一个格子是正数，那dp=1,如果是负数，则dp=1-dungeon，综合来看就是max(1, 1-dungeon[row-1][col-1]);


》礼物的最大价值：j47-p233
    在一个m x n的棋盘的每一格都放有礼物，每个礼物都有一个价值，可以从棋盘的左上角开始拿礼物，每次往右或者朝下移动一格，直到到达棋盘的右下角，
    给定一个棋盘及其上面的礼物，请计算最多能拿到多少钱的礼物
    》方法一
    很简单的动态规划，dp[i][j]是到达位置[i][j]后能有的最大价值
    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + gift[i][j]

    》方法二：
    可以对空间进行优化，因为每次dp[i][j]只依赖dp[i-1][j]和dp[i][j-1],因此i-2及以上的格子都没有必要保存
    对于dp[],当遍历到num[i][j]时，dp[0]到dp[j-1]是本行的数据，dp[j]到dp[col]是上一行的数据，这样用一维数组就可以完成工作了。
    （ dp[j]=max(dp[j-1], dp[j]) ）
    需要注意的是，就算dp优化成了一维数组，遍历num仍然二重循环。


》有重量分别为3，5，7公斤的三种货物，和一个载重量为X公斤的箱子（不考虑体积等其它因素，只计算重量）：b28
    需要向箱子内装满X公斤的货物，要求使用的货物个数尽可能少（三种货物数量无限）

    使用动态规划。设dp[i]能装满载重为i的箱子的最少货物个数
    //下面为了书写简洁起见没有考虑i-3,i-5,i-7的范围，其实代码中是要考虑进去的
    dp[i]=-1;
    if(dp[i-3]!=-1 || dp[i-5]!=-1 || dp[i-7]!=-1){
        dp[i] = Integer.MAX_VALUE;
        if(dp[i-3]!=-1){
            dp[i] = Math.min(dp[i-3],dp[i])+1;
        }
        if(dp[i-5]!=-1){
            dp[i] = Math.min(dp[i-5],dp[i])+1;
        }
        if(dp[i-7]!=-1){
            dp[i] = Math.min(dp[i-7],dp[i])+1;
        }
    }


》假设弄成中成熟的母牛每年生1头小母牛，且永远不会死，第一年农场有1头成熟的母牛，第二年开始，母牛开始生小母牛，每只小母牛3年后成熟又可以生小母牛，给定整数N，求出N年后母牛的数量：c-p181.3

    对于第N年，所有3年前的牛在今年都可以生一头母牛，并且牛总数要加上两年前新出生的牛和一年前新出生的牛
    dp[1]=1;
    dp[2]=2;
    dp[3]=3
    dp[4] = dp[4-3] * 2 + dp[3]-dp[2] + dp[2]-dp[1];
    dp[n] = dp[n-3] * 2 + dp[n-2]-dp[n-3] + dp[n-1]-dp[n-2];


》换钱的方法数：c-p196
给定数组arr，arr中所有值都为正数且不重复，每个值代表 一种面额的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法

    （如果能想到方法一，一般就能写出方法二，因为只是保存之前的结果，然后尽量去找依赖的位置来写dp）
    》方法一：
        首先想到的就是用trackback求组合数，需要传入start。（暴力递归）
        复杂度是O(aim^N)

    》方法二：记忆搜索（优化的trackback），
        在方法一递归过程中，arr始终不变，变得只有start和cur，计算之所以大量，因为中间过程都没有记录下来，只要把start-cur作为k，此时能完成的结果数作为v记录到map中，就能使用之前遍历过的结果,为了更方便理解，把cur改成rest，表示剩下准备处理的数。以start-rest作为key，复用之前的结果
        复杂度是O(N * aim^2)

    》方法三：动态规划：
        生成行数为N，列数为aim+1的矩阵dp[][] dp[i][j]代表使用arr[0...i]的货币能构成总钱数为j的总方法数
        dp[i][0]=1 组成0元的方法数均为1  //这个有点不好想，因为不使用任何货币也算一种方法，所以是1
        dp[0][j]= j%arr[0]==0?j/arr[0]:0;  //j是arr[0]的倍数，则可组成，否则为0
        dp[i][j]包含 不使用arr[i]，只使用arr[0..i]组成j的可能性：dp[i-1][j]，
        如果使用arr[i]，则可能性为：dp[i-1][j-k * arr[i]] （一直到 j-k * arr[i]<0为止, k为0时包含了dp[i][j]）

        所以dp[i][j] = Σdp[i-1][j-k * arr[i]] (j-k * arr[i]>=0)

        如果要使用路径压缩优化空间，二层的遍历也要倒序遍历，因为本层的答案用的都是上一层的结果，用不到本层之前的结果。要注意。
        动态规划比较吃空间，当空间吃不消时，可以改用记忆搜索


    》优化动态规划：对于dp[i-1][j-k* arr[i]],当k为0时，为dp[i-1][j], 
        而当k不为0时，有 dp[i-1][j-1* arr[i]] + dp[i-1][j-2* arr[i]]+... 其实就是dp[i][j-arr[i]]
        因此又可以简化为：dp[i][j] = dp[i-1][j] + dp[i][j-arr[i]] 不过还是得保证j-arr[i]>=0，否则只有前面的项


》最长公共子序列/公共最长子序列：c-p210
    给定两个字符串str1和str2，返回两个字符串的最长公共子序列
    如str1="1A2C3D4B56" str2="B1D23CA45B6A"
    "123456" 或 "12C4B6" 都是最长公共子序列，返回哪个都行

    dp[i][j]为 str1[0..i]与str2[0...j]的最长公共子序列长度

    dp[0][0] == str1[0]==str2[0]?1:0
    dp[0][j] == max(dp[0][j-1], str1[0]==str2[j]?1:0)
    dp[i][0] == max(dp[i-1][0], str1[i]==str2[0]?1:0)

    若str1[i]==str2[j]
        dp[i][j] = max(dp[i-1][j-1]+1, dp[i][j-1], dp[i-1][j])
    若str1[i]!=str2[j]
        dp[i][j] = max(dp[i][j-1], dp[i-1][j])

    要还原出序列，方法如下:
    1.从矩阵右下角开始，有三种移动方式：向上，向左，向左上。假设移动过程中，i表示此时的行数，j表示此时的列数，同时用一个变量res表示最长公共子序列。
    2.如果dp[i][j]大于dp[i-1][j]和dp[i][j-1],说明之前计算dp[i][j]时，移动选择了决策dp[i-1][j-1]+1,可以确定str1[i]等于str2[j]，且这个字符移动属于最长公共子序列，把这个字符放进res，然后向左上方移动
    3.如果dp[i][j]等于dp[i-1][j]，说明之前在计算dp[i][j]的时候，dp[i-1][j-1]+1这个决策部署必须选择的决策，向上方移动即可
    4.如果dp[i][j]等于dp[i][j-1],与步骤3同理，向左上方移动。
    5.如果dp[i][j]同时等于dp[i][j-1]和dp[i][j-1]，向上还是向左无所谓，选择其中一个即可




》最长公共子串：c-p213
    给定两个字符串str1和str2，返回两个字符串最长公共子串
    str1="1AB2345CD", str2="12345EF", 返回"2345"
    dp[i][j]是str1以str1[i]结尾，str2以str2[j]结尾的最长公共子串长度

    dp[0][0] = str1[0]==str2[0]?1:0
    dp[0][j] == str1[0]==str2[j]?1:0
    dp[i][0] == str1[i]==str2[0]?1:0

    如果str1[i]!=str2[j]
        dp[i][j]=0
    如果str1[i]==str2[j]
        dp[i][j]=dp[i-1][j-1]+1

    复原子串：
    遍历dp，记录其中最大值的行和列，比如dp[6][4]=4
    则str[3..6]就是这个最长子序列

    》改进法：
        经典方法需要大小为MxN的矩阵，实际上可以减小到O(1)，因为计算dp[i][j]的时候，只需要dp[i-1][j-1]的值，按照斜线方向（从左上往右下的斜线），只需要常数级变量就可以计算出所有位置的值








```

## 子序列可以是不连续的，子串是连续的





## Scanner无法读入char：只能用in.next(),读入String，然后再用charAt(index)去转成字符

## 自顶向下的动态规划一般都要使用递归，且基本都要使用之前的计算结果避免重复计算。且递归函数要有终止条件(当问题规模最小时的答案)
## 自底向下的动态规划一般从0，1等初始状态开始，慢慢到最后的最终状态
## 一般自顶向下比自底向上少一层循环，这是因为函数的递归本身就算是一层循环

#最优子结构或分治法或划分子问题
```
》一个二叉树，每个节点代表一个房子，两个相邻的房子不能被同时偷，求能偷得的最大金额：337
    ## 看起来很多类似的问题都可以归结为：一个值是取还是不取，这样会产生分支，也可能会是递归或者循环的条件

    乍一看，问题表现出“最优子结构”的特征：如果我们想从当前的二叉树（根植于根）中抢夺最大金额，我们当然希望我们可以对其左右子树做同样的事情。
    因此，沿着这条线，让我们定义函数rob（root），它将返回我们可以为根植于根的二叉树抢夺的最大金额;

    显然，上面的分析提出了递归解决方案。对于递归，总是值得找出以下两个属性：
    终止条件：我们何时知道rob（root）的答案而不进行任何计算？当然，当树是空的时候----我们没有什么可以抢劫的，所以钱数是零。
    递归关系：即如何从rob（root.left），rob（root.right）等中获取rob（root）。从树根的角度来看，最后只有两个场景：
    root是抢劫还是不抢劫。
        --如果抢，由于“我们不能抢夺任何两个直接连接的房屋”的约束，可用的下一级子树将是四个“孙子子树”（root.left.left，root.left.right） ，root.right.left，root.right.right）。
        --如果不抢，那么下一级别的可用子树就是两个“儿子子树”（root.left，root.right）。我们只需要选择产生更大金额的方案。
    public int rob(TreeNode root) {
        return rob(root, new HashMap<>());
    }
    //用map保存已经计算过的节点
    public int rob(TreeNode root, HashMap<TreeNode, Integer> map) {
        if (root == null) return 0;
        if(map.containsKey(root)) return map.get(root);
        int val = 0;
        if (root.left != null) {
            val += rob(root.left.left, map) + rob(root.left.right, map);
        }
        if (root.right != null) {
            val += rob(root.right.left, map) + rob(root.right.right, map);
        }
        int max = Math.max(val + root.val, rob(root.left, map) + rob(root.right, map));
        map.put(root, max);
        return max;
    }



》给定一串数字和运算符，返回所有可能的结果，这些结果来自计算所有可能的方法来分组数字和运算符。有效的操作符是+、-和 * 。：241
    非常典型的大问题由相同类型的小问题组成，
    用分治法的思想来解决
    当遍历到一个符号时，递归找到该符号两边能成为的数字，再将它们组合
    当输入的字符串中没有符号时，则它是一个数字，直接加入到答案集中返回即可

    //典型的分治法
    public List<Integer> diffWaysToCompute(String input) {
        //按正则表达式把数字全分出来
        ArrayList<Integer> ans = new ArrayList<>();
        int operatorCnt = 0;
        for(int i=0;i<input.length();i++){
            char c = input.charAt(i);
            if(c=='-' || c=='+' || c=='*'){
                operatorCnt++;
                List<Integer> part1 = diffWaysToCompute(input.substring(0, i));
                List<Integer> part2 = diffWaysToCompute(input.substring(i+1, input.length()));
                for(int i1: part1){
                    for(int i2: part2){
                        if(c=='-'){
                            ans.add(i1-i2);
                        }else if(c=='+'){
                            ans.add(i1+i2);
                        }else{
                            ans.add(i1*i2);
                        }
                    }
                }
            }
        }
        //没有符号，则说明是一个数字
        if(operatorCnt==0){
            ans.add(Integer.valueOf(input));
        }
        return ans;
    }


》找出给定字符串的最长子串的长度，这个子串中每个字母都必须重复至少k次,这里的子串整个是一个整体：395
    思路是分治法。
    要找s[i,j]的最大子串，先统计频数，然后遍历一遍频数，找出第一个频数小于k且大于0的字符，然后找出这个字符的位置，接下来的分析很重要，这个字符一定不能出现在任何的子串中，因为i,j是整个的子串，在ij里面频数都没有达到k，那么在ij的任何子串中，这个字符也不可能达到频数k。所以不能有这个字符，那么就在这个位置做一个分治，递归对前半和后半部分调用函数，最后返回其中的最大值。



》给定一个正整数n，把它分解成至少两个正整数的和，然后最大化这些整数的乘积。返回您可以得到的最大乘积。：343
    n不会小于2不会大于58

    》将满足条件的数称为dp
    得出每一个2到n数字的这个值，对每个数字i，trackback分解出所有可能的形式并求出其中最大的值，，并记录在dp[i]中供后续的数字调用

    》例如对于5来说，先将其分解为1+4，对于4，之前已经记录过了，其分解的加数的最大乘积为4，因此对于1+4的形式，4就不用再往下分解了，此时的乘积就为4；记录该数，dp[5]=4
    再分解为2+3，对于3页之前记录过了，其分解的加数的最大乘积为2，此时就要比较，是用该数的分解加数的最大乘积还是用它自己，显然2* 3大于2* 2，记录此时的乘积为6，比之前的4大，因此dp[5]更新为6
    再分解为3+2，后面的工作都是类似的。核心思想就是，对于分解后的加数，因为之前就计算过它自己的加数最大乘积，因此不用重复分解，直接用之前的结果即可

    这是典型的划分子问题


》字符串的交错组成：c-p220
给定3个字符串str1，str2和aim，如果aim包含且仅包含来自str1和str2的所有字符，且在aim中属于str1的字符之间保持原来在str1中的顺序，属于str2的字符之间保持原来在str2中的顺序，那么称aim是str1和str2的交错组成。实现一个函数，判断aim是否是str1和str2交错组成。
如str1="AB", str2="12", 则"AB12", "A1B2", "A12B", "1A2B"和"1AB2"等都是str1和str2的交错组成

    aim的长度一定是M+N，否则直接返回false，然后生成大小为(M+1)x(N+1)的布尔型矩阵dp，dp[i][j]的值代表aim[0..i+j-1]能否被str1[0..i-1]和str2[0..j-1]交错组成。

    1.dp[0][0]=true, aim为空串时，当然可以被str1为空串和str2为空串交错组成
    2.dp[i][0]表示aim[0..i-1]能否只被str1[0..i-1]交错组成，如果aim[0..i-1]等于str1[0..i-1]，则令dp[i][0]=true, 否则令dp[i][0]=false
    3.dp[0][j]表示aim[0..j-1]能否只被str2[0..j-1]交错组成，如果aim[0..j-1]等于str2[0..j-1]，则令dp[0][j]=true, 否则令dp[0][j]=false
    4.
        ①dp[i-1][j]代表aim[0...i+j-2]能否被str1[0..i-2]和str2[0..j-1]交错组成，如果可以，那么如果再有aim[i+j-1]与str1[i-1]相等，说明str1[i-1]可以作为交错组成aim[0...i+j-1]的最后一个字符，令dp[i][j]=true。
        ②dp[i][j-1]代表aim[0...i+j-2]能否被str1[0..i-1]和str2[0..j-2]交错组成，如果可以，那么如果再有aim[i+j-1]与str2[j-1]相等，说明str2[j-1]可以作为交错组成aim[0...i+j-1]的最后一个字符，令dp[i][j]=true。
        如果上述两种情况都不满足，则返回dp[i][j]=false





```

#贪心
```
》长为m的绳子剪成若干段，至少剪一刀，每段绳子记为k0,k1,k2...km，问k0*k1*k2...*km的最大可能乘积是多少：j14-p96
    》贪婪算法：当n>=5时，尽可能多剪长度为3的绳子，当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子
    （因为当n>=5时，有公式 3(n-3）>= 2(n-2),所以应该尽可能多剪长度为3的绳子段

    》动态规划
    设dp[i]是剪长度为i的绳子的最大乘积，j是剪一刀后第一段绳子的长度，则i-j是第二段绳子长度，这两部分都可以剪或不剪，因此有4种可能的组合
    dp[i] = max(dp[j] * dp[i-j], j* (i-j), dp[j]* (i-j), j* dp[i-j]);
    但对于剪后的两段绳子 j和 i-j来说，都有可能存在不剪的情况，如对于i=5来说，剪一刀即可，即2和3，但对2和3不能再剪




》跳跃游戏：给定一个非负整数数组，初始位置是数组的第一个位置。：45，c-p235
    数组中的每个元素表示该位置的最大跳转长度。
    您的目标是在最少的跳跃次数中达到最后一个索引。

    》动态规划，会超时：
    dp[i]为最少跳几次跳到索引i处
    dp[i] = min(dp[j]+1)  且dp[j]>=i-j
    这样的话复杂度是O(N^2)

    》贪心算法：
    以目的地为导向，从前往后找能第一个到达目的地的位置，找到后，将该位置标记为新的目的地，然后重复这个过程直到目的地为第一个位置
    1.设dump，表示目前跳了多少步，
        cur代表如果只能跳jump步，最远能够达到的位置。
        next代表如果再多跳一步，最远到达的位置
    2.从左到右遍历arr，假设遍历到位置i
        1.如果cur>=i，说明跳jump步可以到达位置i，此时什么都不用做
        2.如果cur< i, 说明只跳jump步不能到达位置i，需要多跳一步才行。此时令jump++，cur=next，表示多跳了一步，cur更新为跳jump+1步能够达到的位置，即next
        3.将next更新为math.max(next, i+arr[i])，表示下一次多跳一步能到达的最远位置
    3.最终返回jump即可


》剪绳子：b36
    题目描述
    有N根绳子，第i根绳子长度为Li，现在需要M根等长的绳子，你可以对n根绳子进行任意裁剪（不能拼接），请你帮忙计算出这m根绳子最长的长度是多少。

    输入描述：
    第一行包含2个正整数N、M，表示N根原始的绳子，和最终需要M根绳子数
    第二行包含N个整数，第i个整数Li表示第i根绳子的长度
    其中
    1 <= N、M <= 100000,
    0 < Li < 10 0000 0000
    输出描述
    对每一个测试用例，输出一个数字，表示裁剪后最长的长度，保留两位小数。

    这道题其实就是问裁剪出 M 段等长绳子，最大裁剪长度是多少。像这样的 "找到一个数，它要满足一定条件"     的题目，第一反应就是 贪心+二分，比如 “公路建设加油站，使最小距离最大化” 这道题以及现在这道题。这道题就是找到一个长度值 X，使得 X 满足能够从已有的 N 根绳子中裁剪出来 M 段。

    二分查找：low：0，high：绳子总长度  
    然后迭代mid，如果mid能满足条件，则可能有更大的值满足条件，low=mid  （遍历所有绳子，若rope/mid 的和大于等于m，说明满足条件，否则不满足）
    如果mid不满足条件，则大于mid的一定都不满足，往小处找，high=mid
    # 因为low和high都是double，所以不能让mid±1来赋值



》建加油站：b37
    有一条高速公路，想要建设 m 个加油站，一共有 n 个可以选择建设加油站的地点（n >= m），在这 n 个可选位置中选择 m 个建加油站有很多种方式，每一种方式中，两个相邻加油站之间的距离都有一个最小值，每种情况的最小距离可能不一样，问所有情况中，这个最小距离的最大值是多少？
    2 <= n, m <= 100000
    1 <= a[i] < a[i + 1] <= 10^9 (a[i] 是加油站位置)

    原题不是这样的，但是很多人并没有理解题什么意思（什么是最小距离最大值），所以我就翻译了一下，变成上边这道题。  输入第一行是 n 和 m，接下来下 n 个数是加油站的位置（保证是递增的，也就是 a[i + 1] > a[i]）。比如下边例子：

    Input 1:        Input 1:
    5 3          5 4
    1 4 5 6 9        1 4 5 6 9

    Output 1:       Output 2:
    4 (1 5 9)       2 (1 4 6 9)

      网上很多答案说用 DP，dp[i][j] 表示前 i 个位置中选择 j 个最小距离最大值是多少，但是这道题的 n 和 m 最大都是十万，数组开不了这么大的，vs中开这么大数组直接编译就错了。所以不是 DP，而是二分+贪心。

    把每个相邻距离都存入数组arr中，如对于a[i]= 1 4 5 6 9 来说，存入的是3 1 1 3
    取low=0，high=Σarr[i] 那么要做的就是每次看一个 mid 能不能满足在若干次合并内有m-1个数都 >= mid（为什么可以这样，是因为最左边和最右边的加油站一定会选，因为选其他任何两个边界，其中的最小距离都只能小于选两个顶头，每合并出一个数大于等于mid，说明可以放一个加油站和上一个加油站之间距离大等于mid）。
    共有n个可选地，所以有n-1个间隙(距离)，因为最左和最右一定会选，所以只需要把剩下的距离合并成每个距离大等于mid，且距离的个数大等于m-1个即可(如果等了，说明距离还能再大，但首先是说明了能保证距离mid满足)






```



#树与二叉树问题
```

》二叉树中每个节点都有数字，取其节点上的值使得和最大，但不能取任意两个直接连接的两个节点的值：337
    问题表现出“最优子结构”的特征：如果我们想从当前的二叉树（根植于根）中抢夺最大金额，我们当然希望我们可以对其左右子树做同样的事情。
    现在的关键是从解决方案到其子问题构建原始问题的解决方案，即如何从rob（root.left），rob（root.right）等中获取rob（root）。
    终止条件：我们何时知道rob（root）的答案而不进行任何计算？当然，当树是空的时候----我们没有什么取的，所以是零。
    递归关系：即如何从rob（root.left），rob（root.right）等中获取rob（root）。从树根的角度来看，最后只有两个场景：
    root是取还是不取。
            如果取，由于“我们不能取任何两个直接连接的节点”的约束，可用的下一级子树将是四个“孙子子树”（root.left.left，root.left.right） ，root.right.left，root.right.right）。
             如果root不取，那么下一级别的可用子树就是两个“儿子子树节点”（root.left，root.right）当前两个儿子节点可以同时用。
        我们只需要选择产生更大金额的方案。

        public int rob(TreeNode root) {
            if (root == null) return 0;
            int val = 0;
            if (root.left != null) {
                val += rob(root.left.left) + rob(root.left.right);
            }   
            if (root.right != null) {
                val += rob(root.right.left) + rob(root.right.right);
            }
            return Math.max(val + root.val, rob(root.left) + rob(root.right));
        }
        同时显然上面的方法对于同一个树根会重复计算多次（当它是孙子子树根或儿子子树根时），因此用map保存已经计算过的节点，避免重复计算


》利用二叉树的前序遍历和中序遍历，重建二叉树： j7-p62  105，c-p171.1
    》前序，后序分别和中序组合重构比较容易，核心就是根据前序或后序找出根节点的值，然后在中序中找到根节点的位置，借此可以区分出左子树和右子树，进而可以递归构建

    先根据前序遍历第一个数字创建根节点，然后在中序遍历中找到根节点的位置，它前面的是左子树，它右边的是右子树，然后把前序和中序序列划分成左子树的前序序列和中序序列，右子树的前序序列和中序序列，就可以递归地调用函数构建其左、右子树了
    构建函数必须的参数（前序序列，该层树前序序列开始的位置，该层树前序序列结束的位置，中序序列，该层树中序序列开始的位置， 该层树中序序列结束的位置）

》利用中序和后序遍历，重建二叉树：106，c-p171.2
    该题和上面题的关键都在于：找到根节点，分离左子树节点和右子树节点，递归构建
    注意返空条件，这是这种题中最重要的部分：
    public TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {
        if(inStart>inEnd || postStart>postEnd )
            return null;

        TreeNode node = new TreeNode(postorder[postEnd]);
        int rootIn = 0;
        for(int i=0;i<inorder.length;i++){
            if(node.val==inorder[i]){
                rootIn = i;
                break;
            }
        }
        int leftChildCount = rootIn-inStart;
        int rightChildCount = inEnd-rootIn;
        node.left = buildTree(inorder, inStart, rootIn-1, postorder, postStart, postStart+leftChildCount-1);
        node.right = buildTree(inorder, rootIn+1, inEnd, postorder, postStart+leftChildCount, postEnd-1);
        return node;
    }


》用前序和后序遍历构建二叉树（节点值都不同）：c-p171.3
    1、首先要分析出一般的二叉树即使有正确前序和后续数组，大多数情况下也不能通过这两个数组构建原来的树，因为很多结构不同的树拥有一样的前序和后序，如，根节点是1，左孩子为2，右孩子为null，则前序是[1,2],后序是[2,1]；根节点是1，左孩子是null，右孩子是2，这样的结果也是前序是[1,2],后序是[2,1]。
    2、然后要分析如果一棵二叉树除了叶节点之外，其他所有节点都有左孩子和右孩子（即每个节点的度只为0或为2，因为前序和后序无法构造的原因就是如果一个节点的左孩子为空右子树为X，和其左子树为X右子树为空无法分辨，所以有子树的两边子树都不为空就能分辨出了）

    既然两边子树都不为空，则对于前序遍历来说，如果不是只有一个值，那么，根后面的那个一定是左孩子


》通过前序和中序数组，不通过重建整棵树生成后序数组：c-p174
    虽然不生成树，但核心思想还是一致的，用一个全局的list来保存后序数组，利用前序和中序先定位到根节点，然后递归地先把左子树和右子树加入到list中，最后再把根节点加入到list中




》给定一个二叉树和其中一个节点，（该树的节点有其父节点的引用）找到该节点在中序序列中的下一个节点： j8-p65，c-p151
    如果一个节点有右子树，那下一个节点就是其右子树最左边的节点，那沿着右孩子往左走即可
    如果一个节点没有右子树，
        若它是其父节点的左孩子，则下一个节点就是其父节点
        若它是其父节点的右孩子，则下一个节点就是沿着其父节点往上走，直到找到一个是它父节点的左子节点的存在，那么该节点的父节点就是中序的下一个节点。


》给定n，有多少种不同结构的的BST(二叉搜索树)存储值1…n ?：96,c-p175.1
    （变种是给定一个数字不重复的数组，能构成多少不同结构的BST，注意，二叉搜索树还不一定是二叉平衡树）
     》方法一：
        考虑对于任意一个元素做为根节点时，可能二叉排序树的个数 = 可能的左子树个数 * 可能的右子树个数。
        对于任意二叉排序树，它的左右子树都是二叉排序树，则对于左子树中每个元素作为根节点时，
        可能的左子树个数 = 可能的左子树的左子树个数 * 可能的左子树的右子树个数
        这样会不断地减少子树中的节点数，直到1， 这样就可以方便使用递归

        int getTreeCount(int start, int end){
            //如果start==end,说明这个树只有1个节点，则能构成的个数为1；
            //如果start>end,说明没有节点，空树也是一种情况，所以个数为1
            if(start==end || start > end) return 1;
            int count =0;
            for(int i=start; i<=end;i++){
                int lchildCount = getTreeCount(start, i-1);
                int rchildCount = getTreeCount(i+1, end);
                count += lchildCount * rchildCount;
            }
            return count;
        }

    》方法二：
        显然这个是不断划分子问题，且子问题可以独立求解，所以可以用动态规划
        当节点数一定时，构成的二叉排序树的个数是一定的（因为树中的元素一定可以有序排列的，而且其中没有重复的元素）

        dp[n] = Σ dp[i] * dp[n-i]  for(i:0-->n) 
        i为左子树中节点个数，n-i为右子树中节点个数

        n个节点构成的二叉搜索树个数 =  Σ 左子树可能的个数 * 右子树可能的个数

        dp[i]表示i个元素能构成的二叉搜索树的个数，注意不是以i为根的二叉搜索树个数！
        其中包括以1为根，以2为根。。。。以i为根的二叉搜索树的个数总和
        ```java
        dp[1]=1;
        dp[0]=1;  //空树
        dp[2] = dp[0]*dp[1] + dp[1] * dp[0];
        dp[3] = dp[0]*dp[2] + dp[1] * dp[1] + dp[2] * dp[0];
                根节点为1        根节点为2         根节点为3

        dp[n] = 0;
        for(int i=0;i<n;i++){
            dp[n] += dp[i] * dp[n-i-1];
        }

        //注意到对于n为奇数时，除了中间一项，左右两边都是对称的，而偶数时左右两边完全是对称的
        //所以上面代码可以更精简，省去一些重复计算：
        for(int j=0;j<=n/2;j++){
            if(j == n/2) {
                if(n%2==1)dp[n] += dp[j]*dp[j];
            }
            else dp[n] += dp[j] * dp[n-j-1] * 2;
        }


》给定一个二叉树，看它是否符合二叉搜索树的规范：98, c-p147.1
    
    》方法一：
        一个二叉搜索树合理，是：左子树上的所有值必须都小于根值，右子树上所有值都大于根值每个节点向它的左右子树分别传递要小于的值和要大于的值，对于左右子树都必须传上限和下限，而且一开始的上下限必须大于整数最大值，小于整数最小值

        由于节点值可能是Integer的最大最小值，为了安全使用上下界，上下界的范围设置为Long类型

        public boolean isValidBST(TreeNode root) {
            //根节点大于MIN,小于MAX（即没要求）
            return checkTree(root, Long.MIN_VALUE, Long.MAX_VALUE);
        }

        boolean checkTree(TreeNode cur, long lower, long upper){
            if(cur==null) return true;
            boolean ans = cur.val > lower && cur.val < upper;
            //左孩子须大于下界，小于根； 右孩子须大于根，小于上界
            return ans && checkTree(cur.left,lower, cur.val) && checkTree(cur.right, cur.val, upper);
        }

    》方法二：
        由于二叉搜索树的中序一定是正序的，所以中序遍历即可，用一个单元素数组作为全局变量表示上次遍历的值，如果发现了逆序，说明不是，直接返回即可



 
》对称树，查看一棵树是否为对称树：101 ，j28-p159
    》方法一：
    如果左子树是右子树的镜面反射，则树是对称的。 空树是对称的
    如果出现以下情况，两棵树是彼此的镜像反射：
    1. 他们的两个根的值相同。
    2. 每棵树的右子树是另一棵树的左子树的镜像反射。
    3. 两棵空树一定是彼此的镜像反射
    4. 一空一非空一定不是彼此的镜像反射

    boolean isSymmetrical(TreeNode pRoot){
        if(pRoot==null) return true;
        return isMirror(pRoot.left, pRoot.right);
    }

    boolean isMirror(TreeNode root1, TreeNode root2){
        if(root1==null && root2==null) return true;
        else if(root1==null || root2==null) return false;
        return (root1.val==root2.val) && isMirror(root1.left, root2.right) && isMirror(root1.right, root2.left);
    }
    
    》方法二：
    定义一种遍历算法：先遍历父，再遍历右子节点，最后遍历左子节点 （父右左）
    如果这种遍历算法和前序遍历（父左右）的序列一样（！！但前提是两种遍历必须要把null也考虑进来！！），则树是对称的，否则不对称


》二叉树的镜像 ：j27-p157
    操作给定的二叉树，将其变换为源二叉树的镜像。
    输入描述:
    二叉树的镜像定义：源二叉树 
            8
           /  \
          6   10
         / \  / \
        5  7 9 11
        镜像二叉树
            8
           /  \
          10   6
         / \  / \
        11 9 7  5
    遍历树的同时交换节点的左右子节点，最方便当然就是递归遍历，前中后序都可。不用递归用循环也是一样的，其实质都是树的遍历算法




》计算二叉树的层数&二叉树的深度：104，j55-p271
    》方法一：用层序遍历，双队列来记录层数，没问题但很慢
    》方法二：递归，每深入一层，层数+1 （这种办法不止对二叉树，对任意树都可以，只要遍历到了所有子节点，最后返回最大值）
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }


》给定一棵二叉树，将它平铺成一个链表。：114
    》方法一：
        展平二叉树，按照前序遍历，而且是就地完成，即空间复杂度必须是O(1)
        其实很简单，再加一个指针pre保存上一个遍历过的元素即可，借助栈，对每一个元素都是先入右再入左
        遍历到一个元素，把它作为pre的右孩子，（pre原来的右孩子在栈中，不会丢失），再入栈它自己的右左孩子，
        把pre置为它，再把它的左右孩子都置null

    》方法二：
        递归展平树，对于以root为根的树，先将其左子树展平，再将其右子树展平，然后将右子树接到左子树的最后一个节点上，然后将左子树移到右子树的位置，左子树置空
        辅助递归函数（返回以root为根的树展平后的最后一个节点）：
            左右子树都为空，返回root
            左子树为空，返回右子树展平后的最后一个节点
            右子树为空，返回左子树展平后的最后一个节点
            都不为空，将右子树的根接到左子树的最后一个节点上，，然后将左子树移到右子树的位置，左子树置空，然后返回（没换位置时的）右子树展平的最后一个节点




》给定一个非空二叉树，找出最大路径和。：124
    路径被定义为沿着父-子连接（或子-父连接，即路径可以有折点）从某个起始节点到树中的任何节点的任意节点序列。路径必须包含至少一个节点，并且不需要经过根节点。（其中可能包括0，负数）

    递归的使用场景，核心是实现一个函数，这个函数会计算以当前节点为最上节点(根)的路径最长长度

    int max = Integer.MIN_VALUE; //最后返回的答案
    public int getCurrentRootMaxPath(TreeNode root){
        if(root == null) return 0;
        //分别算得以左右儿子为最上节点的路径最长长度,如果某个子树最长长度是负值，那么这个分支就不要了
        int left = Math.max(0, getCurrentRootMaxPath(root.left));
        int right = Math.max(0, getCurrentRootMaxPath(root.right));
        //root.val + left + right 是 当root为路径最上面的节点时的路径最长长度
        max = Math.max(max, root.val + left + right);
        //如果root不是最上面的节点，则返回左分支和右分支里面数值大的一条，作为更上层节点的子分支
        //显然只有路径最上面的节点可以是折点,折点才能左右分支都要，非折点只能要一条
        return Math.max(left, right) + root.val;
    }


》二叉树节点之间的最大距离：c-p169
    从二叉树的一个节点出发，可以向上走或者向下走，但沿途的节点只能经过1次，当到达另一个节点时，路径上的节点数叫做A到B的距离。
    对于每个节点，都把他当做拐点，计算 左子树的高度+右子树高度+1 对所有的节点，求出这个值的最大值



》给定一个完全二叉树，计算节点数。：222，c-p178
    直接层序遍历当然可以，复杂度是O(n), 而且只需要一个队列即可，但这样就没有用到“完全二叉树”这个条件

    只需向左走即可找到树的高度。 让单个节点树的高度为1.找到整个树的高度h。 如果整个树是空的，即高度为0。
    然后检查右子树的高度是否只比整个树的高度小1，这意味着左右子树具有相同的高度。
    如果是，则最后一个树行上的最后一个节点在右子树中，而左子树是一个高度为h-1的满二叉树。 
        因此，该树的总结点数 = 左子树的2 ^ (h-1)-1个节点加上1个根节点加上递归的右子树中的节点数。
    如果否，则最后一个树行上的最后一个节点在左子树中，右子树是一个高度为h-2的满二叉树。 
        因此，该树的总结点数 = 右子树的2 ^（h-2）-1个节点加上1个根节点加上递归的左子树中的节点数。
    由于我在每个递归步骤中将树减半，因此我有O（log（n））步。 找高度成本为O（log（n））。 所以整体O（log（n）^ 2）。
    int getHeight(TreeNode root){
        return root==null?0:1+getHeight(root.left);
    }

    public int countNodes(TreeNode root){
        int h = getHeight(root);
        if(h==0) return 0;
        int t = getHeight(root.right)==h-1? ((1<<(h-1)))+countNodes(root.right)
                : ((1<<(h-2)))+countNodes(root.left);
        return t;
    }


》翻转二叉树：226
    递归调用函数，函数中左右孩子交换，并对左右孩子也调用函数



》给定一棵树，两个节点，找到这两个节点的最低公共祖先节点（LCA），：236，c-p153
    需要注意的是，一个节点算是它自己的祖先（该方法不太好，看下面j68-p326中的方法）
    》方法一：
        维护一个本节点与其祖先的HashMap<TreeNode, TreeNode> map，k是本节点，v是其祖先节点，先用层序遍历把这个map给做好
        过程中把q和p的层高找到,先让低的追溯祖先让二者层高相同，然后两个一起追溯，直到节点相同，相同的就是公共祖先
    》方法二：
        对于二叉树中的节点，当以后序遍历遍历到一个节点时，此时栈中的元素就是该节点的祖先链，因此考虑用后续遍历得到两个节点的祖先链，可以把它另存入list中，然后再从头开始算出最远的相同节点即为最低公共祖先（需要注意的是，一个节点的祖先链包括自己，所以对普通的后续遍历需要小改造一下）
        》可以直接用LinkedList，既可以当栈在遍历中使用，也可以当队列使用。

    》问题2.如果查询两个节点的最近公共祖先操作十分频繁，想办法让单条查询的查询时间减少。
    对于每个节点，把其祖先链存放在map中，即HashMap<TreeNode, LinkeList>，每当要查找时，先看map中有无该节点的祖先链，如果有的话就不用再遍历了。
    把所有的节点存储在HashSet中，对树进行后续遍历，当遍历到一个节点在HashSet中时，就保存其祖先链，当一遍遍历完后，所有需要查询的节点的祖先链就都保存起来了。




》给定二叉搜索树(BST)，查找BST中两个给定节点的最低公共祖先(LCA)。：235
    对于普通的树，用上面的map方法，存储父节点，追溯LCA
    而对于二叉搜索树，就变得更简单了，因为是二叉搜索树，很方便能找到对应节点直接用队列qa记录根到节点A的节点链，qb记录根到节点B的节点链，然后出队到两个队头节点不同时，上一个出队的节点就是最低公共祖先


》寻找树中两个节点的公共最低祖先（LCA）：j68-p326
    》如果是普通二叉树，后序遍历到该节点时，栈中元素就是该节点的祖先链（注意还要把自己也算进去）
    》如果是二叉树，且是二叉搜索树，可以很容易的找出根到两个节点分别的路径，然后从根的那一端开始找，就能找到
    》如果是一棵有指向父节点的指针的树，则转变成求两个链表的第一个公共节点
    》如果只是一棵普通的树，则可以分别对两个节点进行深度优先搜索，并且保留两个深搜过程中使用的栈，两个栈中就包括了两个节点从根开始的路径，剩下的就很好操作了



》序列化和反序列化一棵二叉树，将二叉树结构序列化成一个字符串，将一个字符串反序列化成一棵二叉树：297，j37-p194，c-p103
    这里理解成将二叉树转成中序序列和前序序列的合集字符串，然后将这个合集再转回二叉树
    节点的值可以是重复的，而且可以是负数，使用层序遍历来构建字符串

    》只使用前序或只用层序（c-p103）：该方法最好，且同值的节点不会歧义，核心是遍历时要保存非空节点的空节点孩子
        》只用前序
        不用又保存前序又保存中序，只保存前序即可，但要保存非空节点的空节点孩子
        序列化，把二叉树的前序序列放在一个String中，空节点用#表示,节点之间用,隔开
        反序列化，先把序列放入队列中，用这个队列作为参数，按照前序遍历的方法，去构建树。因为序列化时是前序，此时也按照前序构建，并且保存了空孩子，不会引起歧义

        》使用层序
        层序遍历也类似，核心还是要保存非空节点的空子节点
        序列化：先用层序遍历把节点序列化成字符串
        反序列化：用层序遍历的方式构建节点。


    》用层序遍历：297
    序列化时：把树变成层序遍历集合，但注意的是要加入null节点，不为null的话再加入左右孩子，且转成字符串时最后的null不要
    反序列化：即把上面的层序遍历变成树，因为有null节点，所以只需要这一个序列即可复原
            先把序列中的所有数字创建成节点放在数组中，然后构建二叉树：维护一个父亲节点索引，父亲节点不能是null，当前节点不是null时，则必须等到它的左右儿子都添加后，该父亲节点索引+1，具体看如下代码：
            nodeList是层序的节点数组，里面包含null
            int parent = 0;
            boolean isLeft = true;
            for (int i = 1; i < nodeList.length; i++) {

                if(isLeft){
                    nodeList[parent].left = nodeList[i];
                    //添加完左孩子该添加右孩子
                    isLeft = false;
                }else {
                    nodeList[parent++].right = nodeList[i];
                    //添加完右孩子该添加下一个节点的左孩子
                    isLeft = true;
                }
                //父亲节点始终不为null
                while(parent < i && nodeList[parent]==null) parent++;
            }

    》使用中序和前序：j37-p194
    序列化：把中序和前序序列放入字符串，中间用#隔开
    反序列化，从字符串得到中序和前序，并用其构建一棵二叉树返回





》给定一个二叉树，其中每个节点包含一个整数值。找出与给定值求和的路径数。
    路径不需要从根节点或叶子节点开始或结束，但是它必须向下(只从父节点移动到子节点)。 ：437
    对于每一个节点，当它为一个路径末节点的时候且路径和为目标值，计数+1，
    关键在于往下传的时候减去它自己的值。  
    由于有可能从任意节点开始，所以对每个节点都要调用pathSum
    对于某个节点，则用递归来找到以它为根的路径
    public int pathSum(TreeNode root, int sum) {
        if(root == null)
            return 0;
        //这样会做到让每个节点都能成为最顶上的节点，去计算
        return findPath(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    }

    public int findPath(TreeNode root, int sum){
        if(root==null) return 0;
        int res = 0;
        if(root.val==sum)
            res++;
        res += findPath(root.left, sum-root.val);
        res += findPath(root.right, sum-root.val);
        return res;
    }


》二叉树中和为某一值的路径：j34-p182，113
    输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
    使用trackback。（由前序遍历改造而来）
    public void trackBack(TreeNode root, int cur, int target, ArrayList<Integer> list, ArrayList<ArrayList<Integer>> ans){
        cur += root.val;
        list.add(root.val);
        if(root.left==null && root.right==null && cur==target){
            ans.add(new ArrayList<>(list));
            list.remove(list.size()-1); //这里千万别忘了！
            return;
        }
        if(root.left!=null){
            trackBack(root.left, cur, target, list, ans);
        }
        if(root.right!=null){
            trackBack(root.right, cur, target, list, ans);
        }
        list.remove(list.size()-1);
    }


》给定一棵二叉树和一个和，确定该树是否有根到叶的路径，以便将路径上的所有值相加等于给定的和。：112
    很简单的递归，找到就直接返回true


》把一个二叉搜索树转成大树，原来二叉树中所有的节点都加上比它值大的节点的值：538
    getSum用于求以root为根节点的树的所有节点和
    Helper返回一个节点新树中root位置要放的节点，该节点的值等于它的右树和+它自己的值+它的右上部分所有节点的和


》给一个二叉树，计算其直径：543
    二叉树的直径，是二叉树中两个相距最远的点之间的距离
    getLongestPath(root)是获得以root为根的树的根到叶子的最大距离=max（左子树的最大距离，右子树最大距离） + 1  

    显然getLongestPath(root) = 1+ Math.max(getLongestPath(root.left), getLongestPath(root.right));

    那么对于以root为根的树，它的直径就是对所有的节点取  getLongestPath(node.left) + getLongestPath(node.right);，其中的最大值就是答案



》二叉树t1是否包含t2树全部的拓扑结构：c-p140
    依次遍历t1所有的节点，是否包含t2形状的拓扑，它比c-p141的条件宽松，只要包含拓扑即可，不用是子树


》检查一棵树是否是另一棵树的子集树（即被它包含）：572，c-p141
    》方法一：
    先算出t的高度，然后找出s中高度与t相同的子树的所有节点，然后判断它们两个树是否相等
    以p节点为根的树的高度=1+Max(左子树高度，右子树高度)

    》方法二：
    直接可以递归判断s中每个节点为根的树与t是否相同



》合并两个二叉树：即从根开始，把两个二叉树的对应位置节点值加起来变成一棵新的二叉树：617
    递归着加，合并它们的根节点，然后在分别合并左子树和右子树。为了统一，对于一个为null节点一个非null，将null的值视为0；
    两个都为null则没有该位置的新节点


》对一个二叉树进行之字形的层序遍历，其实就是奇数层从左往右遍历，偶数层从右往左遍历：103， p176，c-p129
    当遇到奇数层时，直接把节点从队列中取出并放入list，并将孩子节点加入队列
    当遇到偶数层时，先把节点从队列放入一个栈，将孩子加入队列，然后从栈中取出并放入list，也可以先顺序放入list，最终用Collections.reverse翻转后再加入结果集。

    》更好的方法是不使用list（因为list如果扩容的话，时间复杂度会上升），而使用双端队列，奇数层顺着出，偶数层倒着出


》将有序数组构成二叉排序树/二叉平衡搜索树：108,c-p150
    对于把一个有序序列排成二叉搜索树，比乱序序列要好排，找到中间的元素，以它为根，左边的是左子树，右边的是右子树，这样直接就是平衡树。仅仅要二叉排序树就更简单了，直接遍历数组插节点即可。


》给一个完全二叉树，让每个节点的next域都填为它同层的右边的节点，一层中最右边的节点next域为null：116
    》方法一：
        直接用层序遍历即可，当前访问节点的next是当前队列中的队头节点（即下一个要访问的节点）

    》方法二：
    用如下方法，逐层构造：
        TreeNode pre = root;
        TreeNode cur = null;
        while(pre.left!=null) {
            cur = pre;
            //将当前cur所在的一层的节点都逐个赋给cur，并将下一层的next关系构造完成
            while(cur!=null) {
                cur.left.next = cur.right;
                if(cur.next!=null) cur.right.next = cur.next.left;
                cur = cur.next;
            }
            pre = pre.left;
        }


》树的子结构：j26-p148
    输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

    设A的根为a
    按照题意，B可以是A中任意一段，即B的叶子节点，可以是A中的非叶子节点，相当于就不要A中这个节点下面的部分了
    但B的非叶子节点在A中必须是非叶子节点，且子树也相同（即A中包含B）

    如果树a和树b相似，充要条件是b的子树(如果有的话)和a的子树相似且 b.val==a.val  
    //这里如果b有子树，则a必须有子树与其相同，如果b没有子树，则只需要满足两节点值相同，a有没有子树不重要，如上面的
    递归遍历以查看a中以每一个节点为根的子树与树b是否相似，如果有一个则为true，一个都没有则为false

    #该题和572的方法二有一点区别（572的方法一不能用），就是572是子树，即b的叶子必须也是a的叶子，而该题是子结构，b的叶子可以不是a的叶子，所以要多一个if，判断b是否有子树，有的话再去检查a对应的子树


》找出二叉搜索树第k小的节点：230
    二叉搜索树的中序遍历就是递增序列，所以要中序遍历的第k个值



》记录二叉树中根到叶子的所有路径：257
    利用递归，每遍历到一个节点，则把它和从上级传下来的路径字符串组合成一个新的字符串作为本级路径串，当该节点为叶子时，把本级路径串加入答案集
    如果不是叶子，则递归遍历该节点的左右孩子，并把本级路径串作为参数传递下去。


》从上往下打印出二叉树的每个节点，同层节点从左至右打印。：j32-p171
    也就是层序遍历，由于不用管层数，用一个队列即可层序遍历即可



》输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。：j33-p179，c-p145.1

    后序遍历中，最后一个数字就是根，数组中的数可以分为两部分，一部分是左子树，值都比根小，一部分是右子树，值都比根大，再用同样的办法确定与数组每一部分对应的结构，其实就是一个递归的过程

    先遍历数组，让i成为右子树的首值，即从左往右第一个大于根值的，然后遍历右子树，如果发现有值小于根的，返回false
    如果左子树不为空，则左子树得正确，没有则默认正确
    如果右子树不为空，则右子树得正确，没有则默认正确
    返回 上述两结果的与值


》arr是节点值为整型的二叉搜索树后序遍历的结果，重构该树：c-p145.2
    因为确定是搜索树，所以只需要分离出左右子树即可，然后分别递归构建左右子树



》给定一个二叉树，返回其节点值的自底向上顺序遍历。：107
(即从左到右，从叶到根，一层一层地)。
    层序遍历，每一层的list都放入一个list，然后倒序这个list即可


》给定一个单链表，其中元素按升序排序，将其转换为高度平衡的BST（二叉平衡树）。：109
    对于该问题，高度平衡二叉树定义为每个节点的两个子树深度相差不超过1的二叉树。
    考虑把单链表节点放到数组中，对数组操作要更简单
    每次取数组的中间值为根，把数组分成左子树和右子树，然后再递归构建

    TreeNode buildTree(int start, int end){
        if(start > end) return null;
        //每次取中间的值作为根
        int mid = (start + end ) / 2;
        TreeNode root = new TreeNode(nodes[mid].val);
        root.left = buildTree(start, mid-1);
        root.right = buildTree(mid+1, end);
        return root;
    }


》给定一个二叉树，判断它是否为高度平衡二叉树。：110，c-p144
    对于该问题，定义高度平衡二叉树为:一种二叉树，其中每个节点的两个子树的深度相差不超过1。

    》方法1：
        先将以每个节点为根的树的高度保存在hashMap中：树的高度=max(左子树高度，右子树高度)+1
        然后对于任何一棵树，它为平衡二叉树 等价于下面两个条件同时满足
        1.它的左子树和右子树高度差不超过1
        2.它的左子树和右子树都是二叉平衡树

    》方法2：
        整体解法是后序遍历，先遍历node的左子树，node的左子树是否为平衡二叉树，如果发现不是二叉平衡树，直接返回；如果是，则再看右子树，程序是一样的。如果左右子树都是平衡树，就看l和r差的绝对值是否大于1，如果是则说明不是二叉平衡树，否则就是返回l和r较大的那一个。使用一个boolean的数组保持遍历过程中每个子树是否是平衡的，如果发现不平衡的，设置boolean数组为false，且直接返回，此时返回什么不重要。boolean数组其功能相当于一个全局变量。这样的化只需遍历一遍即可



》输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。：j36-p191
    二叉搜索树中序遍历就是排序的顺序,利用中序遍历，每次都保存上一个遍历过的节点，在访问当前节点后，将上一个遍历过的节点的right指向当前节点，当前节点的left指向上一个节点。（由于当前节点的left已经遍历完了，上一个遍历过的节点的right一定也遍历完了(或者就是当前节点，否则不可能遍历到当前节点)，所以不会出现断链的问题），并将上一个访问的节点的引用更新为该节点的引用。并且要保留第一个访问的节点。
    可以有递归和非递归两种方法（即中序遍历的递归和非递归），递归由于涉及到方法之间的跳转，所以需要一个实例域来保存上一个遍历过的节点。最终返回第一个访问的节点即可。


》给定一个二叉树，求它的最小深度。：111
    最小深度是从根节点到最近叶子节点的最短路径上的节点数。
    注意:叶子是没有子节点的节点。
    》方法一：
    使用记录层数的层序遍历（两个队列），当遍历到第一个叶子时，返回层数
    》方法二：
    使用递归：
        当节点为null时（只有最顶层的节点为null才会走到这，因为下面的逻辑约束不会有其他的null节点进入该递归）返回0
        当节点是叶子时(左右孩子都为空)，返回1
        当节点不是叶子时（左右孩子有一个不为空），返回其左右子树中的最小深度+1
    注意，不能直接递归左右两个孩子，而要判断它们是否为空，不为空后在判断，否则当root左孩子为2层，右孩子为null时，最小深度会变成1（因为右边是0），而应该是3（右边根本就不算）
    


》给定一个整数n，生成所有结构上唯一的BST(二叉搜索树)，存储值1…n。：95,c-p175.2
    下面这个做法要从大一点的角度去看，对于每个节点，获得它的左边的可能性的所有节点的组合和右边可能性的所有节点的组合
    求出所有这种组合即可
    是一种很巧妙的递归做法
    》
    public List<TreeNode> genTrees(int start, int end) {
        List<TreeNode> list = new ArrayList<TreeNode>();
        if (start > end) { //若头大于尾，返回null
            list.add(null);
            return list;
        }
        if (start == end) {  //头等于尾，说明就是这个节点
            list.add(new TreeNode(start));
            return list;
        }

        List<TreeNode> left, right;
        for (int i = start; i <= end; i++) {
            //以i下标的树为根
            left = genTrees(start, i - 1);  //获它的左子树的所有可能性
            right = genTrees(i + 1, end);   //获得它右子树的所有可能性

            //组合这些可能性，与根一起构成树
            for (TreeNode lnode : left) {
                for (TreeNode rnode : right) {
                    TreeNode root = new TreeNode(i);
                    root.left = lnode;
                    root.right = rnode;
                    list.add(root);
                }
            }
        }
        return list;
    }


》一个二叉搜索树(BST)的两个元素被错误地交换了。在不改变树结构的情况下恢复树。：99
    使用O(n)空间的解非常简单。(把节点全部存下来)

    ## 二叉搜索树的中序遍历是有序序列
    》方法一：
        先用中序遍历一遍，遍历出的结果与排序结果逐位置对比，必然只有两个位置不对：
        第一个：321，正常序：123  ：1和3不对
        第二个：1324  正常序：1234： 2和3不对
        记录这两个值
        再中序遍历一遍树，当遍历到位置不对的两个节点时，替换其值为另一个即可（如果要替换节点，还要前序遍历一遍找到它们两个各自的父节点并保存下来，交换各自的父节点和子节点）

    》方法二：
        用c-p134的方法，一次中序遍历找到两个错误的节点，然后交换其值即可



》调整搜索二叉排序树中两个错误的节点，并且在要完全交换两个节点的位置（而不只是交换值）：c-p134
    这个题是题目99的改进版，要求交换两个节点，不光是交换值

    二叉树的中序遍历是升序的，因此在中序遍历的过程中，一定会发生降序，中序遍历时节点发生降序，第一个错误的节点是第一次降序时较大的节点，第二个错误的节点是降序时较小的节点。可以用中序序列把节点全部放进list（99题），但没必要，首先要中序遍历一遍，找到两个错误的节点并保存，然后再中序遍历一遍，找到他俩的父节点，然后先交换彼此的父节点(即交换2个父节点的相应域)，再交换彼此的即可。（先交换父节点，再交换子节点，即使两个错误节点有父子关系，最终结果也是保证正确的）

    需要注意的是，找第二个错误节点时，先用第一个错误节点的后继赋予它，然后接下来如果还有错误节点，则再次赋给它，这样做的目的是怕两个错误节点连在一起时，找不到第二个错误节点：

    如： 1 2 3 6 5 4   遍历到5时，令error1=6（即5的pre），也令error2=5，接着遍历到4时，再令error=4

    如 1 2 3 5 4 6
    遍历到4时，令error1=5（即4的pre），也令error2=4，接着遍历就没有降序了。如果此时遍历到4时，只令error1=5。那么error2将找不到了




》给定两棵二叉树，写一个函数来检查它们是否相同。：100
    很简单的递归，对于2个节点来说，它们的值相等，且左右子树都相同才算一样



》给定一个二叉树。填充每个next指针，指向它的右边的兄弟节点。如果没有next right节点，则应该将下一个指针设置为NULL。：117
    最初，所有next指针都设置为NULL。
    用两个队列的层序遍历即可



》给定一个只包含0-9位数字的二叉树，每个根到叶的路径都可以表示一个数字。：129
    一个例子是根到叶的路径1->2->3，它表示数字123。求所有根到叶的数的和。
    直接递归即可，每往抵达一个节点，记录数=pre* 10 + node.val，然后再把记录数往下一个节点传递



》在二叉搜索树(BST)上实现迭代器。迭代器将使用BST的根节点初始化。：173
    调用next()将返回BST中的下一个最小的数字。
    注意:
    next()和hasNext()应该在平均O(1)时间内运行，并使用O(h)内存，其中h是树的高度。
    您可以假设next()调用总是有效的，也就是说，当调用next()时，BST中至少会有下一个最小的数。

    》方法一
    可以一开始就把中序遍历保存起来，也能AC

    》方法二：
    使用栈，构建迭代器时，就把树的从根一直靠左入栈直到最小节点进去
    next则是一个中序遍历的部分，先获得栈顶元素，输出该元素前，处理其右子树，对右子树顺着左边依次入栈，直到一个左节点不为空
        public int next() {
            TreeNode node = stk.pop();
            TreeNode cur = node;
            //当某个节点输出时，它的左子树肯定已经输出过了，然后处理右子树，当然还是顺着左边处理
            if(cur.right!=null){
                cur = cur.right;
                while(cur!=null){
                    stk.push(cur);
                    if(cur.left!=null){
                        cur = cur.left;
                    }else{
                        break;
                    }
                }
            }
            return node.val;
        }
    hasNext则是判断栈是否为空



》给定一棵二叉树，想象自己站在树的右边，返回从上到下有序排列的节点的值。：199
    用从右往左的双队列层序遍历可以做


》求一个满二叉树的求和树。二叉树的求和树， 是一颗同样结构的二叉树，其树中的每个节点是原始树中的左子树和右子树的和。：b17
    读入一行：Scanner.nextLine，然后可以用split分割
    》方法一
        先通过中序和前序构建原树，然后根据原树的结构构建与其同构的新树。可知原树中的节点和新树中的节点可以一一对应
        新树节点值 = 原树中对应节点的 左子树所有节点值 + 右子树所有节点值 （以递归形式赋值）。
    》方法二：
        因为是满二叉树，其实结果跟前序遍历数组无关，只和中序遍历数组有关，并且中序数组一定是奇数个，
        结果索引为偶数的一定为0，索引为奇数的值是中序遍历数组其他值之和(不包括自己)，使用二分法找到根节点，然后计算子树之和，不用还原二叉树。




》验证二叉树的前序序列化：331
序列化二叉树的一种方法是使用前序遍历。当遇到非空节点时，我们记录该节点的值。如果它是一个空节点，我们使用一个标记值来记录，比如#。例如，上面的二叉树可以序列化为字符串“9、3、4、#、#、1、#、#、2、#、6、#、#”，其中#表示空节点。
给定一串逗号分隔的值，验证它是否是正确的二叉树的前序遍历序列化。在不重构树的情况下找到算法。
字符串中每个逗号分隔的值必须是整数或字符'#'表示空指针。您可以假设输入格式总是有效的，例如它不可能包含两个连续的逗号，比如“1，，3”。
    
    》方法一：
        设置一个数据结构，保存每个节点值，并表示它的左右孩子是否已找到
        每遍历到一个节点，先看栈顶元素的左右孩子是否都找到，都找到了就让其弹栈，循环直到栈空或栈顶元素有孩子没找到
        若当前节点是数字，让栈顶元素的为false的域设为true，然后把这个数字创建一个节点加入栈中。这里要注意，设置一个布尔位标识当前节点是否是树的根节点。当栈为空时，当前节点必须是根节点。若不是，说明后面的元素都是多余的，则返回false。
        若当前节点是#，让栈顶元素的为false的域设为true，若当前栈为空则不满足，#的节点不入栈。
        遍历完后，弹出所有栈中的元素，若栈中有左右孩子还没找到的节点，返回false。

    》方法二： 借鉴c-p103的方法（更好）
        直接把原序列放入队列中，然后进行前序遍历的二叉树的构建，每到要构建节点则出队一个元素，当构建到一个节点时队列中的元素不够了，则说明不符合，直接跳出返回。 因为构建时返回的类型是节点类型，所以要设置一个全局的变量flag，当元素不够时，设置其为false。并且在构建完最后要判断一下队列是否为空，如果不为空说明没用完节点。 最后返回 flag && 队列是否为空





》构造数组的MaxTree c-p22
一个数组的MaxTree定义如下：
    》数组必须没有重复元素
    》MaxTree是一棵二叉树，数组的每一个值对应一个二叉树节点
    》包括MaxTree在内的每一棵子树上，值最大的节点都是树的根

    以下面原则来建立这棵树：
        1.每一个数的父节点是它左边第一个比它大的数和它右边第一个比它大的数中较小的那一个。
        2.如果一个数左边没有比它大的数，右边也没有，也就是说这个数是整个数组的最大值，那么这个数是MaxTree的根节点。

    通过这个方法，所有的数最多只有两个孩子，也就是说，这棵树可以用二叉树表示，而不用多叉树。
    要证明的话，只需证明任何一个数在单独一侧，害死数量都不可能超过1即可。

    证：假设a在单独一侧有两个孩子，不妨设在右侧，假设这两个孩子一个是k1，另一个是k2。即：...a...k1...k2...

    因为a是k1和k2的父，所以a>k1,a>k2,且k1与k2不相等，所以k1和k2可以分出大小，假设k1较小，k2较大
    那么k1可能会以k2位父节点，且绝对不会以a为父节点。再假设k2是较小的，k1是较大的，同理a也轮不到当k2的父节点。总之，k1和k2肯定有一个不是a的孩子，所以，任何一个数的单独一侧，其孩子数量都不可能超过1个，最多只会有1个，因此，任何数最多有2个孩子，而不会有更多。

    如何尽快找到每个数左右两边第一个比它大的数呢？利用栈
    找每个数左边第一个比它大的数，从左到右遍历每一个数，栈中保持递减序列，新来的数不停地利用pop出栈顶，直到栈顶比新数大或没有数。
    以[3,1,2]为例，首先3入栈，接下来1比3小，无须pop出3，1入栈，且确定1往左第一个比它大的数是3，然后2比1大，1出栈，2比3小，2入栈，确定了2往左第一个比它大的数是3。（这个过程中，当栈中没有数时，当前数对应的第一个比它大的数设为MAX，以便在后续比较过程中处理，在后续过程中，如果它两边都是MAX，则他就是根节点；如果不都是MAX，则其中较小的那个值会成为其父，而MAX不会起到作用。）
    同样的方法可求得每个数往右第一个比它大的数

    可以把生成的树节点以值为key存入hashmap，方便后续得到，




》打印二叉树的边界节点：c-p96
    按照两种标准打印：
    标准1：
    1.头结点为边界节点
    2.叶节点为边界节点
    3.如果节点在其所在的层中是最左或者最右的，那么也是边界节点
    标准2：
    1.头结点为边界节点
    2.叶节点为边界节点
    3.树左边界延伸下去的路径为边界节点
    4.树右边界延伸下去的路径为边界节点

    标准1：
    这里要求的顺序是逆时针的顺序不重复打印.关键是利用一个二维数组levelBound，把每一层的左边界和右边界都保存起来
    1.先利用递归获取高度的方法，填充levelBound。
    2.从上到下打印所有层中最左边的节点
    3.打印既不是左边界，也不是右边界的叶子节点
    4.倒序打印不是左边界的所有右边界

    标准2：
    1.从头结点开始往下寻找，找到第一个既有左孩子，又有右孩子的节点，即为h，进入步骤2，这个过程中找过的节点都打印。
    2.h的左子树先进入步骤3的打印过程；h的右子树再进入步骤4的打印过程。
    3.打印左边界的延伸路径以及h左子树上所有的叶子节点，详见printLeftEdge函数
    4.打印右边界的延伸路径以及h右子树上所有的叶子节点，详见printLeftEdge函数



》直观地打印二叉树，可以直观地展示树的形状，也便于画出真实的结构：c-p100
    打印二叉树顺时针旋转90°的样子，如何清晰表示一个节点的父节点呢？如果一个节点打印结果的前缀和后缀都是H，说明这个节点是根节点，不存在父节点。如果一个打印结果前缀和后缀都有v，说明父节点在当前列所在的前一列，在该节点的下方，且是离该节点最近的节点。如果一个打印结果前缀和后缀都有^，说明父节点在当前列所在的前一列，在该节点的上方，且是离该节点最近的节点。

    对于节点打印时所占的统一长度必须统一，例如如果一些节点的值很短，如1，2.有的节点值很长，如323123123，那么如果不统一长度的话，一定会格式对不齐，进而产生歧义。在java中，最长的整数是Integer.MIN_VALUE（-2147483648）长度为11，加上前后缀，长度为13，为了更好区分，把前面加上两个空格，后面加上两个空格。因此，长度为17的空间一定能存放任何一个32位整数。例如，对于v8v，要在前面补7个空格，在后面补7个空格，总长度为17，即：(       v8v       ),对于v66v，要在前面补6个空格，后面补7个空格：（      v66v       ）

    打印的过程结合了先右子树，再根节点，最后左子树的递归遍历过程。如果递归到一个节点，先遍历它的右子树，右子树遍历结束后再回到这个节点。如果这个节点所在的层为l，则先打印l* 17个空格，不换行，然后开始制作该节点的打印内容，这个内容包括节点的值，及前后缀字符，及补充的空格。如果该节点是其父节点的右孩子，前后缀是v，因为它必然在它父节点的上面，如果是左孩子，前后缀是^，如果是头结点，前后缀为H。打印完这个内容后换行，最后进行左子树的遍历过程


》遍历二叉树的神级方法：c-p107
    之前的递归和非递归的的空间复杂度都是O(h),h是二叉树的高度。如果完全不用栈结构能完成三种遍历吗？
    答案是可以，使用二叉树节点中大量指向的null指针。本题实际上就是Morries遍历

    首先看普通的递归和非递归解法，其实都使用了栈结构，在处理完二叉树某个节点后可以回到上层取。为什么从下层回到上层如此之难？因为二叉树的结构如此，每个节点都有指向孩子节点的指针，而没有指向父节点的指针，所以从上到下易，从下到上难。

    Morris遍历实际上就是避免使用栈结构，而是让下层到上层有指针，具体是通过底层节点指向null的空闲指针指回上层的某个节点，从而完成下层到上次的移动

    首先看中序：
    1.假设当前子树的头结点为h，让h的左子树中最右节点的right指针指向h，然后的左子树继续步骤1的处理过程，直到遇到某个节点没有左子树时记为node。
    2.从node开始通过每个节点的right指针进行移动，并依次打印，假设移动到的节点为cur。对于每一个cur节点都判断cur节点的左子树中最右节点是否指向cur
        ①如果是，让cur节点的左子树中最右节点的right指针指向空，也就是把步骤1的调整后再逐渐调整回来，然后打印cur，继续通过cur的right指针移动到下一个节点，重复步骤2
        ②如果不是，以cur为头的子树重回步骤1执行。
    3.步骤2最终会移动到null，整个过程结束

    用一个二叉树手动模拟一下算法，会发现实现很简单，具体算法如下：
    1.如果当前子树为空，返回
    否则假设当前子树的头结点为h，从h的左子树一直往右找，找到右孩子为空，或右孩子为h的节点，记为node
        ①如果node的右孩子为空，则让node的右孩子等于h,且以h的左子树为当前子树，返回步骤1
        ②如果node的右孩子等于h，则令node的右孩子为空，进入步骤2
    2.打印h，并且以h的右子树为当前子树，返回步骤1

    Morris前序遍历的实现就是Morris中序遍历实现的简单改写，只是修改打印的时机，打印时机放在步骤1发生的时候，正在处理以h为头的子树，且是以h为头的子树首次进入调整过程，则直接打印h

    Morris后序遍历也是Morris中序遍历的改写，但包含调整过程，简单来说，就是依次逆序打印所有节点的左子树的右边界。（最好看代码，这个描述太抽象）



》在二叉树中找到累加和为指定值的最长路径长度：c-p115
    树中可能出现负值
    求累加和为sum的最长路径长度，路径是指从某个节点往下，每次最多选择一个孩子节点或不选所成的节点链。用递归方法求解，能解出，但时间复杂度太高（见437）
    本解法是可以做到tO(N), sO(h)

    具体：
    1.二叉树头结点head和规定值sum已知，生成变量maxLen，记录累加和等于sum的最长路径长度。
    2.生成哈希表sumMap，记录从head开始的一条路径上的累加和的出现情况。累加和从head的值开始累加，sumMap的key代表某个累加和，value代表这个累加和在路径中最早出现的层数
    3.首先在sumMap中加入一个记录(0,0)（这一步很重要！！这是起始情况），它表示累加和0不用包括任何节点就可以得到。然后按照二叉树的前序遍历方式遍历节点，遍历到的当前节点记为cur，从head到cur父节点的累加和记为preSum，cur所在的层数记为level。将cur.value+preSum的值记为curSum，就是从head到cur的累加和，如果sumMap中已经包含了curSum的记录，说明curSum在上层中已经出现过，那么就不更新sumMap；否则把curSum放入。如果map中含有curSum-sum的key，说明从head到当前节点的路径上，有子路径的和是sum，该子路径的长是（当前层数-（curSum-sum所在的层数）），让它和当前maxlen中的大值赋给maxlen。
    4.递归遍历当前节点的左右子树
    5.如果curSum的值是当前层高，则从sumMap中删除curSum-curlevel，为了让上层的另一个分支不受当前分支的干扰.


    其本质实际上是一种trackback，每次sumMap中只保存head到当前节点的路径上出现过的子路径的所有和值，并且相同的和下只保存head到更上面的节点的路径和，这是为了让下面满足条件的子路径计算时，能得到更大的子路径长，如：
    路径1-2的和是10
    路径1-2-3-4 的和也是 10
    路径1-2-3-4-5-6的和是15， 要求的sum是5，所以更长的子路径是3-4-5-6，因此map保存的就应该是节点2的层数，（即路径1-2，而不保存路径1-2-3-4）



》找到二叉树中的最大搜索二叉子树：c-p117
    给一棵二叉树，树中的节点值都不一样
    搜索二叉子树的叶子必须是原二叉树的叶子，即不能从中间截出一块来，只能从下往上取
    显然可以使用递归法方法，方法返回的是以本节点为根是否能构成一个二叉排序树。如果节点是null，可以视其为二叉排序树，返回true。对一个节点，如果它的左右子树都不是二叉排序树，那么它一定不是二叉排序树，返回false。若左子树是，且其最大值节点小于本节点值，则说明根值和左子树可构成搜索树；若右子树是，且其最小值节点大于本节点值，则说明根值和右子树可构成搜索树。将能构成的二叉排序树的中序序列返回给上层（作为参数），函数返回true。


》找到二叉树中符合二叉排序树条件的最大拓扑结构：c-p119
给一棵二叉树，树中的节点值都不一样，这道题搜索二叉树就可以从中间截出来一块了（即子树的叶子可以不是原二叉树的叶子），此时返回的是符合二叉排序树的子结构的大小
修改一下上面的方法，

    先看一种简单解法，对于每一个节点，都搜索以它为根的最大二叉搜索树拓扑结构，往下添加节点，必须要当前遍历到的节点符合上下限要求才能添加，直到无法再往下走就返回。整个左子树都要小于根值，整个右子树都要大于根值。 一开始的时候，上下限分别是MAX和MIN，代表没有上下限，往下传递时才会补充上下限
    时间复杂度为O(N^2)



》判断是否是完全二叉树：c-p147.2
    层序遍历二叉树，如果当前节点没有左孩子但有右孩子，直接返回false
    如果当前节点并不是左右孩子都有，则之后遍历到的节点必须都是叶子，否则返回false
    如果遍历过程中不返回false，则最后返回true






```


#模式匹配问题
```
模式匹配一般都是难题

》正则表达式匹配：10，j19-p125
.代表任何一个单个字符
*代表它前面的字符重复0-N次， 即 a* 可以代表 "", "a", "aa", "aaa"...  *号不会独立存在，它和前面的字符是共同体
该题的核心思想在于逐步拆解匹配串

step1：
先匹配原串和匹配串的第一个字符

//如果不匹配：
	1.如果匹配串第二个是*，则继续匹配，原串=原串，匹配串=匹配串第3个字符开始的子串（跳过第1、2个字符）。返回step1
	2.如果匹配串第二个不是*，则失败
//如果匹配：
	1.如果匹配串第二个是*
		1.原串=原串第2个字符开始的子串（跳过第1个字符），匹配串=匹配串，返回step1 (即要这个匹配的字符，后面的仍可能是匹配串的第一个字符)
		2.原串=原串，匹配串=匹配串第3个字符开始的子串（跳过第1、2个字符），返回step1 （即看如果不要这个匹配的字符，后面的是否匹配） 
		如果1和2中有任意一种可匹配成功，则成功
	2.如果匹配串第二个不是*，原串和匹配串都跳过第一个字符，继续匹配，返回step1



》LCP：公共最长前缀：14
	1.首先，把待匹配串中的最短串作为模式串，初始化lcp为空
	2.遍历模式串的所有位置上的字母，并对每一个字母，遍历其他待匹配串的对应位置，如果都相同，则lcp加入该字母
	3.一旦有待匹配串相应位置的字母不等于模式串该位置上的字母，匹配终止，跳出循环，返回lcp



》又一种正则表达式匹配：44
    “* ”代表任意一串字符（包括空字符）
    “?” 代表任意单个字符
    匹配串s只有小写字母
    模式串p只有小写字母和* 和?，看s和p是否匹配

    》使用4个计数，s和p作为指针，初始化为0，lastStar为上一个“* ”的在pattern中位置，初始化-1；match代表最新的一个“* ”可以在s中开始匹配的地方
    遍历str串，
        如果pattern[p]==str[s] 或pattern[p]=='?'：s++，p++

        如果pattern[p]=='* ' ：s不动，p++，记录lastStar=p，match=s

        如果 lastStar!=-1 说明pattern[p]此时和str[s]不匹配，且pattern[p]不是* （才能走到这来），但前面有* ，则* 要匹配的串再加上一个字符，再匹配s和pattern中* 后面的。
        ：p=lastStar+1，match++，s=match

        否则（str[s]和pattern[p]不匹配，且前面没出现过* ，则pattern[p]也不是*），一定不匹配

    遍历完str
    此时如果p及后面都是* ，则还是可以匹配的（因为* 可以代表空串），但如果pattern[p]及后面还有其他字符，则不匹配

    ￥举个例子
    （cdf  *cde）
    一开始就是* 则p++， match=0，lastStar=0
    一直到f和e这，不匹配，要回头，p=lastStar+1，即c处，match=1，s=1处，即相当于* 此时和c匹配了，继续匹配df和cde
    d和c不匹配，要回头，p=lastStar+1 即c处，match=2，s=2处，相当于* 此时和cd匹配了，继续匹配f和cde
    f和c不匹配,要回头，p=lastStar+1 即c处，match=3，s=3处，相当于* 此时和cdf匹配了，继续匹配“”和cde
    s到str的头了，跳出
    此时如果p及后面都是* ，则还是可以匹配的（因为* 可以代表空串），但如果pattern[p]及后面还有其他字符，则不匹配




》表示数值的字符串：j20-p127， 65
    请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

    表示数值的字符串遵循模式 A[.B]][e|EC]或者.B[e|EC],
    其中A为数值的整数部分，B紧跟着小数点为数值的小数部分，C紧跟着‘e’或者E为数值的指数部分。另外，在小数里可能没有数值的整数部分，如.123=0.123
    因此A不是必须的，如果一个数没有整数部分，那么它的小数部分不能为空
    上述A和C都是可能以‘+’或者‘-’开头的0到9的字符串，B也是0到9的数位串，但前面不能有正负号

    取字符串中的.号和e或E号，.的位置为pi，e或E的位置为ei

    合法自然数：只有数字
    合法小数：至多有一个. ,且前后都是合理的自然数
    合法带e：如果有e，后面必须是合理的正负数，前面必须是合理的小数
    合理的正负数：只有一个正负号再最前面，且后面是合理的小数

    写两个函数作为辅助：判断是否为合法带符号整数（如果带符号，后面就得是合法自然数；否则整体就得是合法自然数），判断是否为合法自然数（字符串只含数字即可）

    分以下几种情况：
        pi<0, ei<0 :不带小数点不带e，直接判断是否是合法带符号整数即可
        pi>=0, ei<0 :带小数点不带e
            如果小数点在第一位，判断后面是否是合法自然数
            否则 小数点前面的是否是合法带符号数 && 小数点后面的是否是合法自然数
        pi<0, ei>=0 :不带小数带e e前面是合法带符号整数 && e后面是合法带符号整数 
        pi>=0 ei>=0 :带小数点带e
            小数点一定得在e前面，否则非法
            如果小数点在第一位：(pi,ei)合法自然数数 && （ei, last]合法带符号整数
            否则 [0,pi)合法带符号整数 && (pi,ei)合法自然数数 && （ei, last]合法带符号整数

    # 65比j20-p127麻烦一点，里面还有空格，还有'3.'这种方式，做一下处理不难解决，大体思路是统一的


》给定一个字符串S和一个字符串T，计算S的不同子序列的个数，它们等于T。：115
    一个字符串的子序列是一个新的字符串，它由原来的字符串组成，删除一些字符(可以是none)，而不影响其余字符的相对位置。(例如，“ACE”是“ABCDE”的子序列，而“AEC”不是)。
    这种题基本上用一般的回溯就会超时，考虑dp

    我们将构建一个数组mem，其中mem[i+1][j+1]表示S[0...j]（前j+1个字符）包含T[0 . .i]（前i+1个字符）的不同子序列的个数。因此，结果将是mem[T.length()][S.length()]。
    第一行必须填入1。这是因为空字符串是任意字符串的子序列，但只有1次。即mem[0][0]=1

    mem[i+1][j+1] 表示s的前j+1字符包含t的前i+1个字符的不同次序的个数
    所以mem[0][j] = 1（对于任意j），这样不仅使更简单，而且如果T是一个空字符串，我们还返回正确的值。
    
    除第一行外，每一行的第一列必须为0。这是因为空字符串不能包含非空字符串作为子字符串——数组的第一项:mem[0][0] = 1，
    因为空字符串一次包含空字符串1一次。

      S 0123....j
    T +----------+
      |1111111111|
    0 |0         |
    1 |0         |
    2 |0         |
    . |0         |
    . |0         |
    i |0         |

    当S[j]!=T[i]的时候 mem[i+1][j+1] = mem[i+1][j] //因为加入的新字母没有用
    当S[j]==T[i]的时候 mem[i+1][j+1] = mem[i+1][j] + mem[i][j]  
    //因为加入的新字母有用,所以这时有两种情况：
        1. 不考虑新加入的字母，那么还是有 mem[i+1][j]种情况
        2. 考虑新加入的字母，已知 T[i] 和 S[j]相同，那么就看 前面S中[0 - j-1] 包含 T[0-i-1]有多少种可能性

    ## 对于字符匹配的问题，上面那种这种矩阵很好用



```


#寻找重复元素
```
》如果元素范围和数组长度相同，即元素范围是0~n-1（当然可以有整体偏移），数组长度为n，则可以循环利用nums[nums[i]] swap nums[i] 的方法让每个数到自己相应的位置上，若出现某数字与其相应的位置上数字相同，则说明该数字有重复，该复杂度为tO(n)-sO(1) ,尽管有两个循环。  j3-1


》如果数字范围为1-n，而数组大小为n+1时。当 l-m的范围内的数字个数大于 m-l+1，则说明该范围的数字有重复的，则可以分段使用二分查找，看哪段的数字有重复
            对于这里的二分查找，有必要解释为什么low=mid+1而不是low=mid
            因为计算机都是向下取整的，当low和high差1时，mid==low，如果目标不在low-mid之中，则要low增大，而如果增大至mid会没变化(因为本来low和mid就相等)，导致死循环。
            如果目标在low-mid中，要减小high，此时因为差1，所以high可以顺利减小  j3-2


》查看一个数组中是否含有重复的数：217
    直接用set即可



```

#设计数据结构
```

》带模式匹配的搜索集： 211
	空白addWord(单词)
	bool搜索(单词)
	search(word)可以搜索只包含字母a-z或..A  .意思是它可以代表任何一个字母。
	具体存储结构可以用字典树完成，难点在于搜索时的.  可以使用深度优先遍历（dfs）。改造字典树的hasword方法，


》字典树 trie，非常非常适合存储单词，查找单词，查找前缀：208，211
注：字典树和二叉树，链表是典型的自己中有自己的结构
###java
	//下面的实现是自己写的，只简单验证过，不能保证完全正确
   //使用字典树，既能节约时间，也能节约空间
    class Trie{
        Trie[] nodes= new Trie[26];
        boolean isWord = false;

        Trie(){

        }

        void insert(String word){
            Trie t = this;
            for(int i=0;i<word.length();i++){
                int num = word.charAt(i)-'a';
                if(t.nodes[num]==null) t.nodes[num] = new Trie();
                t = t.nodes[num];
                if(i==word.length()-1) t.isWord = true;
            }
        }

        boolean hasPrefix(String prefix){
            Trie t = this;
            for(int i=0;i<prefix.length();i++){
                int num = prefix.charAt(i)-'a';
                if(t.nodes[num]==null) return false;
                t = t.nodes[num];
            }
            return true;
        }

        boolean hasWord(String word){
            Trie t = this;
            for(int i=0;i<word.length();i++){
                int num = word.charAt(i)-'a';
                if(t.nodes[num]==null) return false;
                t = t.nodes[num];
            }

            return t.isWord;
        }

        //符合特殊要求的字典树：211（涉及到了模式匹配）
    }
###


》LRU: 为最近最少使用的缓存设计和实现数据结构。它应该支持以下操作:get和put。:146
    直接继承LinkedHashMap，改写其中的方法：removeEldestEntry，当其中元素个数大于预设值时，就删除最老的没使用过的元素


》包含min函数的栈：设计一个栈，支持push、pop、top和在常量时间内检索最小元素。：155，j30-p165
    用两个栈，一个主栈数据栈，一个辅助栈
    把每次的最小元素（之前的最小元素和新压入栈的元素两者的较小值）都保存起来放到另一个辅助栈中

    假设入栈3，4，2，1
    首先往空的数据栈中压入数字3，显然现在3是最小值，也把这个数压入辅助栈。然后往数据栈压入数字4，比较4和辅助栈的栈顶元素，发现4大于3，因此仍然往辅助栈中压入3。第三步往数据栈中压入2，2小于辅助栈栈顶元素3，因此把2压入辅助栈。同样，压入数字1时，也要把1压入辅助栈

    辅助栈栈顶永远是当前栈中元素的最小值。
    弹栈时，不仅弹主栈，也弹辅助栈。
    求最小值时，直接返回辅助栈的栈顶元素即可（不弹）


》数据流中的中位数：median是一个数组序列中的中间值，数组长度是偶数就是两个中间的值之和：295, j40-p214
    设计一个数据结构完成：
    addNum，添加一个值到结构中
    findMedian，找到结构中所有值的中间值

    使用ArrayList，排序是容易想到的办法，但效率很低，虽然能过。

    效率高的话，考虑使用优先级队列
    两个优先级队列max,min，一个从大到小排序，一个从小到大排序（其实就是最大堆和最小堆）
    但每个队列只存储数列的一半，max中始终保存着当前数字小的一半，min中始终保存着当前数字中大的一半，若二者尺寸相同，则max出队和min出队就是最中间的两个元素；若不一样，只能是max比min多一，所以max出队就是中间的元素

    先把一个数字加入max，然后从max中poll出的一定是max中最大的数（规定了优先级），
    然后加入min，如果此时总数是偶数，则max和min的个数一样
    如果是奇数，则从min中poll出min中最小的数，放入max中。

    这样能保证，如果总数是偶数，则两个队头的元素就是数组中最中间的两个数
    如果总数是奇数，max队头的元素就是最中间的那个数

    ## 记住这种找中间值的办法（两个优先级相反的优先级队列）：先往大里放，再往小里放，小得多的话再往大里放



》平整嵌套列表的迭代器：341
    给定一个嵌套的整数列表，实现一个迭代器将其变平。有next方法和hasNext方法
    [[1,1],2,[1,1]]-》[1,1,2,1,1]； [1,[4,[6]]]-》[1,4,6]
    每个元素要么是整数，要么是列表——其元素也可以是整数或其他列表。

    其底层是一个链表队列LinkedList：l
    next()保证如果有 hasNext为true，则返回l.pop.getInteger()

    hashNext负责：
    while：
        1.如果l下一个是整数，则直接返回true
        2.如果l下一个仍是list，则把这个list的元素逐个添加进l，然后继续上面的while

    这里有一个地方一定要注意，逻辑一定要放在hasNext而不是next中
    假如传入[[]] 如果逻辑在hashNext中，则能判断出这个的hasNext为false，继而不会调用next，最终结果是链表：[]
    如果逻辑都在next中，此时hashNext只判断nestedList的长度，长度为1（唯一的元素是[]），再调用next，而后返回结果null，
    最终结果是[null],就会导致错误


》设计一个数据结构，可以以O(1)的时间复杂度完成下列工作：380
    insert(val):将一个项val插入到集合中(如果还没有)。
    remove(val):如果存在，则从集合中删除一个项目val。
    getRandom:从当前元素集中返回一个随机元素。每个元素必须具有相同的返回概率。

    让数据结构中有以下域：
    一个整数list，保存加入的数字
    一个hashmap，保存该数字及其在list中的相应位置
    一个random对象

    insert(a)：如果map中有这个key，返回false，，添加到map中，k为a，v为list当前大小，然后把它加入到list中
    remove(a)：这是关键一步：通过map找到a在list中的位置，如果该数不是最后一个，则把最后一个数放到该位置上，这样该数就会没有，最后一个数就会多一个，然后再删除最后一个数（这是效率高的删除方式，但前提是对位置不敏感），并且从map中删掉k为a的记录
    getRandom：r = random.getInt(list.size()) 以list的大小为上界，求出一个随机值，然后返回list.get(r)


》给定一个具有next()和hasNext()方法的迭代器类接口，设计并实现一个支持peek()操作的PeekingIterator——它本质上是对元素的peek()，该元素将在下一次调用next()时返回。：284

    假设迭代器根据一个列表初始化:[1,2,3]。

    调用next()将得到列表中的第一个元素1。
    现在调用peek()，它返回2，即下一个元素。在此之后调用next()仍然返回2。
    最后一次调用next()，它返回3，即最后一个元素。
    在此之后调用hasNext()应该返回false。

    先把迭代器所有元素存进一个队列，之后用队列的peek，poll，isEmpty来代替该数据结构的peek，next，hasNext即可

    # 后续工作:如何将您的设计扩展为通用的，并能处理所有类型，而不仅仅是整数?：考虑用泛型


》实现一个队列，并可以得到其中的最大值：j-p292
    定义一个队列并实现函数max，得到其中的最大值，要求函数max、offer，poll的时间复杂度都是O（1），由于max和poll不同，所以不能用PriorityQueue
    还是用上述j59-p288的思想，把滑动窗口看成是一个队列，队列的大小就是窗口的宽度，

    里面的数据需要单独开一个类InternalData，既有数据又有索引
        class InternalData{
            int index;
            int data;

            InternalData(int index, int data){
                this.index = index;
                this.data = data;
            }
        }

    一个双端队列dequeue，类型InternalData，用来索引当前最大值
    一个队列，InternalData，是正经的标准队列
    一个计数器curIndex， 表示当前已经是加入的第i个数（只增不减）


    offer(e): 先用数字和当前索引curIndex初始化一个元素
        将该元素加入到queue中
        双端队列中放入的是索引
        若待加入的元素大于队头元素对应的数字，则清空队列加入该元素
        若待加入的元素小于队头元素对应的数，则和队尾元素对应的数的比较：
            若大于队尾对应的数，从队尾出队直到队尾对应的数大于该数，向队尾插入该元素
            若小于队尾对应的数，向队尾插入该元素

    poll：出队头，返回其对应的数字

    max：若当前curIndex和队头索引差大于过size，则出deque队直到队头元素索引差小等于size，peek出deque队头对应的数字



```


#回溯问题（回退递归）
```
非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择，直至到达最终的状态

》对于一个数组/字符串 将其中的元素排列组合成其他若干的组合类型，适合用回溯

》在二维数组（可能具体表现为迷宫或者棋盘等）中搜索路径，适合用回溯

》地上有一个m行n列的方格，一个机器人从坐标(0,0)的格子开始移动，它每次可以向上下左右移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子：j13-p92
    用一个boolean二维数组保存某个位置是否已到达过，用回退递归去到达位置，当递归到一个位置时，如果该位置还未到达过，且该位置坐标有效，则到达，计数+1，标定该位置已到达过，然后回溯它周围的四个位置。


```


#找规律问题
```
》编写一个程序，输出从1到n的数字的字符串表示形式。。：412
但对于3的倍数，它应该输出“Fizz”而不是数字;对于5的倍数，它应该输出“Buzz”。对于同时是3和5的倍数的数字，输出“FizzBuzz”
        for(int i=1;i<=n;i++){
            if(i%15==0){
                res.add("FizzBuzz");
            }else if(i%5==0){
                res.add("Buzz");
       
            }else if(i%3==0){
                res.add("Fizz");
            }else {
                res.add(""+i);
            }
        }





```




#对于dfs深度优先遍历和trackback
```
一般情况下，
trackback如下过程：
	设置开始的下标，在循环中添加本次下标的变量，递归，递归回来后，去掉上面添加的变量，继续循环
	一般是
trackback(int start){
    边界判断
	结束条件（其中或许有增加结果）

	for(int i=start...){
		添加i为下标的量
		trackback(i+1);
		去掉i为下标的量  //主要是这一步去掉了上面添加的东西，所以这个过程叫trackback(回溯)
	}
}

dfs是如下过程：
	方法一，递归法：
		递归法基本就是trackback，因为遇到每个分叉，都要深入下去，当深入到无法再深入时，再返回，去掉先前深入的分支，转而深入另一个分支。
		有时候dfs又和trackback是有所区别的。
			第一个原因是有时候没有那么多分支，而只有一些小分支，所以没有上面的大循环，只有在分支出现时才需要循环。
			第二个原因是每个分支如果对应后续的情况互不干扰，那就不需要回退了，只需要遍历每种分支情况到底即可，典型情况就是211题的dfs，对于trie来说， ad和cd中第二个 'd' 是不同的情况，它们不会互相干扰，（一般的trackback则是，遍历完ad后，去掉d,去掉a,再遍历c，再遍历d，也就说分支只有一条就是主分支，而这里会出现多条分支，不干扰的情况下，也就不用回退了）所以不需要回退。

	方法二，非递归法
		核心就是使用栈去保存每一步的深入，当深入到无法深入时，则弹栈，弹栈就相当于上面的返回，返回后再处理下一个分支，非递归法需要有一个flag数组监督已经访问过的元素


```

## 深度优先是用栈来完成的，配合标志数组记录已经遍历过的位置
## 广度优先是用队列来做的，也要配合标志数组

深度优先有递归和非递归，这是因为函数调用的过程和栈一样。
广度优先只有非递归，即利用队列，没有递归做法
（因为有时候叫搜索，有时间叫遍历，索性就不加后面的词了）






# 算法和数据操作（来自剑指offer）

## 应该重点掌握二分查找，归并排序和快速排序，做到能随时正确，完整地写出代码
## 如果面试题要求在二维数组（可能具体表现为迷宫或者棋盘等）上搜索路径，那么可以尝试回溯法，通常适合使用回退递归，当不能用递归时，考虑用栈来模拟递归的过程
## 如果是求某个问题的最优解，且该问题可以分为多个子问题，则可以尝试动态规划，在用自上而下的递归思路分析dp问题时，会发现子问题直接存在重叠的更小子问题，为了避免重复计算，用自下而上的循环代码来实现，也就是把子问题的最优解先算出来并用数组（一般是一维或二维数组）保存下来，接来下基于子问题的解计算大问题的解
## 如果分解子问题存在某个特殊的选择，若使用这个特殊选择将一定能得到最优解，那么可能意味着该题可能适用于贪婪算法
## 位运算对于数字操作非常重要






//记录一下二分查找，快速排序，归并排序，冒泡排序, 面试前一定要多写几遍（连同二叉树的4种遍历方法的循环实现），形成肌肉记忆

## 二分查找
```java
    public int binarySearch(int[] nums, int low, int high, int target){
        int mid = 0;
        while (low<high){
            mid = (low+high)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid] > target){
                high = mid-1;
            }else {
                low = mid+1;
            }
        }
        return -1;
    }
```



## 二分查找找到第一个比target值大的数的索引, 没有(都比target小)则返回数组最大索引
```java

    static int binarySearch(ArrayList<Long> part, long target){
        int low = 0;
        int high = part.size()-1;
        int mid = (low+high)/2;
        while(low<high){
            mid = (low+high)/2;
            if(part.get(mid)==target){
                break;
            }else if(part.get(mid)>target){
                high = mid;
            }else{
                low = mid+1;
            }
        }

        if(part.get(mid)==target){
            while(mid<=(part.size()-1) && part.get(mid)==target ){
                mid++;
            }
            return Math.min(mid,high);
        }else if(part.get(mid)<target){
            while(mid<=(part.size()-1) && part.get(mid)<target){
                mid++;
            }
            return Math.min(mid,high);
        }else{
            while( mid>=0 && part.get(mid)>target){
                mid--;
            }
            return Math.max(mid+1, 0);
        }


    }


```

#排序算法

## 快速排序

两个关键点：
1.如果枢轴在数组最前面，则后指针先动,总之记住，要先把枢轴值给替换掉
2.所有的范围判断都不带等号，所有的值判断都带等号

```java
//快排有点像二分查找的感觉，排序先划分，再对每一个划分排序
void qSort(int[] nums, int start, int end){   
    if(start < end){
        int mid = partition(nums, start, end);
        qSort(nums, start, mid-1);
        qSort(nums, mid+1, end);
    }
}
int partition(int[] nums, int low, int high){    //把low指向的元素放到合适的位置，并返回这个新位置，作为一次划分
    int pivot = nums[low];
    int left = low;
    int right = high;
    while(left < right){
        /*一定一定要注意，这里后面的指针要先动，因为前指针指向的值已经被pivot保存起来了，后指针先动才能保证不丢失数字，否则前指针先动的话，一和后指针的值交换，后指针的值就丢了，所以这个是非常重要的一步，
如果枢轴是low，则要后指针先动，如果枢轴是high，则要前指针先动，    
        》不指向枢轴的指针先动
        》指针的判断都没有等于号
        》值的判断都有等于号
*/
        while(nums[right] >= pivot && left < right){   
            right--;
        }
        nums[left] = nums[right];
        while(nums[left] <= pivot && left < right){
            left++;
        }
        nums[right] = nums[left];
    }
    nums[left] = pivot;
    return left;
}

```

##冒泡排序
冒泡排序每趟下来，会让有序序列增加一个值，且有序序列一定是从一边开始的（不像快排，一趟下来是中间的一个数到达其位置上）
冒泡和插入排序都是一趟下来有序序列会多一个数，且有序序列一定在边上，但冒泡是每次数字只和邻居比，且一趟不是只盯着一个数（而是盯着此趟过程中出现的最小数）；而插入排序一趟只盯着一个数排到其正确位置上
```java
    public void bubbleSort(int[] list){
        int len = list.length;
        for(int i=0;i<len;i++){
            boolean change = false;
            //因为前i各元素已经是正序了，所以j只到i即可
            for(int j=len-1;j>i;j--){
                if(list[j]<list[j-1]){
                    int tmp = list[j];
                    list[j] = list[j-1];
                    list[j-1] = tmp;
                    change = true;
                }
            }
            //如果一趟排序之后没有任何元素交换，说明已经是正序了，直接退出即可
            if(!change){
                break;
            }
        }
    }
```

##堆排序
分为建堆和排序两个过程，建堆和排序都必须倒着遍历
建堆倒着遍历才能保证最大数在第一个，
排序倒着遍历才能保证最终是正序

```java

    public void heapSort(char[] chas){
        int n = chas.length;
        //一定要记得，建堆必须倒着遍历
        for(int i=n/2-1;i>=0;i--){
            heapify(chas, i, n);
        }

        //排序也必须倒着遍历
        for(int i=n-1;i>=0;i--){
            char tmp = chas[0];
            chas[0] = chas[i];
            chas[i]=tmp;
            heapify(chas, 0, i);
        }
    }

    public void heapify(char[] chas, int i, int n){
        if(i>=n) return;
        int left = i*2+1;
        int right = i*2+2;

        int tmp = i;
        if(left<n && chas[tmp]<chas[left]){
            tmp = left;
        }
        if(right<n && chas[tmp]<chas[right]){
            tmp = right;
        }
        if(tmp==i) return;
        else {
            char t = chas[i];
            chas[i] = chas[tmp];
            chas[tmp] = t;

            heapify(chas, tmp, n);
        }

    }
```






#图算法

##最短路径
Dijkstra 算法， Bellman-Ford 算法， Floyd 算法和 SPFA算法等。

##最小生成树算法
Prim算法和Kruskal’算法


# 二叉树的前中后层序遍历：

## 需要记住，前序只有一个循环，里面分别是访问值，加右孩子，加左孩子
## 中序也只有一个循环，里面有if（p是否为空）-else，不空就继续挪到左孩子，空就访问栈中值，然后挪到右孩子
## 后序是一个大循环里面有个小循环+if（栈顶右孩子是否为空or栈顶右孩子是否等于刚访问过的节点）-else判断，有一个pre节点保存上一个节点。用tmp节点保存当前栈顶节点的右孩子

## 前、中、后序都只用一个栈，前序不需要借助p，中后需要借助p。借助了p的，循环条件都要判断p不为空(或条件)

## 层序的话，如果只需要一个序列，则用一个队列，如果需要表明层级，则可以用两个队列，也可以用一个队列，但需要两个变量：一个变量表示当前层还没有打印的节点数，另一个变量表示下一层的节点数目

```java
class Solution {
    //中序遍历
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root==null) return new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        ArrayList<Integer> ans = new ArrayList<>();
        //中序遍历需要借助一个指针p
        TreeNode p = root;
        while(p!=null || !stk.empty()){
            if(p!=null){
                stk.push(p);
                p = p.left;
            }else{
                p = stk.pop();
                ans.add(p.val);
                p = p.right;
            }
        }
        return ans;
    }


    //前序遍历
    public List<Integer> preTraversal(TreeNode root) {
        if(root==null) return new ArrayList<>();
        //遍历的话,必须要辅助以数据结构，此时用两个栈
        Stack<TreeNode> stk = new Stack<>();
        ArrayList<Integer> ans = new ArrayList<>();
        stk.push(root);
        while(!stk.empty()){
            TreeNode node = stk.pop();
            ans.add(node.val);
            if(node.right!=null) stk.push(node.right);
            if(node.left!=null) stk.push(node.left);
        }
        return ans;
    }

    //后序遍历
    public List<Integer> postTraversal(TreeNode root) {
        if(root==null) return new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        ArrayList<Integer> ans = new ArrayList<>();
        TreeNode p = root;
        TreeNode pre = null;  //pre记录上一个已经输出的结点
        while(p!= null || !stk.empty()){
            while(p!=null){
                stk.push(p);
                p = p.left;
            }
            TreeNode tmp = stk.peek().right;  //在出栈之前，先判断栈顶元素的右孩子结点
            ////走到这里该节点的左子树已经处理完毕，如果该节点的右子树为空或者右子树已经处理过，则输出该节点
            if(tmp==null || tmp==pre){  //当前节点无右子树或右子树已经输出    
                p = stk.pop();
                ans.add(p.val); 
                pre = p;    //记录上一个已输出结点
                p = null;
            }else{
                p = tmp;  //处理右子树
            }
        }
        return ans;
    }


    //双队列层序遍历，可以表面哪个节点属于哪个层
    public List<Integer> levelTraversal2(TreeNode root) {
        LinkedList<TreeNode> queue1 = new LinkedList<>();
        LinkedList<TreeNode> queue2 = new LinkedList<>();
        ArrayList<Integer> res = new ArrayList<>();

        if(root!=null) queue1.offer(root);
        while(!queue1.isEmpty() || !queue2.isEmpty()){
            LinkedList<TreeNode> cur = queue1.isEmpty()?queue2:queue1;
            LinkedList<TreeNode> another = queue2.isEmpty()?queue2:queue1;
            //boolean isAdd = false;
            while(!cur.isEmpty()){
                TreeNode node = cur.poll();

                /*这个代码是只添加每层第一个节点
                if(!isAdd){
                    res.add(node.val);
                    isAdd = true;
                }
                */
                if(node.left!=null) another.offer(node.left);
                if(node.right!=null) another.offer(node.right);
            }
        }
        return res;
    }

    //单队列层序遍历，只能给出层序遍历序列
    public ArrayList<Integer> levelTraversal1(TreeNode root) {
        ArrayList<Integer> ans = new ArrayList<>();
        if(root==null) return ans;
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            ans.add(node.val);
            if(node.left!=null){
                queue.offer(node.left);
            }
            if(node.right!=null){
                queue.offer(node.right);
            }
        }
        return ans;
    }



    //单队列且能分行的打印的层序遍历，需要两个变量：一个变量表示当前层还没有打印的节点数，另一个变量表示下一层的节点数目
    public List<ArrayList<Integer>> levelTraversal3withLn(TreeNode root) {
        LinkedList<TreeNode> queue = new LinkedList<>();
        int toBeAdded = 1;
        int nextLevel = 0;
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        ArrayList<Integer> tmp = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            tmp.add(node.val);
            toBeAdded--;
            if(node.left!=null) {
                queue.offer(node.left);
                nextLevel++;
            }
            if(node.right!=null) {
                queue.offer(node.right);
                nextLevel++;
            }
            if(toBeAdded==0){
                res.add(tmp);
                toBeAdded = nextLevel;
                nextLevel = 0;
                tmp = new ArrayList<>();
            }
        }
        return res;
    }

}

```

遍历二叉树的神级方法：Morris遍历法，空间复杂度是O(1): c-p107


```java
//Morris中序遍历：
public void morrisIn(TreeNode root){
    if(root==null)
        return;
    TreeNode cur1 = root;
    TreeNode cur2 = null;
    while(cur1!=null){
        cur2 = cur1.left;
        if(cur2!=null){
            //不断找到cur2最右边的节点，如果已经指定了
            while(cur2.right!=null && cur2.right!=cur1){
                cur2 = cur2.right;
            }
            //让cur1左子树，即以cur2为根的树最右边的节点为cur1
            //且cur1成为cur1的左子树
            //到了这里，要么cur2的右孩子是空（说明还没设置）
            //要么cur2的右孩子就是cur1（已经设置了）
            if(cur2.right==null){
                cur2.right = cur1;
                cur1 = cur1.left;
                continue;
            }else{
                //如果已经设置了
                cur2.right=null;
            }

        }
        System.out.print(cur1.val + " ");
        cur1 = cur1.right;
    }
    System.out.println();
}


//Morris前序遍历
public void morrisPre(TreeNode root){
    if(root==null)
        return;
    TreeNode cur1 = root;
    TreeNode cur2 = null;
    while(cur1!=null){
        cur2 = cur1.left;
        if(cur2!=null){
            while(cur2.right!=null && cur2.right!=cur1){
                cur2 = cur2.right;
            }

            if(cur2.right==null){
                cur2.right = cur1;
                System.out.print(cur1.val + " ");
                cur1 = cur1.left;
                continue;
            }else{
                cur2.right=null;
            }
        }else{
            System.out.print(cur1.val + " ");
        }
        
        cur1 = cur1.right;
    }
    System.out.println();
}


//Morris后序遍历
public void morrisPost(TreeNode root){
    if(root==null)
        return;
    TreeNode cur1 = root;
    TreeNode cur2 = null;
    while(cur1!=null){
        cur2 = cur1.left;
        if(cur2!=null){
            while(cur2.right!=null && cur2.right!=cur1){
                cur2 = cur2.right;
            }

            if(cur2.right==null){
                cur2.right = cur1;
                cur1 = cur1.left;
                continue;
            }else{
                cur2.right=null;
                printRightEdge(cur1.left);
            }
        }
        cur1 = cur1.right;
    }
    printRightEdge(root);
    System.out.println();
}

//打印以root为根的子树的右边界
public void printRightEdge(TreeNode root){
    //打印倒序，则可以先翻转过来，然后打印完了再翻转过去
    TreeNode tail = reverseRightEdge(root);
    TreeNode cur = tail;
    while(cur!=null){
        System.out.print(cur.val + " ");
        cur = cur.right;
    }
    reverseRightEdge(tail);
}

//让 n1.right=n2, n2.right=n3  变成 n3.right=n2, n2.right=n1 就像是单链表的翻转一样。
public TreeNode reverseRightEdge(TreeNode from){
    TreeNode dummy = new TreeNode(0);
    dummy.right = null;
    TreeNode cur = from;
    while(cur!=null){
        TreeNode tmp = cur.right;
        cur.right = dummy.right;
        dummy.right = cur;
        cur = tmp;
    }
    return dummy.right;
}

```












排列和组合的写法：

//任一数组元素的组合都只有一种, 这里只记录不同元素不重复，同一个元素出现后可重复出现情况下的写法
这里是元素叠加成目标，还可能出现初始值减各元素成目标，其实就是换个符号


一般情况下的排列组合：
排列：
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

```java
import java.util.*;
public class Solution {

    public ArrayList<String> Permutation(String str) {
        ArrayList<String> ans = new ArrayList<>();
        if(str==null || str.length()==0) return ans;
        HashSet<String> set = new HashSet<>();
        trackBack(str, new boolean[str.length()], set, 0, new StringBuilder());
        ans = new ArrayList<>(set);
        Collections.sort(ans);
        return ans;
    }

    public void trackBack(String str, boolean[] flag, HashSet<String> ans, int curTotal, StringBuilder builder){
        if(curTotal==str.length()){
            ans.add(builder.toString());
            return;
        }
        for(int i=0;i<str.length();i++){
            if(flag[i]==false){
                flag[i]=true;
                builder.append(str.charAt(i));
                trackBack(str, flag, ans, curTotal+1, builder);
                flag[i]=false;
                builder.deleteCharAt(builder.length()-1);
            }

        }
    }
}
```
组合：
如abc，它们的组合有：a、b、c、ab、ac、bc、abc

```java
class Solution{

    public ArrayList<String> Combination(String str) {
        ArrayList<String> ans = new ArrayList<>();
        if(str==null || str.length()==0) return ans;
        HashSet<String> set = new HashSet<>();
        trackBack(0, str, set, new StringBuilder());
        ans = new ArrayList<>(set);
        //重写排序算法，短的位于长的前面，要是一样长才看字典序
        Collections.sort(ans, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                if(o1.length()!=o2.length())
                    return o1.length()-o2.length();
                else{
                    return o1.compareTo(o2);
                }
            }
        });
        return ans;
    }

    public void trackBack(int start, String str, HashSet<String> ans, StringBuilder builder){

        for(int i=start;i<str.length();i++){
            builder.append(str.charAt(i));
            ans.add(builder.toString());
            trackBack(i+1, str, ans, builder);
            builder.deleteCharAt(builder.length()-1);
        }
    }

}
```


对于数组中求和为给定值的排列组合

要求数组中和为target的不同数字能形成的组合：
```java
//
public void combination(int target, int current, int start, int len, int[] nums, List<List<Integer>> ans, List<Integer> numbers){
    if(current > target) return;  //要减的话这里就是 <

    //数字够了
    if(target==current){
        List<Integer> tmp = new ArrayList<>(numbers);
        ans.add(tmp);
        return;
    }

    for(int i=start;i < len;i++){
        numbers.add(nums[i]);
        combination(target, current+nums[i],i, len, nums, ans, numbers); //要减的话这里就是current-nums[i]
        numbers.remove(numbers.size()-1);
    }
}
```

对于数组中求和为给定值的排列(次序不同)

```java
//排列，不同的次序算不同种
//排列必须每次都从第一个元素开始遍历，但要剔除已经在numbers中的数字，所以用一个标志数组保存当前数是否已经出现过
public void arrangement(int len ,  int[] nums, boolean[] flags, List<List<Integer>> ans, List<Integer> numbers){
    if(numbers.size()==len){
        List<Integer> tmp = new ArrayList<>(numbers);
        ans.add(tmp);
        return;
    }

    for(int i=0;i < len;i++){
        if(flags[i]) continue; //该数字已经出现过了。
        numbers.add(nums[i]);
        flags[i] = true;
        arrangement(i+1, len, nums, ans, numbers);
        numbers.remove(numbers.size()-1);
        flags[i] = false;

    }
}
```



# 求最大公约数 gcd
```java
private int generateGCD(int a,int b){
    if (b==0) return a;
    else return generateGCD(b,a%b);        
}
```

# 计算组合数 C(a,b)
```java
int count = 1;
for (int i = 0; i < b; i++) {//求组合数c(a, b)
    count *= a - i;
    count /= (i + 1);
}
```



```
移位运算符 
<< 左移时，最左边的n位将被抛弃，最右边补0

>> 右移，正数右移左边补0，负数右移左边补1
>>>无符号右移，左边都补0
```

#大数的加减：
两个大数相加
大数问题都使用字符串很方便，核心还是逐个遍历两个字符串，从低位开始往高位加，但这里要注意，由于两数不一定一样长，所以要先让两个字符串一样长，
短的在高位补0

两数相减，等于大绝对值-小绝对值，要注意符号和绝对值大的数一致，两数相减的话直接就用绝对值减，要注意做单数位的减法，要先借位（借10），减完如果还不上，就标记借位，如果还的上（差大等于10），则不标记借位

```java
class Solution{
    String twoSum(String s1, String s2) {
        if(s1.charAt(0)!='-' && s2.charAt(0)!='-'){  //两个正数

            return addTwoPositive(s1,s2);
        }else if(s1.charAt(0)=='-' && s2.charAt(0)=='-'){  //两个负数
            return "-" + addTwoPositive(s1.substring(1), s2.substring(1));
        }else{
            boolean s1N = false;
            if(s1.charAt(0)=='-'){
                s1N = true;
                s1 =s1.substring(1);
            }else
                s2 = s2.substring(1);

            int cmp = compare(s1,s2);
            if(cmp==1){
                String res = subTwo(s1, s2);
                return s1N?"-"+res:res;
            }else if(cmp==-1){
                String res = subTwo(s2, s1);
                return s1N?res:"-"+res;
            }else{
                return "0";
            }
        }
    }

    //1 s1>s2,  0 s1==s2   -1 s1<s2
    int compare(String s1, String s2){
        int len1 = s1.length();
        int len2 = s2.length();
        if(len1>len2) return 1;
        else if(len1<len2) return -1;
        else{
            //从高位开始比
            for(int i=0;i<len1;i++){
                int num1 = s1.charAt(i) - '0';
                int num2 = s2.charAt(i) - '0';
                if(num1>num2) return 1;
                else if(num1<num2) return -1;
            }
            return 0;
        }

    }

    String subTwo(String s1, String s2){
        int len1 = s1.length();
        int len2 = s2.length();
        StringBuilder sb1 = new StringBuilder(s1);
        StringBuilder sb2 = new StringBuilder(s2);

        if (len1 > len2) {
            for (int i = 0; i < len1 - len2; i++) {
                sb2.insert(0, "0");
            }
        }

        int len = len1 > len2 ? len1 : len2;
        StringBuilder sb = new StringBuilder();
        int borrow = 0;
        for (int i = len - 1; i >= 0; i--) {
            int num1 = sb1.charAt(i) - '0';
            int num2 = sb2.charAt(i) - '0';
            //先借10
            int cur = 10 + num1 - num2 - borrow;
            //如果不够还，再往上借
            if (cur < 10) {
                cur = cur % 10;
                borrow = 1;
            } else { //够还就不借了
                cur = cur % 10;
                borrow = 0;
            }
            sb.insert(0, cur + "");
        }
        return sb.toString();
    }

    String addTwoPositive(String s1, String s2){
        int len1 = s1.length();
        int len2 = s2.length();
        StringBuilder sb1 = new StringBuilder(s1);
        StringBuilder sb2 = new StringBuilder(s2);

        if (len1 > len2) {
            for (int i = 0; i < len1 - len2; i++) {
                sb2.insert(0, "0");
            }
        } else {
            for (int i = 0; i < len2 - len1; i++) {
                sb1.insert(0, "0");
            }
        }

        int len = len1 > len2 ? len1 : len2;
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for (int i = len - 1; i >= 0; i--) {
            int num1 = sb1.charAt(i) - '0';
            int num2 = sb2.charAt(i) - '0';
            int cur = num1 + num2 + carry;
            if (cur >= 10) {
                cur = cur % 10;
                carry = 1;
            } else {
                carry = 0;
            }
            sb.insert(0, cur + "");
        }
        if (carry == 1) {
            sb.insert(0, 1 + "");
        }
        return sb.toString();
    }
}    
```

# 区别一下几个方法：

## lower_bound（val）
    函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置.
    注意：如果所有元素都小于val，则返回last的位置，且last的位置是越界的！！

## upper_bound(val)
    功能：函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置
    注意：返回查找元素的最后一个可安插位置，也就是“元素值>查找值”的第一个元素的位置。同样，如果val大于数组中全部元素，返回的是last。(注意：数组下标越界)

```java

    /**
     * C++中存在的两个方法，用java实现一下
     * ower_bound算法要求在已经按照非递减顺序排序的数组中找到第一个大于等于给定值key的那个数的索引，
     * 其基本实现原理是二分查找
     */
    public static int lowerBound(int[] nums,int l,int r,int target){
        while(l<r){
            int m = (l+r)/2;
            if(nums[m]>=target) r= m;
            else    l = m +1;
        }
        return l;
    }

    /**
     * upper_bound函数要求在按照非递减顺序排好序的数组中找到第一个大于给定值key的那个数索引，
     * 其基本实现原理是二分查找
     */
    public static int upperBound(int []nums ,int l,int r, int target){
        while(l<r){
            int m = (l+r)/2;
            if(nums[m]<=target) l = m+1;
            else    r = m;
        }
        return l;
    }
```

PS：
    lower_bound(val):返回容器中第一个值【大于或等于】val的元素的iterator位置。
    upper_bound(val): 返回容器中第一个值【大于】val的元素的iterator位置。


## floor(E e) 方法返回在这个集合中小于或者等于给定元素的最大元素，如果不存在这样的元素,返回null.

## ceiling(E e) 方法返回在这个集合中大于或者等于给定元素的最小元素，如果不存在这样的元素,返回null.


注意ceil和floor是分正0和负0的！
What is displayed when the following is executed;
```java
double d1=-0.5;
System.out.println("Ceil d1="+Math.ceil(d1));
System.out.println("floor d1="+Math.floor(d1));
//out：
Ceil d1=-0.0
floor d1=-1.0
```
这里主要是有一点：
>Math.ceil(d1) 
ceil 方法上有这么一段注释：If the argument value is less than zero but greater than -1.0, then the result is negative zero
如果参数小于0且大于-1.0，结果为 -0

>Math.floor(d1)
ceil 和 floor 方法 上都有一句话：If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument，意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，
如果是 -0.0，那么其结果是 -0.0
但要注意的是，拿-0与0比较大小时，得到的结果是相等



## java 数值转为ASCII对应字符
首先保证是数
然后在前面加上 (char) 就行了。










